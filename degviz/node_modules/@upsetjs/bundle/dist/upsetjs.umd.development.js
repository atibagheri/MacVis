/**
 * @upsetjs/bundle
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2022 Samuel Gratzl <sam@sgratzl.com>
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.UpSetJS = {}));
})(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }

  var n,
      l$1,
      u$1,
      t$1,
      r$1,
      o$1,
      f$1,
      e$1 = {},
      c$1 = [],
      s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

  function a$1(n, l) {
    for (var u in l) {
      n[u] = l[u];
    }

    return n;
  }

  function h$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }

  function v$1(l, u, i) {
    var t,
        r,
        o,
        f = {};

    for (o in u) {
      "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    }

    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (o in l.defaultProps) {
      void 0 === f[o] && (f[o] = l.defaultProps[o]);
    }
    return y$1(l, f, t, r, null);
  }

  function y$1(n, i, t, r, o) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: r,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o ? ++u$1 : o
    };
    return null == o && null != l$1.vnode && l$1.vnode(f), f;
  }

  function p$1() {
    return {
      current: null
    };
  }

  function d$1(n) {
    return n.children;
  }

  function _$1(n, l) {
    this.props = n, this.context = l;
  }

  function k$2(n, l) {
    if (null == l) return n.__ ? k$2(n.__, n.__.__k.indexOf(n) + 1) : null;

    for (var u; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    }

    return "function" == typeof n.type ? k$2(n) : null;
  }

  function b$1(n) {
    var l, u;

    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }
      }

      return b$1(n);
    }
  }

  function m$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$1)(g$2);
  }

  function g$2() {
    for (var n; g$2.__r = t$1.length;) {
      n = t$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t$1 = [], n.some(function (n) {
        var l, u, i, t, r, o;
        n.__d && (r = (t = (l = n).__v).__e, (o = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(o, t, i, l.__n, void 0 !== o.ownerSVGElement, null != t.__h ? [r] : null, u, null == r ? k$2(t) : r, t.__h), z$1(u, t), t.__e != r && b$1(t)));
      });
    }
  }

  function w$2(n, l, u, i, t, r, o, f, s, a) {
    var h,
        v,
        p,
        _,
        b,
        m,
        g,
        w = i && i.__k || c$1,
        A = w.length;

    for (u.__k = [], h = 0; h < l.length; h++) {
      if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$1(null, _, null, null, _) : Array.isArray(_) ? y$1(d$1, {
        children: _
      }, null, null, null) : _.__b > 0 ? y$1(_.type, _.props, _.key, null, _.__v) : _)) {
        if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
          if ((p = w[v]) && _.key == p.key && _.type === p.type) {
            w[v] = void 0;
            break;
          }

          p = null;
        }
        j$2(n, _, p = p || e$1, t, r, o, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && _.__k === p.__k ? _.__d = s = x$2(_, s, n) : s = P$1(n, _, p, w, b, s), "function" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k$2(p));
      }
    }

    for (u.__e = m, h = A; h--;) {
      null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k$2(i, h + 1)), N$1(w[h], w[h]));
    }

    if (g) for (h = 0; h < g.length; h++) {
      M$1(g[h], g[++h], g[++h]);
    }
  }

  function x$2(n, l, u) {
    for (var i, t = n.__k, r = 0; t && r < t.length; r++) {
      (i = t[r]) && (i.__ = n, l = "function" == typeof i.type ? x$2(i, l, u) : P$1(u, i, i, t, i.__e, l));
    }

    return l;
  }

  function A$2(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      A$2(n, l);
    }) : l.push(n)), l;
  }

  function P$1(n, l, u, i, t, r) {
    var o, f, e;
    if (void 0 !== l.__d) o = l.__d, l.__d = void 0;else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;else {
      for (f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 2) {
        if (f == t) break n;
      }

      n.insertBefore(t, r), o = r;
    }
    return void 0 !== o ? o : t.nextSibling;
  }

  function C$1(n, l, u, i, t) {
    var r;

    for (r in u) {
      "children" === r || "key" === r || r in l || H$1(n, r, null, u[r], i);
    }

    for (r in l) {
      t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || H$1(n, r, l[r], u[r], i);
    }
  }

  function $$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s$1.test(l) ? u : u + "px";
  }

  function H$1(n, l, u, i, t) {
    var r;

    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
          u && l in u || $$1(n.style, l, "");
        }
        if (u) for (l in u) {
          i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      }
    } else if ("o" === l[0] && "n" === l[1]) r = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? T$2 : I$1, r) : n.removeEventListener(l, r ? T$2 : I$1, r);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
    }
  }

  function I$1(n) {
    this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
  }

  function T$2(n) {
    this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
  }

  function j$2(n, u, i, t, r, o, f, e, c) {
    var s,
        h,
        v,
        y,
        p,
        k,
        b,
        m,
        g,
        x,
        A,
        P = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [e]), (s = l$1.__b) && s(u);

    try {
      n: if ("function" == typeof P) {
        if (m = u.props, g = (s = P.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in P && P.prototype.render ? u.__c = h = new P(m, x) : (u.__c = h = new _$1(m, x), h.constructor = P, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != P.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, P.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == P.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
          if (null == P.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
            h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), h.__h.length && f.push(h);
            break n;
          }

          null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
            h.componentDidUpdate(y, p, k);
          });
        }
        h.context = x, h.props = m, h.state = h.__s, (s = l$1.__r) && s(u), h.__d = !1, h.__v = u, h.__P = n, s = h.render(h.props, h.state, h.context), h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), A = null != s && s.type === d$1 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(A) ? A : [A], u, i, t, r, o, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, r, o, f, c);

      (s = l$1.diffed) && s(u);
    } catch (n) {
      u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$1.__e(n, u, i);
    }
  }

  function z$1(n, u) {
    l$1.__c && l$1.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$1.__e(n, u.__v);
      }
    });
  }

  function L$1(l, u, i, t, r, o, f, c) {
    var s,
        a,
        v,
        y = i.props,
        p = u.props,
        d = u.type,
        _ = 0;
    if ("svg" === d && (r = !0), null != o) for (; _ < o.length; _++) {
      if ((s = o[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, o[_] = null;
        break;
      }
    }

    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = r ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), o = null, c = !1;
    }

    if (null === d) y === p || c && l.data === p || (l.data = p);else {
      if (o = o && n.call(l.childNodes), a = (y = i.props || e$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
        if (null != o) for (y = {}, _ = 0; _ < l.attributes.length; _++) {
          y[l.attributes[_].name] = l.attributes[_].value;
        }
        (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
      }

      if (C$1(l, p, y, r, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, r && "foreignObject" !== d, o, f, o ? o[0] : i.__k && k$2(i, 0), c), null != o) for (_ = o.length; _--;) {
        null != o[_] && h$1(o[_]);
      }
      c || ("value" in p && void 0 !== (_ = p.value) && (_ !== y.value || _ !== l.value || "progress" === d && !_) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
    }
    return l;
  }

  function M$1(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$1.__e(n, i);
    }
  }

  function N$1(n, u, i) {
    var t, r;

    if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$1.__e(n, u);
      }
      t.base = t.__P = null;
    }

    if (t = n.__k) for (r = 0; r < t.length; r++) {
      t[r] && N$1(t[r], u, "function" != typeof n.type);
    }
    i || null == n.__e || h$1(n.__e), n.__e = n.__d = void 0;
  }

  function O$1(n, l, u) {
    return this.constructor(n, u);
  }

  function S$1(u, i, t) {
    var r, o, f;
    l$1.__ && l$1.__(u, i), o = (r = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!r && t || i).__k = v$1(d$1, null, [u]), o || e$1, e$1, void 0 !== i.ownerSVGElement, !r && t ? [t] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), z$1(f, u);
  }

  function q$1(n, l) {
    S$1(n, l, q$1);
  }

  function B$1(l, u, i) {
    var t,
        r,
        o,
        f = a$1({}, l.props);

    for (o in u) {
      "key" == o ? t = u[o] : "ref" == o ? r = u[o] : f[o] = u[o];
    }

    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), y$1(l.type, f, t || l.key, r || l.ref, null);
  }

  function D$1(n, l) {
    var u = {
      __c: l = "__cC" + f$1++,
      __: n,
      Consumer: function Consumer(n, l) {
        return n.children(l);
      },
      Provider: function Provider(n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(m$1);
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;

          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }

  n = c$1.slice, l$1 = {
    __e: function __e(n, l) {
      for (var u, i, t; l = l.__;) {
        if ((u = l.__c) && !u.__) try {
          if ((i = u.constructor) && null != i.getDerivedStateFromError && (u.setState(i.getDerivedStateFromError(n)), t = u.__d), null != u.componentDidCatch && (u.componentDidCatch(n), t = u.__d), t) return u.__E = u;
        } catch (l) {
          n = l;
        }
      }

      throw n;
    }
  }, u$1 = 0, _$1.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m$1(this));
  }, _$1.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
  }, _$1.prototype.render = d$1, t$1 = [], r$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$2.__r = 0, f$1 = 0;

  var t,
      u,
      r,
      o = 0,
      i = [],
      c = l$1.__b,
      f = l$1.__r,
      e = l$1.diffed,
      a = l$1.__c,
      v = l$1.unmount;

  function m(t, r) {
    l$1.__h && l$1.__h(u, t, o || r), o = 0;
    var i = u.__H || (u.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({}), i.__[t];
  }

  function l(n) {
    return o = 1, p(w$1, n);
  }

  function p(n, r, o) {
    var i = m(t++, 2);
    return i.t = n, i.__c || (i.__ = [o ? o(r) : w$1(void 0, r), function (n) {
      var t = i.t(i.__[0], n);
      i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
    }], i.__c = u), i.__;
  }

  function y(r, o) {
    var i = m(t++, 3);
    !l$1.__s && k$1(i.__H, o) && (i.__ = r, i.__H = o, u.__H.__h.push(i));
  }

  function h(r, o) {
    var i = m(t++, 4);
    !l$1.__s && k$1(i.__H, o) && (i.__ = r, i.__H = o, u.__h.push(i));
  }

  function s(n) {
    return o = 5, d(function () {
      return {
        current: n
      };
    }, []);
  }

  function _(n, t, u) {
    o = 6, h(function () {
      "function" == typeof n ? n(t()) : n && (n.current = t());
    }, null == u ? u : u.concat(n));
  }

  function d(n, u) {
    var r = m(t++, 7);
    return k$1(r.__H, u) && (r.__ = n(), r.__H = u, r.__h = n), r.__;
  }

  function A$1(n, t) {
    return o = 8, d(function () {
      return n;
    }, t);
  }

  function F$1(n) {
    var r = u.context[n.__c],
        o = m(t++, 9);
    return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;
  }

  function T$1(t, u) {
    l$1.useDebugValue && l$1.useDebugValue(u ? u(t) : t);
  }

  function x$1() {
    var t;

    for (i.sort(function (n, t) {
      return n.__v.__b - t.__v.__b;
    }); t = i.pop();) {
      if (t.__P) try {
        t.__H.__h.forEach(g$1), t.__H.__h.forEach(j$1), t.__H.__h = [];
      } catch (u) {
        t.__H.__h = [], l$1.__e(u, t.__v);
      }
    }
  }

  l$1.__b = function (n) {
    u = null, c && c(n);
  }, l$1.__r = function (n) {
    f && f(n), t = 0;
    var r = (u = n.__c).__H;
    r && (r.__h.forEach(g$1), r.__h.forEach(j$1), r.__h = []);
  }, l$1.diffed = function (t) {
    e && e(t);
    var o = t.__c;
    o && o.__H && o.__H.__h.length && (1 !== i.push(o) && r === l$1.requestAnimationFrame || ((r = l$1.requestAnimationFrame) || function (n) {
      var t,
          u = function u() {
        clearTimeout(r), b && cancelAnimationFrame(t), setTimeout(n);
      },
          r = setTimeout(u, 100);

      b && (t = requestAnimationFrame(u));
    })(x$1)), u = null;
  }, l$1.__c = function (t, u) {
    u.some(function (t) {
      try {
        t.__h.forEach(g$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || j$1(n);
        });
      } catch (r) {
        u.some(function (n) {
          n.__h && (n.__h = []);
        }), u = [], l$1.__e(r, t.__v);
      }
    }), a && a(t, u);
  }, l$1.unmount = function (t) {
    v && v(t);
    var u,
        r = t.__c;
    r && r.__H && (r.__H.__.forEach(function (n) {
      try {
        g$1(n);
      } catch (n) {
        u = n;
      }
    }), u && l$1.__e(u, r.__v));
  };
  var b = "function" == typeof requestAnimationFrame;

  function g$1(n) {
    var t = u,
        r = n.__c;
    "function" == typeof r && (n.__c = void 0, r()), u = t;
  }

  function j$1(n) {
    var t = u;
    n.__c = n.__(), u = t;
  }

  function k$1(n, t) {
    return !n || n.length !== t.length || t.some(function (t, u) {
      return t !== n[u];
    });
  }

  function w$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }

  function S(n, t) {
    for (var e in t) {
      n[e] = t[e];
    }
    return n;
  }
  function C(n, t) {
    for (var e in n) {
      if ("__source" !== e && !(e in t)) return !0;
    }
    for (var r in t) {
      if ("__source" !== r && n[r] !== t[r]) return !0;
    }
    return !1;
  }
  function E(n) {
    this.props = n;
  }
  function g(n, t) {
    function e(n) {
      var e = this.props.ref,
          r = e == n.ref;
      return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : C(this.props, n);
    }
    function r(t) {
      return this.shouldComponentUpdate = e, v$1(n, t);
    }
    return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
  }
  (E.prototype = new _$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var w = l$1.__b;
  l$1.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
  };
  var R = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.forward_ref") || 3911;
  function x(n) {
    function t(t, e) {
      var r = S({}, t);
      return delete r.ref, n(r, (e = t.ref || e) && ("object" != _typeof(e) || "current" in e) ? e : null);
    }
    return t.$$typeof = R, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var N = function N(n, t) {
    return null == n ? null : A$2(A$2(n).map(t));
  },
      k = {
    map: N,
    forEach: N,
    count: function count(n) {
      return n ? A$2(n).length : 0;
    },
    only: function only(n) {
      var t = A$2(n);
      if (1 !== t.length) throw "Children.only";
      return t[0];
    },
    toArray: A$2
  },
      A = l$1.__e;
  l$1.__e = function (n, t, e) {
    if (n.then) for (var r, u = t; u = u.__;) {
      if ((r = u.__c) && r.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), r.__c(n, t);
    }
    A(n, t, e);
  };
  var O = l$1.unmount;
  function L() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function U(n) {
    var t = n.__.__c;
    return t && t.__e && t.__e(n);
  }
  function F(n) {
    var t, e, r;
    function u(u) {
      if (t || (t = n()).then(function (n) {
        e = n["default"] || n;
      }, function (n) {
        r = n;
      }), r) throw r;
      if (!e) throw t;
      return v$1(e, u);
    }
    return u.displayName = "Lazy", u.__f = !0, u;
  }
  function M() {
    this.u = null, this.o = null;
  }
  l$1.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
  }, (L.prototype = new _$1()).__c = function (n, t) {
    var e = t.__c,
        r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = U(r.__v),
        o = !1,
        i = function i() {
      o || (o = !0, e.__R = null, u ? u(l) : l());
    };
    e.__R = i;
    var l = function l() {
      if (! --r.__u) {
        if (r.state.__e) {
          var n = r.state.__e;
          r.__v.__k[0] = function n(t, e, r) {
            return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
          }(n, n.__c.__P, n.__c.__O);
        }
        var t;
        for (r.setState({
          __e: r.__b = null
        }); t = r.t.pop();) {
          t.forceUpdate();
        }
      }
    },
        c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __e: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, L.prototype.componentWillUnmount = function () {
    this.t = [];
  }, L.prototype.render = function (n, t) {
    if (this.__b) {
      if (this.__v.__k) {
        var e = document.createElement("div"),
            r = this.__v.__k[0].__c;
        this.__v.__k[0] = function n(t, e, r) {
          return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
            "function" == typeof n.__c && n.__c();
          }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
            return n(t, e, r);
          })), t;
        }(this.__b, e, r.__O = r.__P);
      }
      this.__b = null;
    }
    var u = t.__e && v$1(d$1, null, n.fallback);
    return u && (u.__h = null), [v$1(d$1, null, t.__e ? null : n.children), u];
  };
  var T = function T(n, t, e) {
    if (++e[1] === e[0] && n.o["delete"](t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) {
        e.pop()();
      }
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  function D(n) {
    return this.getChildContext = function () {
      return n.context;
    }, n.children;
  }
  function I(n) {
    var t = this,
        e = n.i;
    t.componentWillUnmount = function () {
      S$1(null, t.l), t.l = null, t.i = null;
    }, t.i && t.i !== e && t.componentWillUnmount(), n.__v ? (t.l || (t.i = e, t.l = {
      nodeType: 1,
      parentNode: e,
      childNodes: [],
      appendChild: function appendChild(n) {
        this.childNodes.push(n), t.i.appendChild(n);
      },
      insertBefore: function insertBefore(n, e) {
        this.childNodes.push(n), t.i.appendChild(n);
      },
      removeChild: function removeChild(n) {
        this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), t.i.removeChild(n);
      }
    }), S$1(v$1(D, {
      context: t.context
    }, n.__v), t.l)) : t.l && t.componentWillUnmount();
  }
  function W(n, t) {
    return v$1(I, {
      __v: n,
      i: t
    });
  }
  (M.prototype = new _$1()).__e = function (n) {
    var t = this,
        e = U(t.__v),
        r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function o() {
        t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, M.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = A$2(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) {
      this.o.set(t[e], this.u = [1, 0, this.u]);
    }
    return n.children;
  }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      T(n, e, t);
    });
  };
  var j = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
      P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
      V = "undefined" != typeof document,
      z = function z(n) {
    return ("undefined" != typeof Symbol && "symbol" == _typeof(Symbol()) ? /fil|che|rad/i : /fil|che|ra/i).test(n);
  };
  function B(n, t, e) {
    return null == t.__k && (t.textContent = ""), S$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
  }
  function $(n, t, e) {
    return q$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
  }
  _$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
    Object.defineProperty(_$1.prototype, n, {
      configurable: !0,
      get: function get() {
        return this["UNSAFE_" + n];
      },
      set: function set(t) {
        Object.defineProperty(this, n, {
          configurable: !0,
          writable: !0,
          value: t
        });
      }
    });
  });
  var H = l$1.event;
  function Z() {}
  function Y() {
    return this.cancelBubble;
  }
  function q() {
    return this.defaultPrevented;
  }
  l$1.event = function (n) {
    return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = q, n.nativeEvent = n;
  };
  var G,
      J = {
    configurable: !0,
    get: function get() {
      return this["class"];
    }
  },
      K = l$1.vnode;
  l$1.vnode = function (n) {
    var t = n.type,
        e = n.props,
        r = e;
    if ("string" == typeof t) {
      var u = -1 === t.indexOf("-");
      for (var o in r = {}, e) {
        var i = e[o];
        V && "children" === o && "noscript" === t || "value" === o && "defaultValue" in e && null == i || ("defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !z(e.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp)/.test(o) ? o = o.toLowerCase() : u && P.test(o) ? o = o.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i && (i = void 0), r[o] = i);
      }
      "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$2(e.children).forEach(function (n) {
        n.props.selected = -1 != r.value.indexOf(n.props.value);
      })), "select" == t && null != r.defaultValue && (r.value = A$2(e.children).forEach(function (n) {
        n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
      })), n.props = r, e["class"] != e.className && (J.enumerable = "className" in e, null != e.className && (r["class"] = e.className), Object.defineProperty(r, "className", J));
    }
    n.$$typeof = j, K && K(n);
  };
  var Q = l$1.__r;
  l$1.__r = function (n) {
    Q && Q(n), G = n.__c;
  };
  var X = {
    ReactCurrentDispatcher: {
      current: {
        readContext: function readContext(n) {
          return G.__n[n.__c].props.value;
        }
      }
    }
  };
  function tn(n) {
    return v$1.bind(null, n);
  }
  function en(n) {
    return !!n && n.$$typeof === j;
  }
  function rn(n) {
    return en(n) ? B$1.apply(null, arguments) : n;
  }
  function un(n) {
    return !!n.__k && (S$1(null, n), !0);
  }
  function on(n) {
    return n && (n.base || 1 === n.nodeType && n) || null;
  }
  var ln = function ln(n, t) {
    return n(t);
  },
      cn = function cn(n, t) {
    return n(t);
  };
  var React = {
    useState: l,
    useReducer: p,
    useEffect: y,
    useLayoutEffect: h,
    useRef: s,
    useImperativeHandle: _,
    useMemo: d,
    useCallback: A$1,
    useContext: F$1,
    useDebugValue: T$1,
    version: "17.0.2",
    Children: k,
    render: B,
    hydrate: $,
    unmountComponentAtNode: un,
    createPortal: W,
    createElement: v$1,
    createContext: D$1,
    createFactory: tn,
    cloneElement: rn,
    createRef: p$1,
    Fragment: d$1,
    isValidElement: en,
    findDOMNode: on,
    Component: _$1,
    PureComponent: E,
    memo: g,
    forwardRef: x,
    flushSync: cn,
    unstable_batchedUpdates: ln,
    StrictMode: d$1,
    Suspense: L,
    SuspenseList: M,
    lazy: F,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: X
  };

  function len(a) {
    return a instanceof Set ? a.size : a.length;
  }
  function setOverlapFactory(a, toElemKey) {
    var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
    var setA = elems.size;
    var same = {
      setA: setA,
      setB: setA,
      union: setA,
      intersection: setA
    };
    return function (b) {
      if (b === a) {
        return same;
      }
      var intersection = 0;
      b.forEach(function (e) {
        if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
          intersection++;
        }
      });
      var setB = len(b);
      return {
        setA: setA,
        setB: setB,
        intersection: intersection,
        union: setA + setB - intersection
      };
    };
  }
  function setOverlap(a, b, toElemKey) {
    if (len(a) < len(b) || a instanceof Set) {
      return setOverlapFactory(a, toElemKey)(b);
    }
    var r = setOverlapFactory(b, toElemKey)(a);
    return Object.assign({}, r, {
      setA: r.setB,
      setB: r.setA
    });
  }
  function setElemOverlapFactory(a, toElemKey) {
    var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
    var setA = Array.isArray(a) ? a : Array.from(a);
    var same = {
      setA: setA,
      setB: setA,
      union: setA,
      intersection: setA
    };
    return function (b) {
      if (b === a) {
        return same;
      }
      var intersection = [];
      var union = setA.slice();
      b.forEach(function (e) {
        if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
          intersection.push(e);
        } else {
          union.push(e);
        }
      });
      return {
        setA: setA,
        setB: Array.isArray(b) ? b : Array.from(b),
        intersection: intersection,
        union: union
      };
    };
  }
  function setElemOverlap(a, b, toElemKey) {
    if (len(a) < len(b) || a instanceof Set) {
      return setElemOverlapFactory(a, toElemKey)(b);
    }
    var r = setElemOverlapFactory(b, toElemKey)(a);
    return Object.assign({}, r, {
      setA: r.setB,
      setB: r.setA
    });
  }
  function setElemIntersectionFactory(a, toElemKey) {
    var arr = a instanceof Set ? Array.from(a) : a;
    var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set(arr.map(toElemKey));
    return function (b) {
      if (b === a) {
        return arr;
      }
      var intersection = [];
      b.forEach(function (e) {
        if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
          intersection.push(e);
        }
      });
      return intersection;
    };
  }
  function isElemQuery(q) {
    return Array.isArray(q.elems);
  }
  function isCalcQuery(q) {
    return typeof q.overlap === 'function';
  }
  function isSetQuery(q) {
    return q.set != null;
  }
  function queryOverlap(query, what, toElemKey) {
    if (isCalcQuery(query)) {
      return query.overlap;
    }
    if (isSetQuery(query) && query.set.overlap) {
      return query.set.overlap;
    }
    var f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
    return function (s) {
      if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {
        return s.overlap(query.elems);
      }
      if (s.overlap && isSetQuery(query)) {
        return s.overlap(query.set);
      }
      return f(s.elems)[what];
    };
  }
  function queryElemOverlap(query, what, toElemKey) {
    if (isCalcQuery(query)) {
      return function () {
        return null;
      };
    }
    if (what === 'intersection') {
      var _f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
      return function (s) {
        return _f(s.elems);
      };
    }
    var f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
    return function (s) {
      return f(s.elems)[what];
    };
  }
  function isBaseSet(v) {
    var vt = v;
    return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);
  }
  function isSet(v) {
    return isBaseSet(v) && v.type === 'set';
  }
  function isSetCombination(v) {
    var vt = v;
    return isBaseSet(v) && ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) && vt.sets instanceof Set && typeof vt.degree === 'number';
  }
  function isSetLike$1(v) {
    return isSet(v) || isSetCombination(v);
  }
  function isGenerateSetCombinationOptions(v) {
    var vt = v;
    return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));
  }
  function isUpSetQuery(v) {
    var vt = v;
    return v != null && typeof vt.name === 'string' && typeof vt.color === 'string' && (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt));
  }
  function byName(a, b) {
    return a.name.localeCompare(b.name);
  }
  function byCardinality(a, b) {
    return b.cardinality - a.cardinality;
  }
  function byDegree(a, b) {
    return a.degree - b.degree;
  }
  function byComposite(func) {
    return function (a, b) {
      return func.reduce(function (acc, f) {
        return acc === 0 ? f(a, b) : acc;
      }, 0);
    };
  }
  function negate(func) {
    return function (a, b) {
      return -func(a, b);
    };
  }
  function byGroup(sets) {
    return function (a, b) {
      var fixNotFound = function fixNotFound(v) {
        return v < 0 ? Number.POSITIVE_INFINITY : v;
      };
      var aIndex = fixNotFound(sets.findIndex(function (s) {
        return a.sets.has(s);
      }));
      var bIndex = fixNotFound(sets.findIndex(function (s) {
        return b.sets.has(s);
      }));
      return aIndex - bIndex;
    };
  }
  function fromSetName(sets) {
    var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /[∩∪&|]/;
    var byName = new Map(sets.map(function (s) {
      return [s.name, s];
    }));
    return function (s) {
      return s.name.split(symbol).map(function (setName) {
        return byName.get(setName.trim());
      });
    };
  }
  function toOrder$1(sets, order) {
    if (!order) {
      return byName;
    }
    var arr = Array.isArray(order) ? order : [order];
    if (arr.length === 0) {
      return byName;
    }
    return byComposite(arr.map(function (o) {
      switch (o) {
        case 'cardinality':
        case 'cardinality:desc':
          return byCardinality;
        case 'cardinality:asc':
          return negate(byCardinality);
        case 'name:desc':
          return negate(byName);
        case 'degree':
        case 'degree:asc':
          return byDegree;
        case 'degree:desc':
          return negate(byDegree);
        case 'group':
        case 'group:asc':
          return byGroup(sets);
        case 'group:desc':
          return negate(byGroup(sets));
        default:
          return byName;
      }
    }));
  }
  function postprocessCombinations(sets, combinations) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var r = combinations;
    if (options.order) {
      r = r.sort(toOrder$1(sets, options.order));
    }
    if (options.limit != null) {
      return r.slice(0, options.limit);
    }
    return r;
  }
  function asCombination(set, type, toSets) {
    var sets = toSets(set);
    return Object.assign({
      type: type,
      cardinality: set.elems.length,
      sets: new Set(sets),
      degree: sets.length
    }, set);
  }
  function asCombinations(sets, type, toSets) {
    return sets.map(function (set) {
      return asCombination(set, type, toSets);
    });
  }
  var SET_JOINERS = {
    distinctIntersection: ' ∩ ',
    intersection: ' ∩ ',
    union: ' ∪ ',
    composite: ','
  };
  function parseColor(color) {
    if (!color) {
      return [255, 255, 255];
    }
    var hex = color.match(/#([\da-f]{2})([\da-f]{2})([\da-f]{2})/i);
    if (hex) {
      return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];
    }
    var rgb = color.match(/\(([\d]+)[, ]([\d]+)[, ]([\d]+)\)/i);
    if (rgb) {
      return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];
    }
    return [255, 255, 255];
  }
  function mergeColors(colors) {
    if (colors.length === 1) {
      return colors[0];
    }
    if (colors.every(function (d) {
      return d == null;
    })) {
      return undefined;
    }
    var rgb = colors.map(parseColor);
    var r = Math.floor(rgb.reduce(function (acc, v) {
      return acc + v[0];
    }, 0) / rgb.length);
    var g = Math.floor(rgb.reduce(function (acc, v) {
      return acc + v[1];
    }, 0) / rgb.length);
    var b = Math.floor(rgb.reduce(function (acc, v) {
      return acc + v[2];
    }, 0) / rgb.length);
    return "#".concat(r.toString(16)).concat(g.toString(16)).concat(b.toString(16));
  }
  function generateName$1(combo, setIndex, joiner) {
    var sorted = Array.from(combo).sort(function (a, b) {
      return setIndex.get(a) - setIndex.get(b);
    });
    return sorted.length === 1 ? sorted[0].name : "(".concat(sorted.map(function (d) {
      return d.name;
    }).join(joiner), ")");
  }
  function generateSet(type, name, combo, elems, mergeColors) {
    return {
      type: combo.size === 0 ? 'composite' : type,
      elems: elems,
      color: mergeColors(Array.from(combo).map(function (s) {
        return s.color;
      })),
      sets: combo,
      name: name,
      cardinality: elems.length,
      degree: combo.size
    };
  }
  function mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {
    var merged = new Set(a.sets);
    b.sets.forEach(function (s) {
      return merged.add(s);
    });
    var name = generateName$1(merged, setIndex, SET_JOINERS[type]);
    if (a.cardinality === 0 || b.cardinality === 0) {
      return generateSet(type, name, merged, [], mergeColors);
    }
    var small = a;
    var big = b;
    if (a.cardinality > b.cardinality) {
      small = b;
      big = a;
    }
    var keySet = new Set();
    var bigLookup = lookup.get(big);
    var elems = [];
    var l = small.elems.length;
    for (var i = 0; i < l; i++) {
      var e = small.elems[i];
      var key = toKey(e);
      if (!bigLookup.has(key)) {
        continue;
      }
      keySet.add(key);
      elems.push(e);
    }
    var r = generateSet(type, name, merged, elems, mergeColors);
    lookup.set(r, keySet);
    return r;
  }
  function mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {
    var merged = new Set(a.sets);
    b.sets.forEach(function (s) {
      return merged.add(s);
    });
    var name = generateName$1(merged, setIndex, SET_JOINERS[type]);
    if (a.cardinality === 0) {
      var _r = generateSet(type, name, merged, b.elems, mergeColors);
      lookup.set(_r, lookup.get(b));
      return _r;
    }
    if (b.cardinality === 0) {
      var _r2 = generateSet(type, name, merged, a.elems, mergeColors);
      lookup.set(_r2, lookup.get(a));
      return _r2;
    }
    var small = a;
    var big = b;
    if (a.cardinality > b.cardinality) {
      small = b;
      big = a;
    }
    var keySet = new Set(lookup.get(big));
    var bigLookup = lookup.get(big);
    var elems = big.elems.slice();
    small.elems.forEach(function (e) {
      var key = toKey(e);
      if (bigLookup.has(key)) {
        return;
      }
      keySet.add(key);
      elems.push(e);
    });
    var r = generateSet(type, name, merged, elems, mergeColors);
    lookup.set(r, keySet);
    return r;
  }
  function generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {
    if (typeof notPartOfAnySet === 'number') {
      return {
        type: 'composite',
        elems: [],
        color: mergeColors ? mergeColors([]) : undefined,
        sets: new Set(),
        name: '()',
        cardinality: notPartOfAnySet,
        overlap: function overlap(s) {
          return s === this || isSetLike$1(s) && s.name === this.name && s.cardinality === this.cardinality ? this.cardinality : 0;
        },
        degree: 0
      };
    }
    if (Array.isArray(notPartOfAnySet)) {
      return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);
    }
    var lookupArr = Array.from(lookup.values());
    var elems = allElements.filter(function (e) {
      var k = toKey(e);
      return lookupArr.every(function (s) {
        return !s.has(k);
      });
    });
    return generateSet(type, '()', new Set(), elems, mergeColors);
  }
  function generateCombinations(sets) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$type = options.type,
        type = _options$type === void 0 ? 'intersection' : _options$type,
        _options$min = options.min,
        min = _options$min === void 0 ? 0 : _options$min,
        _options$max = options.max,
        max = _options$max === void 0 ? Number.POSITIVE_INFINITY : _options$max,
        _options$empty = options.empty,
        empty = _options$empty === void 0 ? false : _options$empty,
        _options$elems = options.elems,
        allElements = _options$elems === void 0 ? [] : _options$elems,
        notPartOfAnySet = options.notPartOfAnySet,
        toElemKey = options.toElemKey,
        _options$mergeColors = options.mergeColors,
        mergeColors$1 = _options$mergeColors === void 0 ? mergeColors : _options$mergeColors;
    var combinations = [];
    var setIndex = new Map(sets.map(function (s, i) {
      return [s, i];
    }));
    var setElems = new Map(sets.map(function (s) {
      return [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)];
    }));
    var setDirectElems = toElemKey ? null : setElems;
    var setKeyElems = toElemKey ? setElems : null;
    var calc = type === 'union' ? mergeUnion : mergeIntersection;
    function push(s) {
      if (s.degree < min || s.degree > max || s.cardinality === 0 && !empty) {
        return;
      }
      if (type !== 'distinctIntersection') {
        combinations.push(s);
        return;
      }
      var others = sets.filter(function (d) {
        return !s.sets.has(d);
      });
      var elems = [];
      if (toElemKey) {
        var othersSets = others.map(function (o) {
          return setKeyElems.get(o);
        });
        elems = s.elems.filter(function (e) {
          var key = toElemKey(e);
          return othersSets.every(function (o) {
            return !o.has(key);
          });
        });
      } else {
        var _othersSets = others.map(function (o) {
          return setDirectElems.get(o);
        });
        elems = s.elems.filter(function (e) {
          return _othersSets.every(function (o) {
            return !o.has(e);
          });
        });
      }
      if (elems.length === s.cardinality) {
        combinations.push(s);
        return;
      }
      var sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);
      if (sDistinct.cardinality === 0 && !empty) {
        return;
      }
      combinations.push(sDistinct);
    }
    function generateLevel(arr, degree, lookup, toKey) {
      if (degree > max) {
        return;
      }
      var l = arr.length;
      for (var i = 0; i < l; i++) {
        var a = arr[i];
        var sub = [];
        for (var j = i + 1; j < l; j++) {
          var b = arr[j];
          var ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);
          push(ab);
          if (type === 'union' || ab.cardinality > 0 || empty) {
            sub.push(ab);
          }
        }
        if (sub.length > 1) {
          generateLevel(sub, degree + 1, lookup, toKey);
        }
      }
    }
    if (min <= 0) {
      if (toElemKey) {
        push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));
      } else {
        push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, function (v) {
          return v;
        }, mergeColors$1));
      }
    }
    var degree1 = sets.map(function (s) {
      var r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);
      setElems.set(r, setElems.get(s));
      push(r);
      return r;
    });
    if (toElemKey) {
      generateLevel(degree1, 2, setKeyElems, toElemKey);
    } else {
      generateLevel(degree1, 2, setDirectElems, function (v) {
        return v;
      });
    }
    return postprocessCombinations(sets, combinations, options);
  }
  function asSet(set) {
    return Object.assign({
      type: 'set',
      cardinality: set.elems.length
    }, set);
  }
  function toOrder(order) {
    if (!order) {
      return byName;
    }
    switch (order) {
      case 'cardinality':
      case 'cardinality:desc':
        return byComposite([byCardinality, byName]);
      case 'cardinality:asc':
        return byComposite([negate(byCardinality), byName]);
      case 'name:desc':
        return negate(byName);
      default:
        return byName;
    }
  }
  function postprocessSets(sets) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var r = sets;
    if (options.order) {
      var order = toOrder(options.order);
      r = r.slice().sort(order);
    }
    if (options.limit != null) {
      return r.slice(0, options.limit);
    }
    return r;
  }
  function asSets(sets) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return postprocessSets(sets.map(asSet), options);
  }
  function extractFromExpression(combinations, accOrOptions) {
    var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a, _b, _c;
    var acc = typeof accOrOptions === 'function' ? accOrOptions : function (e) {
      return e.sets;
    };
    var options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};
    var type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';
    var joiner = (_c = options.joiner) !== null && _c !== void 0 ? _c : SET_JOINERS[type];
    var sets = [];
    var setLookup = new Map();
    var cs = combinations.map(function (c) {
      var containedSets = acc(c);
      var containedSetsObjects = containedSets.map(function (s) {
        if (setLookup.has(s)) {
          return setLookup.get(s);
        }
        var set = {
          cardinality: 0,
          elems: [],
          name: s,
          type: 'set'
        };
        sets.push(set);
        setLookup.set(set.name, set);
        return set;
      });
      if (type === 'distinctIntersection') {
        var _iterator = _createForOfIteratorHelper(containedSetsObjects),
            _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var s = _step.value;
            s.cardinality += c.cardinality;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else if (containedSets.length === 1) {
        Object.assign(containedSetsObjects[0], {
          cardinality: c.cardinality
        }, c);
      } else if (type === 'intersection') {
        var _iterator2 = _createForOfIteratorHelper(containedSetsObjects),
            _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _s = _step2.value;
            _s.cardinality = Math.max(_s.cardinality, c.cardinality);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else if (type === 'union') {
        var _iterator3 = _createForOfIteratorHelper(containedSetsObjects),
            _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _s2 = _step3.value;
            _s2.cardinality = Math.min(_s2.cardinality, c.cardinality);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      var name = containedSets.join(joiner);
      return Object.assign({
        type: type,
        elems: [],
        name: name
      }, c, {
        cardinality: c.cardinality,
        degree: containedSets.length,
        sets: new Set(containedSetsObjects)
      });
    });
    var sortedSets = postprocessSets(sets, {
      order: options.setOrder
    });
    var sortedCombinations = postprocessCombinations(sortedSets, cs, {
      order: options.combinationOrder
    });
    return {
      sets: sortedSets,
      combinations: sortedCombinations
    };
  }
  function extractSets(elements, accOrOptions) {
    var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a;
    var acc = typeof accOrOptions === 'function' ? accOrOptions : function (e) {
      return e.sets;
    };
    var options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};
    var sets = Object.create(null);
    elements.forEach(function (elem) {
      acc(elem).forEach(function (set) {
        var s = typeof set === 'string' ? set : String(set);
        var r = sets[s];
        if (r == null) {
          sets[s] = [elem];
        } else {
          r.push(elem);
        }
      });
    });
    return postprocessSets(Object.entries(sets).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          set = _ref2[0],
          elems = _ref2[1];
      var r = {
        type: 'set',
        elems: elems,
        name: String(set),
        cardinality: elems.length
      };
      return r;
    }), options);
  }
  function createTree(byDegree, getOrCreateCombination) {
    var children = new Map();
    byDegree.slice().reverse().forEach(function (csOfDegree) {
      if (csOfDegree.length === 0 || csOfDegree[0].degree === 1) {
        return;
      }
      csOfDegree.forEach(function (c) {
        var sets = Array.from(c.sets).map(function (d) {
          return d.name;
        });
        for (var i = 0; i < sets.length; i++) {
          var subSet = sets.slice();
          subSet.splice(i, 1);
          var parent = getOrCreateCombination(subSet);
          if (children.has(parent)) {
            children.get(parent).push(c);
          } else {
            children.set(parent, [c]);
          }
        }
      });
    });
    return children;
  }
  function extractCombinations(elements, accOrOptions) {
    var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a, _b, _c, _d;
    var acc = typeof accOrOptions === 'function' ? accOrOptions : function (e) {
      return e.sets;
    };
    var options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};
    var type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';
    var sets = (_c = options.sets) !== null && _c !== void 0 ? _c : extractSets(elements, acc, {
      limit: options.setLimit,
      order: options.setOrder
    });
    if (type === 'union') {
      return {
        sets: sets,
        combinations: generateCombinations(sets, {
          type: 'union',
          limit: options.combinationLimit,
          order: options.combinationOrder
        })
      };
    }
    var setLookup = Object.create(null);
    sets.forEach(function (set, i) {
      setLookup[set.name] = [set, i];
    });
    var isSortedAlphabetically = sets.map(function (d) {
      return d.name;
    }).sort().every(function (d, i) {
      return sets[i].name === d;
    });
    var bySet = isSortedAlphabetically ? undefined : function (a, b) {
      var _a, _b, _c, _d;
      var ai = (_b = (_a = setLookup[a]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : -1;
      var bi = (_d = (_c = setLookup[b]) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : -1;
      return ai - bi;
    };
    var validSet = options.sets == null && options.setLimit == null ? null : new Set(sets.map(function (d) {
      return d.name;
    }));
    var joiner = (_d = options.joiner) !== null && _d !== void 0 ? _d : SET_JOINERS[type];
    var cs = [];
    var csLookup = Object.create(null);
    var byDegree = Array(sets.length + 1).fill(0).map(function (_) {
      return [];
    });
    function genName(setsOfElem) {
      switch (setsOfElem.length) {
        case 0:
          return '()';
        case 1:
          return setsOfElem[0];
        default:
          var sorted = setsOfElem.slice().sort(bySet);
          var joined = sorted.join(joiner);
          return '(' + joined + ')';
      }
    }
    function genKey(setsOfElem) {
      switch (setsOfElem.length) {
        case 0:
          return '';
        case 1:
          return setsOfElem[0];
        case 2:
          {
            if (bySet != null && bySet(setsOfElem[0], setsOfElem[1]) > 0 || bySet == null && setsOfElem[1] > setsOfElem[0]) {
              return setsOfElem[1] + '&' + setsOfElem[0];
            }
            return setsOfElem[0] + '&' + setsOfElem[1];
          }
        default:
          var sorted = setsOfElem.slice().sort(bySet);
          return sorted.join('&');
      }
    }
    function getOrCreateCombination(setsOfElem) {
      var key = genKey(setsOfElem);
      var entry = csLookup[key];
      if (entry) {
        return entry;
      }
      var newEntry = {
        type: type,
        name: genName(setsOfElem),
        degree: setsOfElem.length,
        sets: new Set(setsOfElem.map(function (s) {
          return setLookup[s][0];
        })),
        cardinality: 0,
        elems: []
      };
      csLookup[key] = newEntry;
      cs.push(newEntry);
      byDegree[newEntry.degree].push(newEntry);
      return newEntry;
    }
    elements.forEach(function (elem) {
      var setsOfElem = acc(elem);
      if (validSet) {
        setsOfElem = setsOfElem.filter(function (d) {
          return validSet.has(d);
        });
      }
      var c = getOrCreateCombination(setsOfElem);
      c.elems.push(elem);
      c.cardinality++;
    });
    var finalize = function finalize() {
      return {
        sets: sets,
        combinations: postprocessCombinations(sets, cs, {
          order: options.combinationOrder,
          limit: options.combinationLimit
        })
      };
    };
    if (type === 'distinctIntersection') {
      return finalize();
    }
    var children = createTree(byDegree, getOrCreateCombination);
    function visit(node, visited, agg) {
      var _a;
      if (visited.has(node)) {
        return;
      }
      visited.add(node);
      if (node.elems.length < 1000) {
        var _agg$;
        (_agg$ = agg[0]).push.apply(_agg$, _toConsumableArray(node.elems));
      } else {
        agg.push(node.elems);
      }
      ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach(function (child) {
        return visit(child, visited, agg);
      });
    }
    byDegree.slice(1).forEach(function (level) {
      level.forEach(function (node) {
        var _a;
        var visited = new Set();
        var agg = [node.elems];
        ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach(function (child) {
          visit(child, visited, agg);
        });
        var elems = agg.length === 1 ? agg[0] : agg.flat();
        Object.assign(node, {
          elems: elems,
          cardinality: elems.length
        });
      });
    });
    return finalize();
  }
  function toKey(s) {
    return "".concat(s.name, ":").concat(s.type, "#").concat(s.cardinality);
  }
  function isUniverse(s) {
    return s.sets.size === 0;
  }
  function common(a, b) {
    var toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;
    var r = {
      done: null,
      aKey: '',
      bKey: '',
      aIsSet: false,
      bIsSet: false,
      toKey: toKey$1
    };
    if (a === b) {
      r.done = a.cardinality;
      return r;
    }
    if (a.cardinality === 0 || b.cardinality === 0) {
      r.done = 0;
      return r;
    }
    r.aKey = toKey$1(a);
    r.bKey = toKey$1(b);
    if (r.aKey === r.bKey) {
      r.done = a.cardinality;
      return r;
    }
    r.aIsSet = isSet(a);
    r.bIsSet = isSet(b);
    if (!r.aIsSet && isUniverse(a) || !r.bIsSet && isUniverse(b)) {
      r.done = 0;
      return r;
    }
    return r;
  }
  function aInB(b, r) {
    if (r.bIsSet || !r.aIsSet) {
      return false;
    }
    return Array.from(b.sets).map(r.toKey).includes(r.aKey);
  }
  function bInA(a, r) {
    if (!r.bIsSet || r.aIsSet) {
      return false;
    }
    return Array.from(a.sets).map(r.toKey).includes(r.bKey);
  }
  function keyedCombinations(combinations) {
    var toKey$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : toKey;
    return combinations.map(function (c) {
      var s = Array.from(c.sets).map(toKey$1).sort();
      return {
        key: s.join('&'),
        s: s,
        sets: new Set(s),
        degree: c.degree,
        cardinality: c.cardinality
      };
    });
  }
  function combinedKey(a, b, r) {
    var sets = new Set();
    if (r.aIsSet) {
      sets.add(r.aKey);
    } else {
      for (var _i = 0, _Array$from = Array.from(a.sets); _i < _Array$from.length; _i++) {
        var s = _Array$from[_i];
        sets.add(r.toKey(s));
      }
    }
    if (r.bIsSet) {
      sets.add(r.bKey);
    } else {
      for (var _i2 = 0, _Array$from2 = Array.from(b.sets); _i2 < _Array$from2.length; _i2++) {
        var _s3 = _Array$from2[_i2];
        sets.add(r.toKey(_s3));
      }
    }
    return Array.from(sets).sort().join('&');
  }
  function generateDistinctOverlapFunction(combinations, fallback) {
    var toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;
    var combinationsBySet = new Map();
    var _iterator4 = _createForOfIteratorHelper(keyedCombinations(combinations, toKey$1)),
        _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var c = _step4.value;
        var _iterator5 = _createForOfIteratorHelper(c.s),
            _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var s = _step5.value;
            if (combinationsBySet.has(s)) {
              combinationsBySet.get(s).push(c);
            } else {
              combinationsBySet.set(s, [c]);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return function (a, b) {
      var r = common(a, b, toKey$1);
      if (r.done != null) {
        return r.done;
      }
      if (!r.aIsSet && !r.bIsSet) {
        return 0;
      }
      if (r.aIsSet && !r.bIsSet) {
        return aInB(b, r) ? b.cardinality : 0;
      }
      if (!r.aIsSet && r.bIsSet) {
        return bInA(a, r) ? a.cardinality : 0;
      }
      var hasA = combinationsBySet.get(r.aKey);
      var hasB = combinationsBySet.get(r.bKey);
      if (!hasA || !hasB) {
        return fallback(a, b);
      }
      if (hasA.length < hasB.length) {
        return hasA.reduce(function (acc, c) {
          return acc + (c.sets.has(r.bKey) ? c.cardinality : 0);
        }, 0);
      }
      return hasB.reduce(function (acc, c) {
        return acc + (c.sets.has(r.aKey) ? c.cardinality : 0);
      }, 0);
    };
  }
  function generateIntersectionOverlapFunction(combinations, fallback) {
    var toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;
    var combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(function (d) {
      return [d.key, d.cardinality];
    }));
    return function (a, b) {
      var r = common(a, b, toKey$1);
      if (r.done != null) {
        return r.done;
      }
      if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
        return b.cardinality;
      }
      if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
        return a.cardinality;
      }
      var key = combinedKey(a, b, r);
      if (!combinationsByKey.has(key)) {
        return fallback(a, b);
      }
      return combinationsByKey.get(key);
    };
  }
  function generateUnionOverlapFunction(combinations, fallback) {
    var toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;
    var combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(function (d) {
      return [d.key, d.cardinality];
    }));
    return function (a, b) {
      var r = common(a, b, toKey$1);
      if (r.done != null) {
        return r.done;
      }
      if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
        return a.cardinality;
      }
      if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
        return b.cardinality;
      }
      var key = combinedKey(a, b, r);
      if (!combinationsByKey.has(key)) {
        return fallback(a, b);
      }
      return a.cardinality + b.cardinality - combinationsByKey.get(key);
    };
  }
  function generateOverlapFunction(combinations, fallback) {
    var toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;
    if (combinations.length === 0) {
      return fallback;
    }
    var firstType = combinations[0].type;
    if (combinations.some(function (s) {
      return s.type !== firstType;
    })) {
      return fallback;
    }
    switch (firstType) {
      case 'union':
        return generateUnionOverlapFunction(combinations, fallback, toKey$1);
      case 'intersection':
        return generateIntersectionOverlapFunction(combinations, fallback, toKey$1);
      case 'distinctIntersection':
        return generateDistinctOverlapFunction(combinations, fallback, toKey$1);
    }
    return fallback;
  }
  function compressLine(line) {
    if (line.length === 0) {
      return '';
    }
    var r = [];
    var start = line[0];
    var len = 1;
    for (var i = 1; i < line.length; i++) {
      var v = line[i];
      if (v === start) {
        len++;
      } else {
        if (len > 1) {
          r.push("".concat(start, "=").concat(len - 1));
        } else if (start === 0) {
          r.push('');
        } else {
          r.push(start.toString());
        }
        start = v;
        len = 1;
      }
    }
    if (len > 1) {
      r.push("".concat(start, "=").concat(len));
    } else if (start === 0) {
      r.push('');
    } else {
      r.push(start.toString());
    }
    return r.join(',');
  }
  function decompressLine(line) {
    if (line.length === 0) {
      return [];
    }
    return line.split(',').map(function (v) {
      if (v === '') {
        return 0;
      }
      if (v.includes('=')) {
        var _v$split$map = v.split('=').map(function (v) {
          return Number.parseInt(v, 10);
        }),
            _v$split$map2 = _slicedToArray(_v$split$map, 2),
            value = _v$split$map2[0],
            length = _v$split$map2[1];
        return Array(length + 1).fill(value);
      }
      return Number.parseInt(v, 10);
    }).flat();
  }
  function compressMatrix(matrix) {
    if (matrix.length === 0) {
      return '';
    }
    var rows = matrix.length;
    var flat = matrix.flat();
    return "".concat(rows, ";").concat(compressLine(flat));
  }
  function decompressMatrix(matrix) {
    if (matrix.length === 0) {
      return [];
    }
    var _matrix$split = matrix.split(';'),
        _matrix$split2 = _slicedToArray(_matrix$split, 2),
        rowsInfo = _matrix$split2[0],
        data = _matrix$split2[1];
    var rows = Number.parseInt(rowsInfo, 10);
    var values = decompressLine(data);
    var r = [];
    var acc = 0;
    for (var i = rows; i > 0; i--) {
      r.push(values.slice(acc, acc + i));
      acc += i;
    }
    return r;
  }
  function generateOverlapLookup(sets, combinations) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        toElemKey = _ref3.toElemKey,
        _ref3$what = _ref3.what,
        what = _ref3$what === void 0 ? 'intersection' : _ref3$what,
        _ref3$compress = _ref3.compress,
        compress = _ref3$compress === void 0 ? 'auto' : _ref3$compress;
    var data = sets.concat(combinations);
    function overlapF(set) {
      if (set.overlap) {
        return set.overlap;
      }
      var f = setOverlapFactory(set.elems, toElemKey);
      return function (v) {
        if (v.overlap) {
          return v.overlap(set);
        }
        return f(v.elems)[what];
      };
    }
    var matrix = data.map(function (set, i) {
      var overlap = overlapF(set);
      var r = [];
      for (var j = i + 1; j < data.length; j++) {
        r.push(overlap(data[j]));
      }
      return r;
    });
    matrix.pop();
    if (compress === 'no') {
      return matrix;
    }
    var compressed = compressMatrix(matrix);
    if (compress === 'yes') {
      return compressed;
    }
    var encodedLength = JSON.stringify(matrix).length;
    var compressedLength = compressed.length + 2;
    return compressedLength < encodedLength * 0.6 ? compressed : matrix;
  }
  function generateOverlapLookupFunction(matrix, sets, combinations) {
    var toKey$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : toKey;
    var lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;
    var setIndex = new Map(sets.map(function (set, i) {
      return [toKey$1(set), i];
    }));
    var combinationIndex = new Map(combinations.map(function (set, i) {
      return [toKey$1(set), i + sets.length];
    }));
    var compute = function compute(a, b) {
      if (a === b) {
        return a.cardinality;
      }
      var aKey = toKey$1(a);
      var bKey = toKey$1(b);
      var aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);
      var bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);
      if (aIndex === bIndex) {
        return a.cardinality;
      }
      var row = Math.min(aIndex, bIndex);
      var col = Math.max(aIndex, bIndex) - row - 1;
      if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {
        return 0;
      }
      return lookup[row][col];
    };
    return {
      setIndex: setIndex,
      compute: compute,
      combinationIndex: combinationIndex
    };
  }
  var bandScale$1 = function bandScale(domain, size, padding) {
    var blocks = domain.length + padding;
    var step = size / Math.max(1, blocks);
    var start = size - step * domain.length;
    var lookup = new Map(domain.map(function (d, i) {
      return [d, i];
    }));
    var bandwidth = step / (1 + padding);
    var scale = function scale(v) {
      var index = lookup.get(v);
      if (index == null) {
        return undefined;
      }
      return start + step * index;
    };
    scale.bandwidth = function () {
      return bandwidth;
    };
    return scale;
  };
  function hasOverlap(positions, heights) {
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    for (var i = 0; i < positions.length - stride; i += stride) {
      var pos_i = positions[i];
      var pos_n = positions[i + 1];
      if (pos_i < pos_n) {
        var right = pos_i + heights[i] / 2;
        var left = pos_n - heights[i + 1] / 2;
        if (right > left) {
          return true;
        }
      } else {
        var _left = pos_i - heights[i] / 2;
        var _right = pos_n + heights[i + 1] / 2;
        if (_right > _left) {
          return true;
        }
      }
    }
    return false;
  }
  function ensureLast(ticks, max, scale, heightPerTick, toStr) {
    var last = ticks[ticks.length - 1];
    if (!last.label) {
      for (var j = ticks.length - 2; j > 0; --j) {
        if (ticks[j].label) {
          last = ticks[j];
          break;
        }
      }
    }
    if (last.value < max) {
      var pos_l = scale(last.value);
      var pos_max = scale(max);
      if (pos_l < pos_max) {
        var right = pos_l + heightPerTick(last.value) / 2;
        var left = pos_max - heightPerTick(max) / 2;
        if (right < left) {
          ticks.push({
            value: max,
            label: toStr(max)
          });
        }
      } else {
        var _left2 = pos_l - heightPerTick(last.value) / 2;
        var _right2 = pos_max + heightPerTick(max) / 2;
        if (_right2 < _left2) {
          ticks.push({
            value: max,
            label: toStr(max)
          });
        }
      }
    }
    return ticks;
  }
  function genTicks(values) {
    var toStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String;
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return values.map(function (v, i) {
      return {
        value: v,
        label: stride === 1 || i % stride === 0 ? toStr(v) : undefined
      };
    });
  }
  function checkValues(values, scale, heightPerTick, max, toStr) {
    var positions = values.map(function (v) {
      return scale(v);
    });
    var heights = values.map(function (v) {
      return heightPerTick(v);
    });
    if (!hasOverlap(positions, heights)) {
      return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
    }
    if (!hasOverlap(positions, heights, 2)) {
      return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
    }
    return null;
  }
  function toStr$1(v) {
    return v.toLocaleString();
  }
  function niceFactors(max) {
    var maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 11;
    var digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));
    var factor = Math.pow(10, digits);
    var factors = [1, 2, 5];
    var r = factors.map(function (f) {
      return f * factor;
    });
    if (digits > 0) {
      r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));
    }
    r.push(factors[0] * Math.pow(10, digits + 1));
    var lower = Math.ceil(max / maxCount);
    return r.filter(function (d) {
      return d >= lower && d <= max;
    });
  }
  function range$1(max) {
    var inc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var values = [];
    for (var v = 0; v <= max; v += inc) {
      values.push(v);
    }
    return values;
  }
  function distributeTicks$1(max, maxCount, scale, heightPerTick) {
    if (maxCount <= 0) {
      return [];
    }
    var factors = niceFactors(max, maxCount);
    for (var i = 0; i < factors.length; i++) {
      var values = range$1(max, factors[i]);
      var r = checkValues(values, scale, heightPerTick, max, toStr$1);
      if (r) {
        return r;
      }
    }
    return genTicks([0, max], toStr$1);
  }
  var linearScale = function linearScale(max, range, options) {
    var size = range[1] - range[0];
    var domain = max;
    var scale = function scale(v) {
      var cv = Math.max(0, Math.min(v, domain));
      var n = cv / domain;
      return range[0] + n * size;
    };
    scale.ticks = function () {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      if (options.orientation === 'vertical') {
        var heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
        return distributeTicks$1(max, count + 1, scale, function () {
          return heightPerTick;
        });
      }
      var widthPerChar = options.fontSizeHint / 1.4;
      return distributeTicks$1(max, count + 1, scale, function (v) {
        return Math.ceil(toStr$1(v).length * widthPerChar);
      });
    };
    scale.tickFormat = function () {
      return toStr$1;
    };
    return scale;
  };
  function toStr(v) {
    var orders = ['', 'k', 'M', 'G'];
    var order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));
    var vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;
    return "".concat(vi.toLocaleString()).concat(orders[order]);
  }
  function range(max, factor) {
    var values = [];
    var inc = Math.pow(10, factor);
    for (var v = 1; v <= max; v *= inc) {
      values.push(v);
    }
    return values;
  }
  function generateInnerTicks(max, factor) {
    var values = [];
    var inc = 10;
    for (var v = 1, i = 0; v <= max; v *= inc, i++) {
      values.push({
        value: v,
        label: factor === 1 || i % factor === 0 ? toStr(v) : undefined
      });
      for (var vv = v + v; vv < v * inc && vv < max; vv += v * factor) {
        values.push({
          value: vv
        });
      }
    }
    return values;
  }
  function distributeTicks(max, maxCount, scale, heightPerTick) {
    if (maxCount <= 0) {
      return [];
    }
    for (var _i3 = 0, _arr = [1, 2, 5]; _i3 < _arr.length; _i3++) {
      var factor = _arr[_i3];
      var values = range(max, factor);
      var r = checkValues(values, scale, heightPerTick, max, toStr);
      if (r) {
        return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr);
      }
    }
    return genTicks([0, max], toStr);
  }
  var logScale = function logScale(max, range, options) {
    var size = range[1] - range[0];
    var domain = max < 1 ? 1 : Math.log10(max);
    var scale = function scale(v) {
      var cv = Math.max(0, Math.min(v, domain));
      var n = cv <= 1 ? 0 : Math.log10(cv) / domain;
      return range[0] + n * size;
    };
    scale.ticks = function () {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      if (options.orientation === 'vertical') {
        var heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
        return distributeTicks(max, count + 1, scale, function () {
          return heightPerTick;
        });
      }
      var widthPerChar = options.fontSizeHint / 1.4;
      return distributeTicks(max, count + 1, scale, function (v) {
        return Math.ceil(toStr(v).length * widthPerChar);
      });
    };
    scale.tickFormat = function () {
      return toStr;
    };
    return scale;
  };
  function compressIndicesArray(arr) {
    if (arr.length === 0) {
      return '';
    }
    var encoded = [];
    var startIndex = 0;
    var push = function push(i) {
      if (i === startIndex + 1) {
        encoded.push(arr[startIndex].toString());
      } else if (i === startIndex + 2 && i < 10) {
        encoded.push("".concat(arr[startIndex], ",").concat(arr[startIndex + 1]));
      } else {
        encoded.push("".concat(arr[startIndex], "+").concat(i - startIndex - 1));
      }
      return i;
    };
    for (var i = 1; i < arr.length; i++) {
      var expected = arr[i - 1] + 1;
      var v = arr[i];
      if (v !== expected) {
        startIndex = push(i);
        startIndex = i;
      }
    }
    push(arr.length);
    return encoded.join(',');
  }
  function toIndicesArray(arr, toIndex) {
    var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        sortAble = _ref4.sortAble,
        _ref4$compress = _ref4.compress,
        compress = _ref4$compress === void 0 ? 'auto' : _ref4$compress;
    if (arr.length === 0) {
      return [];
    }
    var base = arr.map(function (v) {
      return toIndex(v);
    });
    if (compress === 'no') {
      return base;
    }
    if (sortAble) {
      base.sort(function (a, b) {
        return a - b;
      });
    }
    var encoded = compressIndicesArray(base);
    var baseLength = JSON.stringify(base).length;
    var encodedLength = encoded.length + 2;
    if (encodedLength < baseLength * 0.6 || baseLength - encodedLength > 50 || compress === 'yes' && encodedLength < baseLength) {
      return encoded;
    }
    return base;
  }
  function fromIndicesArray(indices, elements) {
    if (typeof indices === 'string') {
      if (indices.length === 0) {
        return [];
      }
      return indices.split(',').map(function (s) {
        if (s.includes('+')) {
          var _s$split$map = s.split('+').map(function (si) {
            return Number.parseInt(si, 10);
          }),
              _s$split$map2 = _slicedToArray(_s$split$map, 2),
              start = _s$split$map2[0],
              length = _s$split$map2[1];
          return elements.slice(start, start + length + 1);
        }
        return elements[Number.parseInt(s, 10)];
      }).flat();
    }
    return indices.map(function (i) {
      return elements[i];
    });
  }
  function withColor(v, s) {
    if (s.color) {
      v.color = s.color;
    }
    return v;
  }
  function fromDump(dump, elems) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var sets = dump.sets.map(function (set) {
      return asSet(Object.assign(Object.assign({}, set), {
        elems: fromIndicesArray(set.elems, elems)
      }));
    });
    var gen = function gen() {
      var _a;
      return generateCombinations(sets, Object.assign({
        type: 'intersection',
        elems: elems,
        toElemKey: options.toElemKey
      }, (_a = dump.combinationOptions) !== null && _a !== void 0 ? _a : {}));
    };
    var combinations = dump.combinations ? dump.combinations.map(function (c) {
      return asCombination(Object.assign(Object.assign({}, c), {
        elems: fromIndicesArray(c.elems, elems)
      }), c.type, function (v) {
        return v.sets.map(function (i) {
          return sets[i];
        });
      });
    }) : gen();
    function fromSetRef(ref) {
      if (ref.type === 'set') {
        return sets[ref.index];
      }
      return combinations[ref.index];
    }
    return {
      sets: sets,
      combinations: combinations,
      selection: dump.selection ? typeof dump.selection === 'string' || Array.isArray(dump.selection) ? fromIndicesArray(dump.selection, elems) : fromSetRef(dump.selection) : undefined,
      queries: dump.queries.map(function (query) {
        if (query.set) {
          return {
            name: query.name,
            color: query.color,
            set: fromSetRef(query.set)
          };
        }
        return {
          name: query.name,
          color: query.color,
          elems: fromIndicesArray(query.elems, elems)
        };
      })
    };
  }
  function toDump(data) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a;
    var indicesOptions = Object.assign({
      sortAble: true
    }, config);
    var toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    var bySetKey = new Map(data.sets.map(function (s, i) {
      return [toKey$1(s), i];
    }));
    var byCombinationKey = new Map(data.combinations.map(function (s, i) {
      return [toKey$1(s), i];
    }));
    var toSetRef = function toSetRef(s) {
      if (s.type === 'set') {
        return {
          type: s.type,
          index: bySetKey.get(toKey$1(s))
        };
      }
      var index = byCombinationKey.get(toKey$1(s));
      if (index == null || index < 0) {
        return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);
      }
      return {
        type: s.type,
        index: index
      };
    };
    var setLookup = data.sets.map(function (s, i) {
      return {
        key: toKey$1(s),
        i: i
      };
    });
    return {
      sets: data.sets.map(function (set) {
        return withColor({
          name: set.name,
          cardinality: set.cardinality,
          elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions)
        }, set);
      }),
      combinations: config.compress === 'no' ? data.combinations.map(function (c) {
        var setKeys = new Set(Array.from(c.sets).map(toKey$1));
        return withColor({
          name: c.name,
          type: c.type,
          cardinality: c.cardinality,
          degree: c.degree,
          sets: setLookup.filter(function (_ref5) {
            var key = _ref5.key;
            return setKeys.has(key);
          }).map(function (_ref6) {
            var i = _ref6.i;
            return i;
          }),
          elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions)
        }, c);
      }) : undefined,
      combinationOptions: data.combinationOptions,
      selection: data.selection ? Array.isArray(data.selection) ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions) : toSetRef(data.selection) : undefined,
      queries: data.queries.map(function (query) {
        var elems = isSetQuery(query) ? toSetRef(query.set) : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);
        return {
          name: query.name,
          color: query.color,
          set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,
          elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined
        };
      })
    };
  }
  function generateName(sets, type) {
    if (sets.length === 1) {
      return sets[0].name;
    }
    return "(".concat(sets.map(function (set) {
      return set.name;
    }).join(SET_JOINERS[type]), ")");
  }
  function toStaticDump(data) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a;
    var toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    var bySetKey = new Map(data.sets.map(function (s, i) {
      return [toKey$1(s), i];
    }));
    var byCombinationKey = new Map(data.combinations.map(function (s, i) {
      return [toKey$1(s), i];
    }));
    var toSelectionSetRef = function toSelectionSetRef(s) {
      if (isSetLike$1(s)) {
        if (s.type === 'set') {
          return {
            type: s.type,
            index: bySetKey.get(toKey$1(s))
          };
        }
        var index = byCombinationKey.get(toKey$1(s));
        if (index != null && index >= 0) {
          return {
            type: s.type,
            index: index
          };
        }
      }
      var overlapF = setOverlapFactory(isSetLike$1(s) ? s.elems : s);
      return data.sets.map(function (set) {
        return overlapF(set.elems).intersection;
      }).concat(data.combinations.map(function (set) {
        return overlapF(set.elems).intersection;
      }));
    };
    var setIndex = new Map(data.sets.map(function (set, i) {
      return [toKey$1(set), i];
    }));
    var overlaps = generateOverlapLookup(data.sets, data.combinations, config);
    var shortNames = config.compress === 'yes';
    var compressCombination = function compressCombination(set) {
      var partOf = Array.from(set.sets).map(function (s) {
        return setIndex.get(toKey$1(s));
      }).sort(function (a, b) {
        return a - b;
      });
      var r = {
        c: set.cardinality,
        s: partOf.reduce(function (acc, i) {
          return acc + Math.pow(2, i);
        }, 0)
      };
      if (set.name !== generateName(partOf.map(function (i) {
        return data.sets[i];
      }), set.type)) {
        r.n = set.name;
      }
      if (set.type !== 'intersection') {
        r.type = set.type[0];
      }
      if (set.color) {
        r.cc = set.color;
      }
      return r;
    };
    return {
      sets: shortNames ? data.sets.map(function (set) {
        return {
          n: set.name,
          cc: set.color,
          c: set.cardinality
        };
      }) : data.sets.map(function (set) {
        return withColor({
          name: set.name,
          cardinality: set.cardinality
        }, set);
      }),
      combinations: shortNames ? data.combinations.map(compressCombination) : data.combinations.map(function (set) {
        return withColor({
          name: set.name,
          cardinality: set.cardinality,
          type: set.type,
          sets: Array.from(set.sets).map(function (s) {
            return setIndex.get(toKey$1(s));
          }).sort(function (a, b) {
            return a - b;
          })
        }, set);
      }),
      overlaps: overlaps,
      selection: data.selection ? toSelectionSetRef(data.selection) : undefined,
      queries: data.queries.map(function (query) {
        if (isSetQuery(query)) {
          var ref = toSelectionSetRef(query.set);
          if (Array.isArray(ref)) {
            return {
              name: query.name,
              color: query.color,
              overlaps: ref
            };
          }
          return {
            name: query.name,
            color: query.color,
            set: ref
          };
        }
        var overlapF = setOverlapFactory(query.elems);
        var overlaps = data.sets.map(function (set) {
          return overlapF(set.elems).intersection;
        }).concat(data.combinations.map(function (set) {
          return overlapF(set.elems).intersection;
        }));
        return {
          name: query.name,
          color: query.color,
          overlaps: overlaps
        };
      })
    };
  }
  function isCompressed(s) {
    return typeof s.c === 'number';
  }
  function isCompressedSet(s) {
    return typeof s.c === 'number';
  }
  function fromStaticDump(dump) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a;
    var toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    var computeF = function computeF() {
      return 0;
    };
    function withOverlap(s) {
      s.overlap = function (b) {
        return computeF(s, b);
      };
      return s;
    }
    var sets = dump.sets.map(function (set) {
      return withOverlap({
        name: isCompressedSet(set) ? set.n : set.name,
        cardinality: isCompressedSet(set) ? set.c : set.cardinality,
        type: 'set',
        elems: []
      });
    });
    var fromBit = function fromBit(v) {
      return sets.filter(function (_, i) {
        var position = Math.pow(2, i);
        return (v & position) === position;
      });
    };
    var combinations = dump.combinations.map(function (set) {
      var _a, _b;
      var partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map(function (i) {
        return sets[i];
      });
      var lookup = {
        i: 'intersection',
        u: 'union',
        c: 'composite',
        d: 'distinctIntersection'
      };
      var type = lookup[((_a = set.type) !== null && _a !== void 0 ? _a : 'i')[0]];
      return withOverlap({
        name: isCompressed(set) ? (_b = set.n) !== null && _b !== void 0 ? _b : generateName(partOf, type) : set.name,
        cardinality: isCompressed(set) ? set.c : set.cardinality,
        type: type,
        degree: partOf.length,
        sets: new Set(partOf),
        elems: []
      });
    });
    var _generateOverlapLooku = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1),
        setIndex = _generateOverlapLooku.setIndex,
        combinationIndex = _generateOverlapLooku.combinationIndex,
        compute = _generateOverlapLooku.compute;
    computeF = compute;
    function fromSetRef(ref) {
      if (ref.type === 'set') {
        return sets[ref.index];
      }
      return combinations[ref.index];
    }
    function generateOverlap(lookup) {
      return function (v) {
        var key = toKey$1(v);
        var index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);
        return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];
      };
    }
    return {
      sets: sets,
      combinations: combinations,
      selection: dump.selection ? Array.isArray(dump.selection) ? generateOverlap(dump.selection) : fromSetRef(dump.selection) : undefined,
      queries: dump.queries.map(function (query) {
        if (query.set) {
          return {
            name: query.name,
            color: query.color,
            set: fromSetRef(query.set)
          };
        }
        return {
          name: query.name,
          color: query.color,
          overlap: generateOverlap(query.overlaps)
        };
      })
    };
  }

  var lzString = {exports: {}};

  (function (module) {
    var LZString = function () {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString = {
        compressToBase64: function compressToBase64(input) {
          if (input == null) return "";
          var res = LZString._compress(input, 6, function (a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            default:
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function decompressFromBase64(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString._decompress(input.length, 32, function (index) {
            return getBaseValue(keyStrBase64, input.charAt(index));
          });
        },
        compressToUTF16: function compressToUTF16(input) {
          if (input == null) return "";
          return LZString._compress(input, 15, function (a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function decompressFromUTF16(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString._decompress(compressed.length, 16384, function (index) {
            return compressed.charCodeAt(index) - 32;
          });
        },
        compressToUint8Array: function compressToUint8Array(uncompressed) {
          var compressed = LZString.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        decompressFromUint8Array: function decompressFromUint8Array(compressed) {
          if (compressed === null || compressed === undefined) {
            return LZString.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function (c) {
              result.push(f(c));
            });
            return LZString.decompress(result.join(''));
          }
        },
        compressToEncodedURIComponent: function compressToEncodedURIComponent(input) {
          if (input == null) return "";
          return LZString._compress(input, 6, function (a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString._decompress(input.length, 32, function (index) {
            return getBaseValue(keyStrUriSafe, input.charAt(index));
          });
        },
        compress: function compress(uncompressed) {
          return LZString._compress(uncompressed, 16, function (a) {
            return f(a);
          });
        },
        _compress: function _compress(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i,
              value,
              context_dictionary = {},
              context_dictionaryToCreate = {},
              context_c = "",
              context_wc = "",
              context_w = "",
              context_enlargeIn = 2,
          context_dictSize = 3,
              context_numBits = 2,
              context_data = [],
              context_data_val = 0,
              context_data_position = 0,
              ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join('');
        },
        decompress: function decompress(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString._decompress(compressed.length, 32768, function (index) {
            return compressed.charCodeAt(index);
          });
        },
        _decompress: function _decompress(length, resetValue, getNextValue) {
          var dictionary = [],
              enlargeIn = 4,
              dictSize = 4,
              numBits = 3,
              entry = "",
              result = [],
              i,
              w,
              bits,
              resb,
              maxpower,
              power,
              c,
              data = {
            val: getNextValue(0),
            position: resetValue,
            index: 1
          };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join('');
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry = dictionary[c];
            } else {
              if (c === dictSize) {
                entry = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w + entry.charAt(0);
            enlargeIn--;
            w = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString;
    }();
    if (module != null) {
      module.exports = LZString;
    }
  })(lzString);
  var LZString = lzString.exports;

  function extractStyleId(node) {
    return Array.from(node.classList).find(function (d) {
      return d.startsWith('root-');
    }).slice('root-'.length);
  }
  function extractTitle(node, styleId) {
    var _a, _b;
    return (_b = (_a = node.querySelector("titleTextStyle-".concat(styleId))) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : 'UpSetJS';
  }
  function extractDescription(node, styleId) {
    var _a, _b;
    return (_b = (_a = node.querySelector("descTextStyle-".concat(styleId))) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : '';
  }
  var EMPTY_OBJECT = {};
  var EMPTY_ARRAY$2 = [];
  var DEFAULT_FONT_SIZES = {
    setLabel: '16px',
    axisTick: '10px',
    chartLabel: '16px',
    barLabel: '10px',
    legend: '10px',
    description: '16px',
    title: '24px',
    valueLabel: '12px',
    exportLabel: '10px'
  };
  var DEFAULT_WIDTH_RATIO = [0.18, 0.12, 0.7];
  var DEFAULT_HEIGHT_RATIO = [0.6, 0.4];
  var DEFAULT_COMBINATIONS = {
    type: 'intersection',
    order: ['cardinality:desc', 'name:asc']
  };
  var FONT_SIZES_KEYS = Object.keys(DEFAULT_FONT_SIZES);
  var MULTI_STYLE_KEYS = ['axisTick', 'bar', 'barLabel', 'chartLabel', 'dot', 'legend', 'title', 'description', 'setLabel', 'set', 'valueLabel'];
  var EXPORT_OPTION_KEYS = ['dump', 'png', 'share', 'svg', 'vega'];
  var OVERFLOW_OPACITY_FACTOR = [0.7, 0.4];
  var OVERFLOW_PADDING_FACTOR = [0.15, 0.3];
  var sets$6 = [];
  var intersections$5 = [];
  var bb$5 = {
    x: 0,
    y: 0,
    width: 10,
    height: 10
  };
  var venn0 = {
    sets: sets$6,
    intersections: intersections$5,
    bb: bb$5
  };
  var sets$5 = [{
    cx: 0,
    cy: 0,
    r: 5,
    text: {
      x: 3.5,
      y: -4
    },
    align: "start",
    verticalAlign: "bottom"
  }];
  var intersections$4 = [{
    sets: [0],
    x1: 0,
    y1: 5,
    arcs: [{
      mode: "i",
      ref: 0,
      x2: 0,
      y2: -5,
      sweep: false,
      large: false
    }, {
      mode: "i",
      ref: 0,
      x2: 0,
      y2: 5,
      sweep: false,
      large: false
    }],
    text: {
      x: 0,
      y: 0
    }
  }];
  var bb$4 = {
    x: -5,
    y: -5,
    width: 10,
    height: 10
  };
  var venn1 = {
    sets: sets$5,
    intersections: intersections$4,
    bb: bb$4
  };
  var sets$4 = [{
    cx: -4,
    cy: 0,
    r: 5,
    text: {
      x: -7.5,
      y: 4
    },
    align: "end",
    verticalAlign: "top"
  }, {
    cx: 4,
    cy: 0,
    r: 5,
    text: {
      x: 7.5,
      y: -4
    },
    align: "start",
    verticalAlign: "bottom"
  }];
  var intersections$3 = [{
    sets: [0],
    x1: 0,
    y1: -3,
    arcs: [{
      mode: "i",
      ref: 0,
      x2: 0,
      y2: 3,
      sweep: false,
      large: true
    }, {
      mode: "o",
      ref: 1,
      x2: 0,
      y2: -3,
      sweep: true,
      large: false
    }],
    text: {
      x: -4,
      y: 0
    }
  }, {
    sets: [1],
    x1: 0,
    y1: 3,
    arcs: [{
      mode: "i",
      ref: 1,
      x2: 0,
      y2: -3,
      sweep: false,
      large: true
    }, {
      mode: "o",
      ref: 0,
      x2: 0,
      y2: 3,
      sweep: true,
      large: false
    }],
    text: {
      x: 4,
      y: 0
    }
  }, {
    sets: [0, 1],
    x1: 0,
    y1: 3,
    arcs: [{
      mode: "i",
      ref: 0,
      x2: 0,
      y2: -3,
      sweep: false,
      large: false
    }, {
      mode: "i",
      ref: 1,
      x2: 0,
      y2: 3,
      sweep: false,
      large: false
    }],
    text: {
      x: 0,
      y: 0
    }
  }];
  var bb$3 = {
    x: -9,
    y: -5,
    width: 18,
    height: 10
  };
  var venn2 = {
    sets: sets$4,
    intersections: intersections$3,
    bb: bb$3
  };
  var sets$3 = [{
    cx: -3.464,
    cy: -2,
    r: 5,
    text: {
      x: -7,
      y: -6
    },
    align: "end",
    verticalAlign: "bottom"
  }, {
    cx: 3.464,
    cy: -2,
    r: 5,
    text: {
      x: 7,
      y: -6
    },
    align: "start",
    verticalAlign: "bottom"
  }, {
    cx: 0,
    cy: 4,
    r: 5,
    text: {
      x: 4,
      y: 7.5
    },
    align: "start",
    verticalAlign: "top"
  }];
  var intersections$2 = [{
    sets: [0],
    x1: -4.855,
    y1: 2.803,
    arcs: [{
      mode: "o",
      ref: 2,
      x2: -1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }, {
      mode: "o",
      ref: 1,
      x2: 0,
      y2: -5.606,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 0,
      x2: -4.855,
      y2: 2.803,
      sweep: false,
      large: true
    }],
    text: {
      x: -4.216,
      y: -2.434
    }
  }, {
    sets: [1],
    x1: 0,
    y1: -5.606,
    arcs: [{
      mode: "o",
      ref: 0,
      x2: 1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }, {
      mode: "o",
      ref: 2,
      x2: 4.855,
      y2: 2.803,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 1,
      x2: 0,
      y2: -5.606,
      sweep: false,
      large: true
    }],
    text: {
      x: 4.216,
      y: -2.434
    }
  }, {
    sets: [2],
    x1: -4.855,
    y1: 2.803,
    arcs: [{
      mode: "o",
      ref: 0,
      x2: 0,
      y2: 1.606,
      sweep: false,
      large: false
    }, {
      mode: "o",
      ref: 1,
      x2: 4.855,
      y2: 2.803,
      sweep: false,
      large: false
    }, {
      mode: "i",
      ref: 2,
      x2: -4.855,
      y2: 2.803,
      sweep: true,
      large: true
    }],
    text: {
      x: 0,
      y: 4.869
    }
  }, {
    sets: [0, 1],
    x1: 0,
    y1: -5.606,
    arcs: [{
      mode: "i",
      ref: 1,
      x2: -1.39,
      y2: -0.803,
      sweep: false,
      large: false
    }, {
      mode: "o",
      ref: 2,
      x2: 1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 0,
      x2: 0,
      y2: -5.606,
      sweep: false,
      large: false
    }],
    text: {
      x: 0,
      y: -2.404
    }
  }, {
    sets: [0, 2],
    x1: -4.855,
    y1: 2.803,
    arcs: [{
      mode: "i",
      ref: 2,
      x2: -1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }, {
      mode: "o",
      ref: 1,
      x2: 0,
      y2: 1.606,
      sweep: false,
      large: false
    }, {
      mode: "i",
      ref: 0,
      x2: -4.855,
      y2: 2.803,
      sweep: true,
      large: false
    }],
    text: {
      x: -2.082,
      y: 1.202
    }
  }, {
    sets: [1, 2],
    x1: 4.855,
    y1: 2.803,
    arcs: [{
      mode: "i",
      ref: 2,
      x2: 1.39,
      y2: -0.803,
      sweep: false,
      large: false
    }, {
      mode: "o",
      ref: 0,
      x2: 0,
      y2: 1.606,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 1,
      x2: 4.855,
      y2: 2.803,
      sweep: false,
      large: false
    }],
    text: {
      x: 2.082,
      y: 1.202
    }
  }, {
    sets: [0, 1, 2],
    x1: 1.39,
    y1: -0.803,
    arcs: [{
      mode: "i",
      ref: 0,
      x2: 0,
      y2: 1.606,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 1,
      x2: -1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }, {
      mode: "i",
      ref: 2,
      x2: 1.39,
      y2: -0.803,
      sweep: true,
      large: false
    }],
    text: {
      x: 0,
      y: 0
    }
  }];
  var bb$2 = {
    x: -8.464,
    y: -7,
    width: 16.928,
    height: 16
  };
  var venn3 = {
    sets: sets$3,
    intersections: intersections$2,
    bb: bb$2
  };
  var sets$2 = [{
    cx: 0.439,
    cy: -1.061,
    rx: 2.5,
    ry: 5,
    rotation: 45,
    text: {
      x: 4.5,
      y: -4.5
    },
    align: "start",
    verticalAlign: "bottom"
  }, {
    cx: 2.561,
    cy: 1.061,
    rx: 2.5,
    ry: 5,
    rotation: 45,
    text: {
      x: 4,
      y: 3.75
    },
    align: "start",
    verticalAlign: "top"
  }, {
    cx: -2.561,
    cy: 1.061,
    rx: 2.5,
    ry: 5,
    rotation: -45,
    text: {
      x: -4,
      y: 3.7
    },
    align: "end",
    verticalAlign: "top"
  }, {
    cx: -0.439,
    cy: -1.061,
    rx: 2.5,
    ry: 5,
    rotation: -45,
    text: {
      x: -4.5,
      y: -4.5
    },
    align: "end",
    verticalAlign: "bottom"
  }];
  var intersections$1 = [{
    sets: [0],
    x1: 0,
    y1: -3.94,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: 4.328,
      y2: -2.828,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 2.179,
      y2: -1.858,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 0,
      y2: -3.94,
      large: false
    }],
    text: {
      x: 2.914,
      y: -3.536
    }
  }, {
    sets: [1],
    x1: 4.328,
    y1: -2.828,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: 0,
      y2: 5.006,
      sweep: true,
      large: true
    }, {
      ref: 2,
      mode: "o",
      x2: 1.328,
      y2: 2.828
    }, {
      ref: 3,
      mode: "o",
      x2: 3.108,
      y2: -0.328
    }, {
      ref: 0,
      mode: "o",
      x2: 4.328,
      y2: -2.828
    }],
    text: {
      x: 5.036,
      y: -1.414
    }
  }, {
    sets: [2],
    x1: 0,
    y1: 5.006,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: -4.328,
      y2: -2.828,
      sweep: true,
      large: true
    }, {
      ref: 3,
      mode: "o",
      x2: -3.108,
      y2: -0.328
    }, {
      ref: 0,
      mode: "o",
      x2: -1.328,
      y2: 2.828
    }, {
      ref: 1,
      mode: "o",
      x2: 0,
      y2: 5.006
    }],
    text: {
      x: -5.036,
      y: -1.414
    }
  }, {
    sets: [3],
    x1: -4.328,
    y1: -2.828,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 0,
      y2: -3.94,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -2.179,
      y2: -1.858,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -4.328,
      y2: -2.828,
      large: false
    }],
    text: {
      x: -2.914,
      y: -3.536
    }
  }, {
    sets: [0, 1],
    x1: 4.328,
    y1: -2.828,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: 3.108,
      y2: -0.328,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 2.179,
      y2: -1.858,
      sweep: false,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 4.328,
      y2: -2.828,
      sweep: true,
      large: false
    }],
    text: {
      x: 3.205,
      y: -1.672
    }
  }, {
    sets: [0, 2],
    x1: -1.328,
    y1: 2.828,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: -3.108,
      y2: -0.328,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -0.969,
      y2: 1.755,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -1.328,
      y2: 2.828,
      large: false
    }],
    text: {
      x: -2.212,
      y: 1.591
    }
  }, {
    sets: [0, 3],
    x1: 0,
    y1: -3.94,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 2.179,
      y2: -1.858,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 0,
      y2: 0.188,
      sweep: false,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -2.179,
      y2: -1.858,
      sweep: false,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 0,
      y2: -3.94,
      sweep: true
    }],
    text: {
      x: 0,
      y: -1.87
    }
  }, {
    sets: [1, 2],
    x1: 1.328,
    y1: 2.828,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 0,
      y2: 5.006,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -1.328,
      y2: 2.828,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 0,
      y2: 2.346,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 1.328,
      y2: 2.828
    }],
    text: {
      x: 0,
      y: 3.393
    }
  }, {
    sets: [1, 3],
    x1: 3.108,
    y1: -0.328,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 1.328,
      y2: 2.828,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 0.969,
      y2: 1.755,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 3.108,
      y2: -0.328,
      large: false
    }],
    text: {
      x: 2.212,
      y: 1.591
    }
  }, {
    sets: [2, 3],
    x1: -3.108,
    y1: -0.328,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -4.328,
      y2: -2.828,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: -2.179,
      y2: -1.858,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -3.108,
      y2: -0.328,
      large: false
    }],
    text: {
      x: -3.205,
      y: -1.672
    }
  }, {
    sets: [0, 1, 2],
    x1: 0,
    y1: 2.346,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: -1.328,
      y2: 2.828,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -0.969,
      y2: 1.755,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 0,
      y2: 2.346,
      large: false
    }],
    text: {
      x: -0.766,
      y: 2.31
    }
  }, {
    sets: [0, 1, 3],
    x1: 2.179,
    y1: -1.858,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 3.108,
      y2: -0.328,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 0.969,
      y2: 1.755,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 0,
      y2: 0.188,
      sweep: false,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 2.179,
      y2: -1.858,
      sweep: true
    }],
    text: {
      x: 1.558,
      y: -0.056
    }
  }, {
    sets: [0, 2, 3],
    x1: -0.969,
    y1: 1.755,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -3.108,
      y2: -0.328,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -2.179,
      y2: -1.858,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: 0,
      y2: 0.188,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -0.969,
      y2: 1.755
    }],
    text: {
      x: -1.558,
      y: -0.056
    }
  }, {
    sets: [1, 2, 3],
    x1: 1.328,
    y1: 2.828,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 0,
      y2: 2.346,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 0.969,
      y2: 1.755,
      sweep: false,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: 1.328,
      y2: 2.828,
      sweep: true,
      large: false
    }],
    text: {
      x: 0.766,
      y: 2.31
    }
  }, {
    sets: [0, 1, 2, 3],
    x1: 0,
    y1: 0.188,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 0.969,
      y2: 1.755,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 0,
      y2: 2.346,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: -0.969,
      y2: 1.755,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 0,
      y2: 0.188,
      sweep: true
    }],
    text: {
      x: 0,
      y: 1.43
    }
  }];
  var bb$1 = {
    x: -6.5,
    y: -5,
    width: 13,
    height: 10
  };
  var venn4 = {
    sets: sets$2,
    intersections: intersections$1,
    bb: bb$1
  };
  var sets$1 = [{
    cx: 0.5,
    cy: -1,
    rx: 2.5,
    ry: 5,
    rotation: 0,
    text: {
      x: 2.25,
      y: -5
    },
    align: "start",
    verticalAlign: "bottom"
  }, {
    cx: 1.106,
    cy: 0.167,
    rx: 2.5,
    ry: 5,
    rotation: 72,
    text: {
      x: 4.5,
      y: 1.5
    },
    align: "start",
    verticalAlign: "top"
  }, {
    cx: 0.183,
    cy: 1.103,
    rx: 2.5,
    ry: 5,
    rotation: 144,
    text: {
      x: 4,
      y: 4
    },
    align: "start",
    verticalAlign: "bottom"
  }, {
    cx: -0.992,
    cy: 0.515,
    rx: 2.5,
    ry: 5,
    rotation: 216,
    text: {
      x: -4.7,
      y: 2
    },
    align: "end",
    verticalAlign: "bottom"
  }, {
    cx: -0.797,
    cy: -0.785,
    rx: 2.5,
    ry: 5,
    rotation: 288,
    text: {
      x: -4,
      y: -3.6
    },
    align: "end",
    verticalAlign: "bottom"
  }];
  var intersections = [{
    sets: [0],
    x1: -1.653,
    y1: -3.541,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: 2.857,
      y2: -2.666,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 2.5,
      y2: -2.648,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -0.495,
      y2: -3.303,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: -1.653,
      y2: -3.541
    }],
    text: {
      x: 0.5,
      y: -5
    }
  }, {
    sets: [1],
    x1: 2.857,
    y1: -2.666,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: 3.419,
      y2: 1.893,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 3.291,
      y2: 1.559,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 2.988,
      y2: -1.492,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 2.857,
      y2: -2.666
    }],
    text: {
      x: 4.91,
      y: -1.07
    }
  }, {
    sets: [2],
    x1: 3.419,
    y1: 1.893,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: -0.744,
      y2: 3.837,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -0.466,
      y2: 3.612,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 2.342,
      y2: 2.381,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 3.419,
      y2: 1.893
    }],
    text: {
      x: 2.534,
      y: 4.339
    }
  }, {
    sets: [3],
    x1: -0.744,
    y1: 3.837,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -3.879,
      y2: 0.478,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: -3.579,
      y2: 0.673,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -1.54,
      y2: 2.963,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -0.744,
      y2: 3.837
    }],
    text: {
      x: -3.343,
      y: 3.751
    }
  }, {
    sets: [4],
    x1: -3.879,
    y1: 0.478,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: -1.653,
      y2: -3.541,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -1.746,
      y2: -3.196,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -3.294,
      y2: -0.549,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -3.879,
      y2: 0.478
    }],
    text: {
      x: -4.601,
      y: -2.021
    }
  }, {
    sets: [0, 1],
    x1: 2.5,
    y1: -2.648,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: 2.857,
      y2: -2.666,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 2.988,
      y2: -1.492,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 2.572,
      y2: -1.839,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 2.5,
      y2: -2.648
    }],
    text: {
      x: 2.741,
      y: -2.152
    }
  }, {
    sets: [0, 2],
    x1: 2.342,
    y1: 2.381,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: -0.466,
      y2: 3.612,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 0.257,
      y2: 2.922,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 2.342,
      y2: 2.381,
      large: false
    }],
    text: {
      x: 0.5,
      y: 3.5
    }
  }, {
    sets: [0, 3],
    x1: -0.495,
    y1: -3.303,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 2.5,
      y2: -2.648,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 1.51,
      y2: -2.515,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: -0.495,
      y2: -3.303,
      large: false
    }],
    text: {
      x: 1.653,
      y: -3.125
    }
  }, {
    sets: [0, 4],
    x1: -1.653,
    y1: -3.541,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: -0.495,
      y2: -3.303,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -0.954,
      y2: -3.015,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -1.746,
      y2: -3.196,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -1.653,
      y2: -3.541
    }],
    text: {
      x: -1.199,
      y: -3.272
    }
  }, {
    sets: [1, 2],
    x1: 3.291,
    y1: 1.559,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 3.419,
      y2: 1.893,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 2.342,
      y2: 2.381,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 2.544,
      y2: 1.878,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 3.291,
      y2: 1.559
    }],
    text: {
      x: 2.894,
      y: 1.942
    }
  }, {
    sets: [1, 3],
    x1: -1.54,
    y1: 2.963,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: -3.579,
      y2: 0.673,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: -2.7,
      y2: 1.147,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -1.54,
      y2: 2.963,
      large: false
    }],
    text: {
      x: -3.174,
      y: 1.557
    }
  }, {
    sets: [1, 4],
    x1: 2.988,
    y1: -1.492,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: 3.291,
      y2: 1.559,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 2.858,
      y2: 0.659,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 2.988,
      y2: -1.492,
      large: false
    }],
    text: {
      x: 3.483,
      y: 0.606
    }
  }, {
    sets: [2, 3],
    x1: -0.466,
    y1: 3.612,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -0.744,
      y2: 3.837,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: -1.54,
      y2: 2.963,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -1,
      y2: 3,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -0.466,
      y2: 3.612
    }],
    text: {
      x: -0.953,
      y: 3.352
    }
  }, {
    sets: [2, 4],
    x1: -3.294,
    y1: -0.549,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: -1.746,
      y2: -3.196,
      sweep: true
    }, {
      ref: 0,
      mode: "o",
      x2: -1.925,
      y2: -2.213
    }, {
      ref: 3,
      mode: "o",
      x2: -3.294,
      y2: -0.549
    }],
    text: {
      x: -2.462,
      y: -2.538
    }
  }, {
    sets: [3, 4],
    x1: -3.579,
    y1: 0.673,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: -3.879,
      y2: 0.478,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: -3.294,
      y2: -0.549,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -3.162,
      y2: -0.024,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -3.579,
      y2: 0.673
    }],
    text: {
      x: -3.483,
      y: 0.13
    }
  }, {
    sets: [0, 1, 2],
    x1: 2.544,
    y1: 1.878,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: 2.342,
      y2: 2.381,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 0.257,
      y2: 2.922,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 0.983,
      y2: 2.049,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 2.544,
      y2: 1.878
    }],
    text: {
      x: 1.457,
      y: 2.331
    }
  }, {
    sets: [0, 1, 3],
    x1: 1.51,
    y1: -2.515,
    arcs: [{
      ref: 1,
      mode: "i",
      x2: 2.5,
      y2: -2.648,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: 2.572,
      y2: -1.839,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 1.51,
      y2: -2.515,
      large: false
    }],
    text: {
      x: 2.194,
      y: -2.334
    }
  }, {
    sets: [0, 1, 4],
    x1: 2.572,
    y1: -1.839,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: 2.988,
      y2: -1.492,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 2.858,
      y2: 0.659,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 2.253,
      y2: -0.302,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 2.572,
      y2: -1.839
    }],
    text: {
      x: 2.667,
      y: -0.665
    }
  }, {
    sets: [0, 2, 3],
    x1: 0.257,
    y1: 2.922,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -0.466,
      y2: 3.612,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -1,
      y2: 3,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 0.257,
      y2: 2.922,
      large: false
    }],
    text: {
      x: -0.403,
      y: 3.178
    }
  }, {
    sets: [0, 2, 4],
    x1: -1.746,
    y1: -3.196,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: -0.954,
      y2: -3.015,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: -1.925,
      y2: -2.213,
      sweep: false,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -1.746,
      y2: -3.196,
      sweep: true,
      large: false
    }],
    text: {
      x: -1.542,
      y: -2.808
    }
  }, {
    sets: [0, 3, 4],
    x1: -0.495,
    y1: -3.303,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: 1.51,
      y2: -2.515,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: 0.409,
      y2: -2.236,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -0.954,
      y2: -3.015,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: -0.495,
      y2: -3.303
    }],
    text: {
      x: 0.192,
      y: -2.742
    }
  }, {
    sets: [1, 2, 3],
    x1: -1.54,
    y1: 2.963,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: -2.7,
      y2: 1.147,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: -1.645,
      y2: 1.568,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -1,
      y2: 3,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -1.54,
      y2: 2.963
    }],
    text: {
      x: -1.767,
      y: 2.106
    }
  }, {
    sets: [1, 2, 4],
    x1: 2.858,
    y1: 0.659,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 3.291,
      y2: 1.559,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "i",
      x2: 2.544,
      y2: 1.878,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: 2.858,
      y2: 0.659,
      large: false
    }],
    text: {
      x: 2.898,
      y: 1.365
    }
  }, {
    sets: [1, 3, 4],
    x1: -2.7,
    y1: 1.147,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: -3.579,
      y2: 0.673,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -3.162,
      y2: -0.024,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: -2.7,
      y2: 1.147,
      large: false
    }],
    text: {
      x: -3.147,
      y: 0.599
    }
  }, {
    sets: [2, 3, 4],
    x1: -3.294,
    y1: -0.549,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: -1.925,
      y2: -2.213,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -2,
      y2: -1.08,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -3.162,
      y2: -0.024,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: -3.294,
      y2: -0.549
    }],
    text: {
      x: -2.548,
      y: -1.029
    }
  }, {
    sets: [0, 1, 2, 3],
    x1: 0.983,
    y1: 2.049,
    arcs: [{
      ref: 3,
      mode: "i",
      x2: 0.257,
      y2: 2.922,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -1,
      y2: 3,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -1.645,
      y2: 1.568,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "o",
      x2: 0.983,
      y2: 2.049
    }],
    text: {
      x: -0.407,
      y: 2.31
    }
  }, {
    sets: [0, 1, 2, 4],
    x1: 2.253,
    y1: -0.302,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 2.858,
      y2: 0.659,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: 2.544,
      y2: 1.878,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "i",
      x2: 0.983,
      y2: 2.049,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "o",
      x2: 2.253,
      y2: -0.302
    }],
    text: {
      x: 2.071,
      y: 1.101
    }
  }, {
    sets: [0, 1, 3, 4],
    x1: 1.51,
    y1: -2.515,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: 2.572,
      y2: -1.839,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: 2.253,
      y2: -0.302,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "o",
      x2: 0.409,
      y2: -2.236,
      sweep: false,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: 1.51,
      y2: -2.515,
      sweep: true
    }],
    text: {
      x: 1.687,
      y: -1.63
    }
  }, {
    sets: [0, 2, 3, 4],
    x1: -2,
    y1: -1.08,
    arcs: [{
      ref: 0,
      mode: "i",
      x2: -1.925,
      y2: -2.213,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: -0.954,
      y2: -3.015,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: 0.409,
      y2: -2.236,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "o",
      x2: -2,
      y2: -1.08
    }],
    text: {
      x: -1.028,
      y: -2.108
    }
  }, {
    sets: [1, 2, 3, 4],
    x1: -1.645,
    y1: 1.568,
    arcs: [{
      ref: 4,
      mode: "i",
      x2: -2.7,
      y2: 1.147,
      sweep: true,
      large: false
    }, {
      ref: 2,
      mode: "i",
      x2: -3.162,
      y2: -0.024,
      sweep: true,
      large: false
    }, {
      ref: 1,
      mode: "i",
      x2: -2,
      y2: -1.08,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "o",
      x2: -1.645,
      y2: 1.568
    }],
    text: {
      x: -2.323,
      y: 0.327
    }
  }, {
    sets: [0, 1, 2, 3, 4],
    x1: 0.409,
    y1: -2.236,
    arcs: [{
      ref: 2,
      mode: "i",
      x2: 2.253,
      y2: -0.302,
      sweep: true,
      large: false
    }, {
      ref: 3,
      mode: "i",
      x2: 0.983,
      y2: 2.049,
      sweep: true,
      large: false
    }, {
      ref: 4,
      mode: "i",
      x2: -1.645,
      y2: 1.568,
      sweep: true,
      large: false
    }, {
      ref: 0,
      mode: "i",
      x2: -2,
      y2: -1.08,
      sweep: true
    }, {
      ref: 1,
      mode: "i",
      x2: 0.409,
      y2: -2.236,
      sweep: true
    }],
    text: {
      x: 0,
      y: 0
    }
  }];
  var bb = {
    x: -5.5,
    y: -6,
    width: 11.6,
    height: 11.8
  };
  var venn5 = {
    sets: sets$1,
    intersections: intersections,
    bb: bb
  };
  function isEllipse(d) {
    return typeof d.rx === 'number';
  }
  var vennDiagramLayout = {
    maxSets: 5,
    compute: function compute(sets, _combinations, width, height) {
      return layoutImpl(sets.length, width, height);
    }
  };
  function layoutImpl(sets, width, height) {
    var lookup = [venn0, venn1, venn2, venn3, venn4, venn5];
    var r = lookup[Math.min(lookup.length - 1, sets)];
    var f = Math.min(width / r.bb.width, height / r.bb.height);
    var x = f * -r.bb.x + (width - f * r.bb.width) / 2;
    var y = f * -r.bb.y + (height - f * r.bb.height) / 2;
    var mx = function mx(v) {
      return x + f * v;
    };
    var my = function my(v) {
      return y + f * v;
    };
    return {
      sets: r.sets.map(function (c) {
        return Object.assign({}, c, {
          cx: mx(c.cx),
          cy: my(c.cy),
          text: {
            x: mx(c.text.x),
            y: my(c.text.y)
          }
        }, isEllipse(c) ? {
          rx: c.rx * f,
          ry: c.ry * f
        } : {
          r: c.r * f
        });
      }),
      intersections: r.intersections.map(function (c) {
        return {
          text: {
            x: mx(c.text.x),
            y: my(c.text.y)
          },
          x1: mx(c.x1),
          y1: my(c.y1),
          sets: c.sets,
          arcs: c.arcs.map(function (a) {
            return Object.assign({}, a, {
              x2: mx(a.x2),
              y2: my(a.y2)
            });
          })
        };
      })
    };
  }
  var lightTheme = {
    selectionColor: '#ffa500',
    color: '#000000',
    hasSelectionColor: '',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#000000',
    hoverHintColor: '#cccccc',
    notMemberColor: '#d3d3d3',
    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
    valueTextColor: '#000000',
    strokeColor: '#000000',
    backgroundColor: '#ffffff',
    filled: false
  };
  var darkTheme = {
    selectionColor: '#ffa500',
    color: '#cccccc',
    hasSelectionColor: '',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#ffffff',
    hoverHintColor: '#d9d9d9',
    notMemberColor: '#666666',
    alternatingBackgroundColor: 'rgba(255, 255, 255, 0.2)',
    valueTextColor: '#ffffff',
    strokeColor: '#ffffff',
    backgroundColor: '#303030',
    filled: false
  };
  var vegaTheme = {
    selectionColor: '#4c78a8',
    color: '#4c78a8',
    hasSelectionColor: '#c9d6e5',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#000000',
    hoverHintColor: '#cccccc',
    notMemberColor: '#d3d3d3',
    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
    valueTextColor: '#000000',
    strokeColor: '#000000',
    backgroundColor: '#ffffff',
    filled: true
  };
  function getDefaultTheme(theme) {
    return theme === 'vega' ? vegaTheme : theme === 'dark' ? darkTheme : lightTheme;
  }
  function areCombinations$1(combinations) {
    return Array.isArray(combinations);
  }
  function styleFactory(rules) {
    return React.createElement("style", null, rules);
  }
  function fillGeneric(base,
  props) {
    var others = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var theme = getDefaultTheme(props.theme);
    return Object.assign(base, {
      queryLegend: props.queries != null && props.queries.length > 0,
      theme: 'light',
      padding: 20,
      selection: null,
      title: '',
      description: '',
      fontFamily: 'sans-serif',
      queries: EMPTY_ARRAY$2,
      exportButtons: true,
      className: '',
      fontSizes: DEFAULT_FONT_SIZES,
      classNames: EMPTY_OBJECT,
      style: EMPTY_OBJECT,
      styles: EMPTY_OBJECT,
      toKey: toKey,
      tooltips: true,
      styleFactory: styleFactory
    }, theme, props, others, props.fontSizes ? {
      fontSizes: Object.assign({}, DEFAULT_FONT_SIZES, props.fontSizes)
    } : EMPTY_OBJECT);
  }
  function fillDefaultsG(props) {
    return fillGeneric({
      barPadding: 0.3,
      dotPadding: 0.7,
      combinations: DEFAULT_COMBINATIONS,
      combinationName: props.combinations != null && !areCombinations$1(props.combinations) && props.combinations.type === 'union' ? 'Union Size' : 'Intersection Size',
      barLabelOffset: 2,
      setNameAxisOffset: 'auto',
      combinationNameAxisOffset: 'auto',
      setName: 'Set Size',
      widthRatios: DEFAULT_WIDTH_RATIO,
      heightRatios: DEFAULT_HEIGHT_RATIO,
      setLabelAlignment: 'center',
      numericScale: 'linear',
      bandScale: 'band',
      childrenFactories: EMPTY_OBJECT,
      setAddons: EMPTY_ARRAY$2,
      combinationAddons: EMPTY_ARRAY$2,
      setAddonPadding: 1,
      combinationAddonPadding: 1,
      emptySelection: true
    }, props);
  }
  function valueFormat(v) {
    return v.toLocaleString();
  }
  function fillDefaults$1(props) {
    return fillDefaultsG(props);
  }
  function fillVennDiagramDefaultsG(props) {
    return fillGeneric({
      valueFormat: valueFormat,
      layout: vennDiagramLayout,
      setLabelOffsets: EMPTY_ARRAY$2
    }, props, {
      exportButtons: props.exportButtons === false ? false : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, {
        vega: false
      })
    });
  }
  function fillVennDiagramDefaults$1(props) {
    return fillVennDiagramDefaultsG(props);
  }
  function fillKarnaughMapDefaultsG(props) {
    return fillGeneric({
      numericScale: 'linear',
      barPadding: 0.3,
      barLabelOffset: 2,
      combinationName: 'Intersection Size',
      combinationNameAxisOffset: 'auto'
    }, props, {
      exportButtons: props.exportButtons === false ? false : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, {
        vega: false
      })
    });
  }
  function fillKarnaughMapDefaults$1(props) {
    return fillKarnaughMapDefaultsG(props);
  }
  function createSVG(node, toRemove) {
    var clone = node.cloneNode(true);
    clone.style.backgroundColor = getDefaultTheme(node.dataset.theme).backgroundColor;
    if (toRemove) {
      Array.from(clone.querySelectorAll(toRemove)).forEach(function (d) {
        return d.remove();
      });
    }
    return new XMLSerializer().serializeToString(clone);
  }
  function exportSVG$1(node, _ref) {
    var _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'png' : _ref$type,
        title = _ref.title,
        toRemove = _ref.toRemove;
    var b = new Blob([createSVG(node, toRemove)], {
      type: 'image/svg+xml;charset=utf-8'
    });
    var styleId = extractStyleId(node);
    var chartTitle = title !== null && title !== void 0 ? title : extractTitle(node, styleId);
    var url = URL.createObjectURL(b);
    if (type === 'svg') {
      downloadUrl$1(url, "".concat(chartTitle, ".").concat(type), node.ownerDocument);
      URL.revokeObjectURL(url);
      return Promise.resolve();
    }
    return toPNG(url, node).then(function (purl) {
      downloadUrl$1(purl, "".concat(chartTitle, ".").concat(type), node.ownerDocument);
      URL.revokeObjectURL(url);
    });
  }
  function toPNG(url, node) {
    var canvas = node.ownerDocument.createElement('canvas');
    var bb = node.getBoundingClientRect();
    canvas.width = bb.width;
    canvas.height = bb.height;
    var ctx = canvas.getContext('2d');
    var img = new Image(canvas.width, canvas.height);
    return new Promise(function (resolve) {
      img.onload = function () {
        ctx.drawImage(img, 0, 0);
        var png = canvas.toDataURL('image/png');
        resolve(png);
      };
      img.src = url;
    });
  }
  function downloadUrl$1(url, title, doc) {
    var a = doc.createElement('a');
    a.href = url;
    a.style.position = 'absolute';
    a.style.left = '-10000px';
    a.style.top = '-10000px';
    a.download = title;
    doc.body.appendChild(a);
    a.click();
    a.remove();
  }
  function createVegaSpec(svg, title) {
    var _a, _b, _c, _d, _e;
    var resolveStyle = (_c = svg.getComputedStyle || ((_b = (_a = svg.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getComputedStyle)) !== null && _c !== void 0 ? _c : window.getComputedStyle;
    var styleId = extractStyleId(svg);
    var chartTitle = title !== null && title !== void 0 ? title : extractTitle(svg, styleId);
    var sets = Array.from(svg.querySelectorAll('[data-upset=sets] [data-cardinality]')).map(function (set) {
      return {
        name: set.querySelector("text.setTextStyle-".concat(styleId)).textContent,
        cardinality: Number.parseInt(set.dataset.cardinality, 10)
      };
    }).reverse();
    var barLabelOffset = -Number.parseFloat(svg.querySelector(".sBarTextStyle-".concat(styleId)).getAttribute('dx'));
    var color = resolveStyle(svg.querySelector(".fillPrimary-".concat(styleId))).fill;
    var fillNotMember = resolveStyle(svg.querySelector(".fillNotMember-".concat(styleId))).fill;
    var textColor = resolveStyle(svg.querySelector('text')).fill;
    var csName = svg.querySelector(".cChartTextStyle-".concat(styleId)).textContent;
    var setName = svg.querySelector(".sChartTextStyle-".concat(styleId)).textContent;
    var combinations = Array.from(svg.querySelectorAll('[data-upset=cs] [data-cardinality]')).map(function (set) {
      return {
        name: set.querySelector("text.hoverBarTextStyle-".concat(styleId)).textContent,
        cardinality: Number.parseInt(set.dataset.cardinality, 10),
        sets: Array.from(set.querySelectorAll(".fillPrimary-".concat(styleId, " > title"))).map(function (n) {
          return n.textContent;
        })
      };
    });
    var translateX = function translateX(v) {
      return Number.parseFloat(v.getAttribute('transform').match(/([\d.]+),/)[1]);
    };
    var translateY = function translateY(v) {
      return Number.parseFloat(v.getAttribute('transform').match(/,([\d.]+)/)[1]);
    };
    var base = svg.querySelector('[data-upset=base]');
    var padding = translateX(base);
    var setWidth = translateX(svg.querySelector('[data-upset=csaxis]'));
    var csWidth = Number.parseFloat(base.querySelector('g').firstElementChild.children[1].getAttribute('x2'));
    var csHeight = translateY(svg.querySelector('[data-upset=setaxis]'));
    var labelWidth = Number.parseFloat(svg.querySelector('defs rect').getAttribute('width'));
    var setHeight = Number.parseFloat(svg.querySelector('defs rect').getAttribute('height'));
    var radius = Number.parseFloat(svg.querySelector("[data-cardinality] circle.fillPrimary-".concat(styleId)).getAttribute('r'));
    var hasPrimarySelection = svg.querySelector('[data-upset=sets-s] [data-cardinality]') != null;
    var hasQuery = svg.querySelector('[data-upset=sets-q] [data-cardinality]') != null;
    var hasSelection = hasPrimarySelection || hasQuery;
    var selectionColor = 'orange';
    if (hasSelection) {
      Array.from(svg.querySelectorAll("[data-upset=sets-".concat(hasPrimarySelection ? 's]' : 'q]:first-of-type', " [data-cardinality]"))).forEach(function (elem) {
        var i = sets.length - Number.parseInt(elem.dataset.i, 10) - 1;
        sets[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
      });
      Array.from(svg.querySelectorAll("[data-upset=cs-".concat(hasPrimarySelection ? 's]' : 'q]:first-of-type', " [data-cardinality]"))).forEach(function (elem) {
        var i = Number.parseInt(elem.dataset.i, 10);
        combinations[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
      });
      selectionColor = resolveStyle(svg.querySelector("[data-upset=sets-".concat(hasPrimarySelection ? 's' : 'q', "] [data-cardinality]"))).fill;
    }
    var highlightedCombination = Number.parseInt((_e = (_d = svg.querySelector('[data-upset=cs-ss]')) === null || _d === void 0 ? void 0 : _d.dataset.i) !== null && _e !== void 0 ? _e : '-1', 10);
    var filter = highlightedCombination >= 0 ? {
      field: 'partOf',
      oneOf: [1, 2]
    } : {
      field: 'partOf',
      equal: 1
    };
    return {
      $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
      title: chartTitle,
      description: extractDescription(svg, styleId),
      datasets: {
        sets: sets,
        combinations: combinations.map(function (c, i) {
          return Object.assign({}, c, {
            partOf: highlightedCombination === i ? 2 : 1,
            nsets: ['']
          });
        }).concat(combinations.map(function (c) {
          return {
            name: c.name,
            cardinality: c.cardinality,
            partOf: 0,
            sets: [''],
            nsets: sets.filter(function (s) {
              return !c.sets.includes(s.name);
            }).map(function (s) {
              return s.name;
            })
          };
        }))
      },
      vconcat: [{
        hconcat: [{
          mark: 'bar',
          width: setWidth + labelWidth - 40,
          height: csHeight
        }, {
          width: csWidth,
          height: csHeight,
          data: {
            name: 'combinations'
          },
          transform: [{
            filter: filter
          }],
          layer: [{
            mark: {
              type: 'bar',
              tooltip: true
            }
          }, {
            mark: {
              type: 'text',
              align: 'center',
              baseline: 'bottom',
              dy: -barLabelOffset
            },
            encoding: {
              text: {
                field: 'cardinality',
                type: 'quantitative'
              }
            }
          }, hasSelection && {
            mark: {
              type: 'bar',
              fill: selectionColor,
              tooltip: true
            },
            encoding: {
              y: {
                field: 'selection',
                type: 'quantitative'
              }
            }
          }].filter(Boolean),
          encoding: {
            x: {
              field: 'name',
              type: 'ordinal',
              axis: null,
              sort: null
            },
            y: {
              field: 'cardinality',
              type: 'quantitative',
              axis: {
                grid: false
              },
              title: csName
            }
          }
        }]
      }, {
        hconcat: [{
          width: setWidth,
          height: setHeight,
          data: {
            name: 'sets'
          },
          layer: [{
            mark: {
              type: 'bar',
              tooltip: true
            }
          }, {
            mark: {
              type: 'text',
              align: 'right',
              baseline: 'middle',
              dx: -barLabelOffset
            },
            encoding: {
              text: {
                field: 'cardinality',
                type: 'quantitative'
              }
            }
          }, hasSelection && {
            mark: {
              type: 'bar',
              fill: selectionColor,
              tooltip: true
            },
            encoding: {
              x: {
                field: 'selection',
                type: 'quantitative'
              }
            }
          }].filter(Boolean),
          encoding: {
            y: {
              field: 'name',
              type: 'ordinal',
              axis: null,
              sort: null
            },
            x: {
              field: 'cardinality',
              type: 'quantitative',
              title: setName,
              sort: 'descending',
              axis: {
                grid: false
              }
            }
          }
        }, {
          data: {
            name: 'sets'
          },
          width: labelWidth,
          height: setHeight,
          mark: {
            type: 'text',
            align: 'center',
            baseline: 'middle',
            fontSize: Number.parseInt(resolveStyle(svg.querySelector(".setTextStyle-".concat(styleId))).fontSize, 10)
          },
          encoding: {
            y: {
              field: 'name',
              type: 'ordinal',
              axis: null,
              sort: null
            },
            text: {
              field: 'name',
              type: 'ordinal'
            }
          }
        }, {
          width: csWidth,
          height: setHeight,
          data: {
            name: 'combinations'
          },
          transform: [{
            flatten: ['sets'],
            as: ['has_set']
          }, {
            flatten: ['nsets'],
            as: ['has_not_set']
          }, {
            calculate: 'datum.has_set+datum.has_not_set',
            as: 'set'
          }],
          layer: [{
            mark: {
              type: 'circle',
              size: radius * radius * Math.PI,
              tooltip: true
            },
            encoding: {
              color: {
                field: 'partOf',
                type: 'nominal',
                legend: null,
                scale: {
                  range: [fillNotMember, color].concat(highlightedCombination >= 0 ? [selectionColor] : [])
                }
              },
              y: {
                field: 'set',
                type: 'ordinal',
                axis: null,
                sort: null,
                scale: {
                  domain: sets.map(function (s) {
                    return s.name;
                  })
                }
              }
            }
          }, {
            mark: 'rule',
            transform: [{
              filter: filter
            }, {
              calculate: 'datum.sets[datum.sets.length -1]',
              as: 'set_end'
            }],
            encoding: Object.assign({
              y: {
                field: 'sets[0]',
                type: 'ordinal',
                axis: null,
                sort: null
              },
              y2: {
                field: 'set_end'
              }
            }, highlightedCombination < 0 ? {} : {
              color: {
                field: 'partOf',
                type: 'nominal',
                legend: null,
                scale: {
                  range: [color, selectionColor]
                }
              }
            })
          }],
          encoding: {
            x: {
              field: 'name',
              type: 'ordinal',
              axis: null,
              sort: null
            }
          }
        }]
      }],
      config: {
        padding: padding,
        background: getDefaultTheme(svg.dataset.theme).backgroundColor,
        concat: {
          spacing: 0
        },
        view: {
          stroke: null
        },
        bar: {
          fill: color
        },
        circle: {
          opacity: 1
        },
        rule: {
          stroke: color,
          strokeWidth: Number.parseInt(resolveStyle(svg.querySelector("[data-upset=cs] [data-cardinality] line")).strokeWidth, 10)
        },
        axis: {
          labelColor: textColor,
          labelFontSize: Number.parseInt(resolveStyle(svg.querySelector(".axisTextStyle-".concat(styleId))).fontSize, 10),
          titleColor: textColor,
          titleFontSize: Number.parseInt(resolveStyle(svg.querySelector(".cChartTextStyle-".concat(styleId))).fontSize, 10)
        },
        title: {
          color: textColor
        },
        text: {
          fill: textColor,
          fontSize: Number.parseInt(resolveStyle(svg.querySelector(".sBarTextStyle-".concat(styleId))).fontSize, 10)
        }
      }
    };
  }
  function exportVegaLite(svg) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        title = _ref2.title;
    var spec = createVegaSpec(svg, title);
    var url = URL.createObjectURL(new Blob([JSON.stringify(spec, null, 2)], {
      type: 'application/json'
    }));
    downloadUrl$1(url, "".concat(spec.title, ".json"), svg.ownerDocument);
    URL.revokeObjectURL(url);
  }
  var THEME_KEYS = ['selectionColor', 'color', 'textColor', 'hoverHintColor', 'notMemberColor', 'alternatingBackgroundColor', 'hasSelectionColor', 'hasSelectionOpacity', 'opacity', 'strokeColor', 'valueTextColor'];
  var LAYOUT_KEYS = ['padding', 'barPadding', 'dotPadding', 'widthRatios', 'heightRatios'];
  var STYLE_KEYS = ['fontSizes', 'combinationName', 'setName', 'barLabelOffset', 'setNameAxisOffset', 'combinationNameAxisOffset', 'theme', 'fontFamily', 'emptySelection', 'exportButtons', 'queryLegend'];
  var DUMP_KEYS = ['bandScale', 'numericScale'].concat(THEME_KEYS, LAYOUT_KEYS, STYLE_KEYS);
  function toDumpProps(props) {
    var _a;
    var full = fillDefaults$1({
      width: 0,
      height: 0,
      sets: (_a = props.sets) !== null && _a !== void 0 ? _a : [],
      combinations: props.combinations,
      theme: props.theme
    });
    var r = {};
    DUMP_KEYS.forEach(function (key) {
      var value = props[key];
      var defaultValue = full[key];
      if (key === 'theme' && value !== 'light') {
        r[key] = value;
        return;
      }
      if (value == null || value === defaultValue) {
        return;
      }
      if (key === 'fontSizes') {
        var empty = true;
        var sub = {};
        FONT_SIZES_KEYS.forEach(function (fKey) {
          var fValue = value[fKey];
          var fDefaultValue = defaultValue[fKey];
          if (fValue !== fDefaultValue) {
            sub[fKey] = fValue;
            empty = false;
          }
        });
        if (!empty) {
          r[key] = sub;
        }
      } else {
        r[key] = value;
      }
    });
    return r;
  }
  function toUpSetJSDump$1(dump, elements, props, author, mode) {
    return Object.assign({
      $schema: 'https://upset.js.org/schema.1.0.0.json',
      name: typeof props.title === 'string' ? props.title : 'UpSetJS',
      description: typeof props.description === 'string' ? props.description : '',
      mode: mode,
      author: author,
      elements: elements,
      attrs: [],
      props: toDumpProps(props)
    }, dump);
  }
  function toUpSetJSStaticDump$1(dump, props, author, mode) {
    return Object.assign({
      $schema: 'https://upset.js.org/schema-static.1.0.0.json',
      name: typeof props.title === 'string' ? props.title : 'UpSetJS',
      description: typeof props.description === 'string' ? props.description : '',
      mode: mode,
      author: author,
      props: toDumpProps(props)
    }, dump);
  }
  function exportDumpData(props, data) {
    var compress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var mode = arguments.length > 3 ? arguments[3] : undefined;
    var _a, _b;
    var elems = [];
    var lookup = new Map();
    var toElemIndex = function toElemIndex(elem) {
      if (lookup.has(elem)) {
        return lookup.get(elem);
      }
      lookup.set(elem, elems.length);
      elems.push(elem);
      return elems.length - 1;
    };
    var dump = toDump({
      sets: props.sets,
      queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter(function (d) {
        return isElemQuery(d) || isSetQuery(d);
      })) !== null && _b !== void 0 ? _b : [],
      toElemIndex: toElemIndex,
      selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,
      combinations: data.cs.v,
      combinationOptions: Array.isArray(props.combinations) ? {} : props.combinations
    }, {
      compress: compress ? 'yes' : 'no'
    });
    return toUpSetJSDump$1(dump, elems, props, undefined, mode);
  }
  function exportStaticDumpData(props, data) {
    var compress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var mode = arguments.length > 3 ? arguments[3] : undefined;
    var _a, _b;
    var dump = toStaticDump({
      sets: props.sets,
      queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter(function (d) {
        return isElemQuery(d) || isSetQuery(d);
      })) !== null && _b !== void 0 ? _b : [],
      selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,
      combinations: data.cs.v
    }, {
      compress: compress ? 'yes' : 'no'
    });
    return toUpSetJSStaticDump$1(dump, props, undefined, mode);
  }
  function exportDump(svg, props, data, mode) {
    var dump = exportDumpData(props, data, false, mode);
    var url = URL.createObjectURL(new Blob([JSON.stringify(dump, null, 2)], {
      type: 'application/json'
    }));
    downloadUrl$1(url, "".concat(dump.name, ".json"), svg.ownerDocument);
    URL.revokeObjectURL(url);
  }
  var MAX_URL_LENGTH = 2048 * 2;
  function exportSharedLink(props, data, mode) {
    var r = exportDumpData(props, data, true, mode);
    delete r.$schema;
    var arg = LZString.compressToEncodedURIComponent(JSON.stringify(r));
    var url = new URL('https://upset.js.org/app/embed.html');
    url.searchParams.set('p', arg);
    if (url.toString().length < MAX_URL_LENGTH) {
      window.open(url.toString(), '_blank');
      return true;
    }
    var r2 = exportStaticDumpData(props, data, true, mode);
    delete r2.$schema;
    var arg2 = LZString.compressToEncodedURIComponent(JSON.stringify(r2));
    url.searchParams.set('p', arg2);
    if (url.toString().length < MAX_URL_LENGTH) {
      window.open(url.toString(), '_blank');
      return true;
    }
    url.searchParams["delete"]('p');
    var w = window.open(url.toString(), '_blank');
    w === null || w === void 0 ? void 0 : w.addEventListener('load', function () {
      w === null || w === void 0 ? void 0 : w.postMessage(r, url.origin);
    });
    return false;
  }
  function clsx() {
    for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }
    return classNames.filter(Boolean).join(' ');
  }
  function generateId(_args) {
    return "upset-".concat(Math.random().toString(36).slice(4));
  }
  function isSetLike(s) {
    return s != null && !Array.isArray(s);
  }
  function elemOverlapOf(query, toElemKey) {
    var f = setOverlapFactory(query, toElemKey);
    return function (s) {
      return f(s.elems).intersection;
    };
  }
  function noGuessPossible() {
    return -1;
  }
  function generateSelectionOverlap(selection, overlapGuesser, toElemKey) {
    if (!selection) {
      return noOverlap;
    }
    if (typeof selection === 'function') {
      return selection;
    }
    if (Array.isArray(selection)) {
      return elemOverlapOf(selection, toElemKey);
    }
    var ss = selection;
    if (ss.overlap) {
      return ss.overlap.bind(ss);
    }
    var f = null;
    return function (s) {
      if (s.overlap) {
        return s.overlap(ss);
      }
      var guess = overlapGuesser(s, ss);
      if (guess >= 0) {
        return guess;
      }
      if (!f) {
        f = elemOverlapOf(ss.elems, toElemKey);
      }
      return f(s);
    };
  }
  function generateSelectionName(selection) {
    var _a;
    return Array.isArray(selection) ? "Array(".concat(selection.length, ")") : typeof selection === 'function' ? '?' : (_a = selection) === null || _a === void 0 ? void 0 : _a.name;
  }
  function elemElemOverlapOf(query, toElemKey) {
    var f = setElemOverlapFactory(query, toElemKey);
    return function (s) {
      return f(s.elems).intersection;
    };
  }
  function noOverlap() {
    return 0;
  }
  function parseFontSize(v) {
    if (v == null) {
      return 10;
    }
    if (v.endsWith('pt')) {
      return Math.floor(4 / 3 * Number.parseInt(v, 10));
    }
    return Number.parseInt(v, 10);
  }
  function toAnchor(alignment) {
    var _a;
    var alignments = {
      left: 'start',
      center: 'middle',
      right: 'end'
    };
    return (_a = alignments[alignment]) !== null && _a !== void 0 ? _a : 'middle';
  }
  function resolveNumericScale(factory) {
    if (factory === 'linear') {
      return linearScale;
    }
    if (factory === 'log') {
      return logScale;
    }
    return factory;
  }
  function resolveBandScale(factory) {
    return factory === 'band' ? bandScale$1 : factory;
  }
  function areCombinations(combinations) {
    return Array.isArray(combinations);
  }
  function deriveDataDependent(sets, combinations, sizes, numericScale, bandScale, barLabelFontSize, dotPadding, barPadding, tickFontSize, combinationAddons, toKey, toElemKey, id, setMaxScale, combinationMaxScale) {
    var _a;
    var numericScaleFactory = resolveNumericScale(numericScale);
    var bandScaleFactory = resolveBandScale(bandScale);
    var cs = areCombinations(combinations) ? combinations : generateCombinations(sets, Object.assign({
      toElemKey: toElemKey
    }, DEFAULT_COMBINATIONS, combinations));
    var csKeys = cs.map(toKey);
    var combinationX = bandScaleFactory(csKeys, sizes.cs.w, sizes.padding);
    var dataCSCardinality = cs.reduce(function (acc, d) {
      return Math.max(acc, d.cardinality);
    }, 0);
    var maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : dataCSCardinality;
    var combinationYEnd = maxCSCardinality > dataCSCardinality ? 0 : barLabelFontSize;
    var combinationY = numericScaleFactory(maxCSCardinality, [sizes.cs.h, combinationYEnd], {
      orientation: 'vertical',
      fontSizeHint: tickFontSize
    });
    var labelSize = function labelSize(text) {
      return Math.floor(barLabelFontSize / 1.4 * 0.7 * text.length);
    };
    var guessLabelWidth = function guessLabelWidth(v) {
      return labelSize(combinationY.tickFormat()(v));
    };
    var dataSetCardinality = sets.reduce(function (acc, d) {
      return Math.max(acc, d.cardinality);
    }, 0);
    var maxSetCardinality = setMaxScale !== null && setMaxScale !== void 0 ? setMaxScale : dataSetCardinality;
    var largestSetLabelWidth = guessLabelWidth(maxSetCardinality);
    var largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
    var _iterator = _createForOfIteratorHelper(combinationAddons),
        _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var addon = _step.value;
        if (!addon.scale) {
          continue;
        }
        var ticks = addon.scale.ticks(3);
        var f = addon.scale.tickFormat();
        var _iterator2 = _createForOfIteratorHelper(ticks),
            _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var tick = _step2.value;
            var l = typeof tick === 'number' ? f(tick) : (_a = tick.label) !== null && _a !== void 0 ? _a : f(tick.value);
            var size = labelSize(l);
            if (size > largestCSLabelWidth) {
              largestCSLabelWidth = size;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var setShift = maxSetCardinality > dataSetCardinality ? 0 : largestSetLabelWidth;
    var setX = numericScaleFactory(maxSetCardinality, [sizes.sets.w, setShift], {
      orientation: 'horizontal',
      fontSizeHint: tickFontSize
    });
    var setKeys = sets.map(toKey);
    var setY = bandScaleFactory(setKeys.slice().reverse(),
    sizes.sets.h, sizes.padding);
    var r = Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2 * dotPadding;
    var triangleSize = Math.max(2, Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2 * barPadding);
    return {
      id: id ? id : generateId(),
      r: r,
      triangleSize: triangleSize,
      sets: {
        v: sets,
        keys: setKeys,
        rv: sets.slice().reverse(),
        x: setX,
        xAxisWidth: sizes.sets.w - setShift,
        y: function y(s) {
          return setY(toKey(s));
        },
        max: maxSetCardinality,
        bandWidth: setY.bandwidth(),
        cy: setY.bandwidth() / 2 + sizes.cs.h,
        format: setX.tickFormat(),
        labelOffset: barLabelFontSize + 9 + 2
      },
      cs: {
        v: cs,
        keys: cs.map(toKey),
        x: function x(s) {
          return combinationX(toKey(s));
        },
        max: maxCSCardinality,
        y: combinationY,
        yAxisWidth: sizes.cs.h - combinationYEnd,
        cx: combinationX.bandwidth() / 2,
        bandWidth: combinationX.bandwidth(),
        format: combinationY.tickFormat(),
        has: function has(v, s) {
          var sk = toKey(s);
          return Array.from(v.sets).some(function (ss) {
            return toKey(ss) === sk;
          });
        },
        labelOffset: largestCSLabelWidth + 9 + 6
      },
      toKey: toKey,
      toElemKey: toElemKey,
      overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey)
    };
  }
  function deriveSizeDependent(width, height, margin, barPadding, widthRatios, heightRatios, setAddons, combinationAddons, id, setAddonPadding, combinationAddonPadding) {
    var setAddonsBefore = setAddons.reduce(function (acc, a) {
      return acc + (a.position === 'before' ? a.size + setAddonPadding : 0);
    }, 0);
    var setAddonsAfter = setAddons.reduce(function (acc, a) {
      return acc + (a.position !== 'before' ? a.size + setAddonPadding : 0);
    }, 0);
    var combinationAddonsBefore = combinationAddons.reduce(function (acc, a) {
      return acc + (a.position === 'before' ? a.size + setAddonPadding : 0);
    }, 0);
    var combinationAddonsAfter = combinationAddons.reduce(function (acc, a) {
      return acc + (a.position !== 'before' ? a.size + setAddonPadding : 0);
    }, 0);
    var h = height - 2 * margin - 20 - combinationAddonsAfter - combinationAddonsBefore;
    var w = width - 2 * margin - setAddonsBefore - setAddonsAfter;
    var setWidth = widthRatios[0] > 1 ? widthRatios[0] : w * widthRatios[0];
    var labelsWidth = widthRatios[1] > 1 ? widthRatios[1] : w * widthRatios[1];
    var combinationHeight = heightRatios[0] > 1 ? heightRatios[0] : h * heightRatios[0];
    return {
      id: id ? id : generateId(),
      cs: {
        before: combinationAddonsBefore,
        after: combinationAddonsAfter,
        x: setAddonsBefore + setWidth + labelsWidth,
        y: combinationAddonsBefore,
        w: w - setWidth - labelsWidth,
        h: combinationHeight,
        addons: combinationAddons,
        addonPadding: combinationAddonPadding
      },
      labels: {
        x: setAddonsBefore + setWidth,
        y: combinationAddonsBefore + combinationHeight,
        w: labelsWidth,
        h: h - combinationHeight
      },
      sets: {
        before: setAddonsBefore,
        after: setAddonsAfter,
        x: setAddonsBefore,
        y: combinationAddonsBefore + combinationHeight,
        w: setWidth,
        h: h - combinationHeight,
        addons: setAddons,
        addonPadding: setAddonPadding
      },
      padding: barPadding,
      legend: {
        x: width / 2
      },
      margin: margin,
      w: width,
      h: height
    };
  }
  function deriveStyleDependent$1(theme, styles, classNames, combinationName, combinationNameAxisOffset, setName, setNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips, setLabelAlignment) {
    return {
      theme: theme,
      styles: styles,
      classNames: classNames,
      cs: {
        name: combinationName,
        offset: combinationNameAxisOffset
      },
      sets: {
        name: setName,
        offset: setNameAxisOffset
      },
      emptySelection: emptySelection,
      id: styleId,
      barLabelOffset: barLabelOffset,
      selectionColor: selectionColor,
      title: title,
      description: description,
      tooltips: tooltips,
      setLabelAlignment: setLabelAlignment
    };
  }
  function ExportButtons(_ref3) {
    var transform = _ref3.transform,
        styleId = _ref3.styleId,
        exportButtons = _ref3.exportButtons,
        exportChart = _ref3.exportChart;
    if (!exportButtons) {
      return null;
    }
    var svgWidth = 26;
    var pngWidth = 26;
    var vegaWidth = 34;
    var dumpWidth = 34;
    var shareWidth = 42;
    var space = 2;
    var acc = 0;
    var buttons = [];
    if (exportButtons === true || exportButtons.svg !== false) {
      acc += svgWidth;
      buttons.push(React.createElement("g", {
        key: "svg",
        className: "exportButton-".concat(styleId),
        onClick: exportChart,
        "data-type": "svg",
        transform: "translate(-".concat(acc, ", 0)")
      }, React.createElement("title", null, "Download SVG Image"), React.createElement("rect", {
        y: -9,
        width: svgWidth,
        height: 11,
        rx: 2,
        ry: 2
      }), React.createElement("text", {
        className: "exportTextStyle-".concat(styleId),
        x: svgWidth / 2
      }, "SVG")));
      acc += space;
    }
    if (exportButtons === true || exportButtons.png !== false) {
      acc += pngWidth;
      buttons.push(React.createElement("g", {
        key: "png",
        className: "exportButton-".concat(styleId),
        onClick: exportChart,
        "data-type": "png",
        transform: "translate(-".concat(acc, ", 0)")
      }, React.createElement("title", null, "Download PNG Image"), React.createElement("rect", {
        y: -9,
        width: pngWidth,
        height: 11,
        rx: 2,
        ry: 2
      }), React.createElement("text", {
        className: "exportTextStyle-".concat(styleId),
        x: pngWidth / 2
      }, "PNG")));
      acc += space;
    }
    if (exportButtons === true || exportButtons.vega !== false) {
      acc += vegaWidth;
      buttons.push(React.createElement("g", {
        key: "vega",
        className: "exportButton-".concat(styleId),
        onClick: exportChart,
        "data-type": "vega",
        transform: "translate(-".concat(acc, ", 0)")
      }, React.createElement("title", null, "Download VEGA-Lite Specification"), React.createElement("rect", {
        y: -9,
        width: vegaWidth,
        height: 11,
        rx: 2,
        ry: 2
      }), React.createElement("text", {
        className: "exportTextStyle-".concat(styleId),
        x: vegaWidth / 2
      }, "VEGA")));
      acc += space;
    }
    if (exportButtons === true || exportButtons.dump !== false) {
      acc += dumpWidth;
      buttons.push(React.createElement("g", {
        key: "dump",
        className: "exportButton-".concat(styleId),
        onClick: exportChart,
        "data-type": "dump",
        transform: "translate(-".concat(acc, ", 0)")
      }, React.createElement("title", null, "Download UpSet.js JSON Dump"), React.createElement("rect", {
        y: -9,
        width: dumpWidth,
        height: 11,
        rx: 2,
        ry: 2
      }), React.createElement("text", {
        className: "exportTextStyle-".concat(styleId),
        x: dumpWidth / 2
      }, "DUMP")));
      acc += space;
    }
    if (exportButtons === true || exportButtons.share !== false) {
      acc += shareWidth;
      buttons.push(React.createElement("g", {
        key: "share",
        className: "exportButton-".concat(styleId),
        onClick: exportChart,
        "data-type": "share",
        transform: "translate(-".concat(acc, ", 0)")
      }, React.createElement("title", null, "Open a shareable URL"), React.createElement("rect", {
        y: -9,
        width: shareWidth,
        height: 11,
        rx: 2,
        ry: 2
      }), React.createElement("text", {
        className: "exportTextStyle-".concat(styleId),
        x: shareWidth / 2
      }, "SHARE")));
      acc += space;
    }
    return React.createElement("g", {
      className: "exportButtons-".concat(styleId),
      transform: transform
    }, buttons);
  }
  var QueryLegend =
  /*!#__PURE__*/
  React.memo(function QueryLegend(_ref4) {
    var queries = _ref4.queries,
        x = _ref4.x,
        style = _ref4.style,
        data = _ref4.data;
    return React.createElement("text", {
      transform: "translate(".concat(x, ",4)"),
      style: style.styles.legend,
      className: clsx("legendTextStyle-".concat(style.id), style.classNames.legend)
    }, queries.map(function (q, i) {
      var count = null;
      if (isSetQuery(q)) {
        count = q.set.cardinality;
      } else if (isElemQuery(q)) {
        count = q.elems instanceof Set ? q.elems.size : q.elems.length;
      }
      return React.createElement(React.Fragment, {
        key: q.name
      }, React.createElement("tspan", {
        className: "fillQ".concat(i, "-").concat(data.id)
      }, '  ⬤ '), React.createElement("tspan", null, q.name, count != null ? ": ".concat(data.sets.format(count)) : ''));
    }));
  });
  var HorizontalTick =
  /*!#__PURE__*/
  React.memo(function HorizontalTick(_ref5) {
    var pos = _ref5.pos,
        spacing = _ref5.spacing,
        tickSizeInner = _ref5.tickSizeInner,
        orient = _ref5.orient,
        name = _ref5.name,
        style = _ref5.style;
    var k = orient === 'top' || orient === 'left' ? -1 : 1;
    return React.createElement("g", {
      transform: "translate(0, ".concat(pos + 0.5, ")")
    }, name && React.createElement("text", {
      x: k * spacing,
      dy: '0.32em',
      className: clsx("axisTextStyle-".concat(style.id), orient === 'right' ? "startText-".concat(style.id) : "endText-".concat(style.id), style.classNames.axisTick),
      style: style.styles.axisTick
    }, name), React.createElement("line", {
      x2: k * tickSizeInner,
      className: "axisLine-".concat(style.id)
    }));
  });
  var VerticalTick =
  /*!#__PURE__*/
  React.memo(function VerticalTick(_ref6) {
    var pos = _ref6.pos,
        name = _ref6.name,
        spacing = _ref6.spacing,
        orient = _ref6.orient,
        tickSizeInner = _ref6.tickSizeInner,
        style = _ref6.style;
    var k = orient === 'top' || orient === 'left' ? -1 : 1;
    return React.createElement("g", {
      transform: "translate(".concat(pos + 0.5, ", 0)")
    }, name && React.createElement("text", {
      y: k * spacing,
      dy: orient === 'top' ? '0em' : '0.71em',
      className: clsx("axisTextStyle-".concat(style.id), style.classNames.axisTick),
      style: style.styles.axisTick
    }, name), React.createElement("line", {
      y2: k * tickSizeInner,
      className: "axisLine-".concat(style.id)
    }));
  });
  function Axis(_ref7) {
    var scale = _ref7.scale,
        orient = _ref7.orient,
        _ref7$tickSizeInner = _ref7.tickSizeInner,
        tickSizeInner = _ref7$tickSizeInner === void 0 ? 6 : _ref7$tickSizeInner,
        _ref7$tickSizeOuter = _ref7.tickSizeOuter,
        tickSizeOuter = _ref7$tickSizeOuter === void 0 ? 6 : _ref7$tickSizeOuter,
        _ref7$tickPadding = _ref7.tickPadding,
        tickPadding = _ref7$tickPadding === void 0 ? 3 : _ref7$tickPadding,
        size = _ref7.size,
        start = _ref7.start,
        style = _ref7.style,
        transform = _ref7.transform;
    var spacing = Math.max(tickSizeInner, 0) + tickPadding;
    var range0 = start;
    var range1 = size;
    var k = orient === 'top' || orient === 'left' ? -1 : 1;
    var Tick = orient === 'left' || orient === 'right' ? HorizontalTick : VerticalTick;
    var values = scale.ticks().map(function (d) {
      return typeof d === 'number' ? {
        value: d,
        label: d.toLocaleString()
      } : d;
    });
    return React.createElement("g", {
      transform: transform
    }, values.map(function (d) {
      return React.createElement(Tick, {
        key: d.value,
        pos: scale(d.value),
        name: d.label,
        spacing: spacing,
        tickSizeInner: tickSizeInner,
        orient: orient,
        style: style
      });
    }), React.createElement("path", {
      className: "axisLine-".concat(style.id),
      d: orient === 'left' || orient === 'right' ? tickSizeOuter ? "M".concat(k * tickSizeOuter, ",").concat(range0, "H0.5V").concat(range1, "H").concat(k * tickSizeOuter) : "M0.5,".concat(range0, "V").concat(range1) : tickSizeOuter ? "M".concat(range0, ",").concat(k * tickSizeOuter, "V0.5H").concat(range1, "V").concat(k * tickSizeOuter) : "M".concat(range0, ",0.5H").concat(range1)
    }));
  }
  var MultilineText =
  /*!#__PURE__*/
  React.memo(function MultilineText(_ref8) {
    var width = _ref8.width,
        text = _ref8.text,
        dy = _ref8.dy,
        x = _ref8.x,
        style = _ref8.style,
        className = _ref8.className;
    var ref = s(null);
    var _useState = l(typeof text === 'string' ? [text] : []),
        _useState2 = _slicedToArray(_useState, 2),
        lines = _useState2[0],
        setLines = _useState2[1];
    h(function () {
      if (typeof text === 'string') {
        setLines([text]);
      } else {
        setLines([]);
      }
    }, [text]);
    h(function () {
      if (!ref.current || ref.current.childElementCount > 0 || typeof text !== 'string' || typeof ref.current.getComputedTextLength !== 'function') {
        return;
      }
      var len = ref.current.getComputedTextLength();
      var lines = [];
      var lineWidth = width;
      var start = 0;
      var p = ref.current.getStartPositionOfChar(0);
      while (len > lineWidth) {
        p.x = lineWidth;
        var num = ref.current.getCharNumAtPosition(p);
        var space = text.lastIndexOf(' ', num);
        if (space < start) {
          break;
        }
        lines.push(text.slice(start, space + 1));
        var used = ref.current.getEndPositionOfChar(space + 1).x;
        start = space + 1;
        lineWidth = used + width;
      }
      lines.push(text.slice(start));
      setLines(lines);
    }, [ref, text, width]);
    if (!text) {
      return null;
    }
    return React.createElement("tspan", {
      ref: ref,
      dy: dy,
      style: style,
      x: x,
      className: className
    }, lines.length > 1 ? lines.map(function (l, i) {
      return React.createElement("tspan", {
        key: l,
        x: 0,
        dy: i > 0 ? '1.2em' : dy
      }, l);
    }) : text);
  });
  var UpSetTitle =
  /*!#__PURE__*/
  React.memo(function UpSetTitle(_ref9) {
    var width = _ref9.width,
        _ref9$descriptionWidt = _ref9.descriptionWidth,
        descriptionWidth = _ref9$descriptionWidt === void 0 ? width : _ref9$descriptionWidt,
        style = _ref9.style;
    if (!style.title && !style.description) {
      return null;
    }
    return React.createElement("text", null, React.createElement(MultilineText, {
      text: style.title,
      width: width,
      dy: "10px",
      className: clsx("titleTextStyle-".concat(style.id), style.classNames.title),
      style: style.styles.title
    }), React.createElement(MultilineText, {
      x: 0,
      width: descriptionWidth,
      dy: style.title ? '2em' : '10px',
      text: style.description,
      className: clsx("descTextStyle-".concat(style.id), style.classNames.description),
      style: style.styles.description
    }));
  });
  function noop() {
    return undefined;
  }
  function wrap(f) {
    if (!f) {
      return noop;
    }
    return function (set, addons) {
      return function (evt) {
        return f.call(this, set, evt.nativeEvent, addons.map(function (a) {
          return a.createOnHandlerData ? a.createOnHandlerData(set) : null;
        }));
      };
    };
  }
  function addonPositionGenerator(total, padding) {
    var beforeAcc = 0;
    var afterAcc = 0;
    return function (addon) {
      var x = 0;
      if (addon.position === 'before') {
        beforeAcc += addon.size + padding;
        x = -beforeAcc;
      } else {
        x = total + afterAcc + padding;
        afterAcc += addon.size + padding;
      }
      return x;
    };
  }
  function mergeColor(style, color) {
    var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'fill';
    if (!color) {
      return style;
    }
    if (!style) {
      return !color ? undefined : _defineProperty({}, prop, color);
    }
    return Object.assign(_defineProperty({}, prop, color), style);
  }
  var UpSetAxis =
  /*!#__PURE__*/
  React.memo(function UpSetAxis(_ref11) {
    var size = _ref11.size,
        style = _ref11.style,
        data = _ref11.data;
    var setPosGen = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
    var combinationPosGen = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
    var csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
    var setNameOffset = style.sets.offset === 'auto' ? data.sets.labelOffset : style.sets.offset;
    return React.createElement("g", null, React.createElement(UpSetTitle, {
      style: style,
      width: size.cs.x - csNameOffset - 20
    }), size.cs.h > 0 && React.createElement("g", {
      transform: "translate(".concat(size.cs.x, ",").concat(size.cs.y, ")"),
      "data-upset": "csaxis"
    }, React.createElement(Axis, {
      scale: data.cs.y,
      orient: "left",
      size: size.cs.h,
      start: size.cs.h - data.cs.yAxisWidth,
      style: style
    }), React.createElement("line", {
      x1: 0,
      x2: size.cs.w,
      y1: size.cs.h + 1,
      y2: size.cs.h + 1,
      className: "axisLine-".concat(style.id)
    }), React.createElement("text", {
      className: clsx("cChartTextStyle-".concat(style.id), style.classNames.chartLabel),
      style: style.styles.chartLabel,
      transform: "translate(".concat(-csNameOffset, ", ").concat(size.cs.h / 2, ")rotate(-90)")
    }, style.cs.name), size.cs.addons.map(function (addon) {
      var pos = combinationPosGen(addon);
      var title = React.createElement("text", {
        key: addon.name,
        className: clsx("cChartTextStyle-".concat(style.id), style.classNames.chartLabel),
        style: style.styles.chartLabel,
        transform: "translate(".concat(-csNameOffset, ", ").concat(pos + addon.size / 2, ")rotate(-90)")
      }, addon.name);
      if (!addon.scale) {
        return title;
      }
      return React.createElement(React.Fragment, {
        key: addon.name
      }, React.createElement(Axis, {
        scale: addon.scale,
        orient: "left",
        size: addon.size,
        start: 0,
        style: style,
        transform: "translate(0,".concat(pos, ")")
      }), title);
    })), size.sets.w > 0 && React.createElement("g", {
      transform: "translate(".concat(size.sets.x, ",").concat(size.sets.y, ")"),
      "data-upset": "setaxis"
    }, React.createElement(Axis, {
      scale: data.sets.x,
      orient: "bottom",
      size: size.sets.w,
      start: size.sets.w - data.sets.xAxisWidth,
      transform: "translate(0, ".concat(size.sets.h, ")"),
      style: style
    }), React.createElement("text", {
      className: clsx("sChartTextStyle-".concat(style.id), style.classNames.chartLabel),
      style: style.styles.chartLabel,
      transform: "translate(".concat(size.sets.w / 2, ", ").concat(size.sets.h + setNameOffset, ")")
    }, style.sets.name), size.sets.addons.map(function (addon) {
      var pos = setPosGen(addon);
      var title = React.createElement("text", {
        key: addon.name,
        className: clsx("sChartTextStyle-".concat(style.id), style.classNames.chartLabel),
        style: style.styles.chartLabel,
        transform: "translate(".concat(pos + addon.size / 2, ", ").concat(size.sets.h + setNameOffset, ")")
      }, addon.name);
      if (!addon.scale) {
        return title;
      }
      return React.createElement(React.Fragment, {
        key: addon.name
      }, React.createElement(Axis, {
        scale: addon.scale,
        orient: "bottom",
        size: addon.size,
        start: 0,
        transform: "translate(".concat(pos, ", ").concat(size.sets.h, ")"),
        style: style
      }), title);
    })));
  });
  var UpSetDot =
  /*!#__PURE__*/
  React.memo(function UpSetDot(_ref12) {
    var cx = _ref12.cx,
        r = _ref12.r,
        cy = _ref12.cy,
        name = _ref12.name,
        className = _ref12.className,
        style = _ref12.style,
        fill = _ref12.fill;
    return React.createElement("circle", {
      r: r,
      cx: cx,
      cy: cy,
      className: className,
      style: mergeColor(style, fill)
    }, name && React.createElement("title", null, name));
  });
  function computeOverflowValues(value, max, scale) {
    var scaled = [scale(value)];
    for (var i = 0; i < OVERFLOW_PADDING_FACTOR.length && value > max; i++) {
      value -= max;
      scaled.push(scale(value));
    }
    return scaled;
  }
  var CombinationChart =
  /*!#__PURE__*/
  React.memo(function CombinationChart(_ref13) {
    var d = _ref13.d,
        h = _ref13.h,
        className = _ref13.className,
        data = _ref13.data,
        size = _ref13.size,
        style = _ref13.style,
        children = _ref13.children;
    var yValues = computeOverflowValues(d.cardinality, data.cs.max, data.cs.y);
    var genPosition = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
    return React.createElement("g", {
      transform: "translate(".concat(data.cs.x(d), ", 0)"),
      onMouseEnter: h.onMouseEnter(d, size.cs.addons),
      onMouseLeave: h.onMouseLeave,
      onClick: h.onClick(d, size.cs.addons),
      onContextMenu: h.onContextMenu(d, size.cs.addons),
      onMouseMove: h.onMouseMove(d, size.cs.addons),
      className: className,
      "data-cardinality": d.cardinality
    }, style.tooltips && React.createElement("title", null, d.name, ": ", data.cs.format(d.cardinality)), React.createElement("rect", {
      y: -size.cs.before,
      width: data.cs.bandWidth,
      height: size.sets.h + size.cs.h + size.cs.before + size.cs.after,
      className: "hoverBar-".concat(style.id)
    }), size.cs.h > 0 && React.createElement(React.Fragment, null, yValues.map(function (y, i) {
      var offset = i > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;
      return React.createElement("rect", {
        key: i,
        x: offset,
        y: y,
        height: size.cs.h - y,
        width: data.cs.bandWidth - offset * 2,
        className: clsx("fillPrimary-".concat(style.id), i < yValues.length - 1 && "fillOverflow".concat(yValues.length - 1 - i, "-").concat(style.id), style.classNames.bar),
        style: mergeColor(style.styles.bar, d.color)
      });
    }), React.createElement("text", {
      y: yValues[0] - style.barLabelOffset,
      x: data.cs.bandWidth / 2,
      style: style.styles.barLabel,
      className: clsx("cBarTextStyle-".concat(style.id), style.classNames.barLabel)
    }, data.cs.format(d.cardinality))), React.createElement("text", {
      y: -style.barLabelOffset - size.cs.before,
      x: data.cs.bandWidth / 2,
      style: style.styles.barLabel,
      className: clsx("hoverBarTextStyle-".concat(style.id), style.classNames.barLabel)
    }, d.name), data.sets.v.map(function (s, i) {
      if (data.cs.has(d, s)) {
        return null;
      }
      return React.createElement(UpSetDot, {
        key: data.sets.keys[i],
        r: data.r,
        cx: data.cs.cx,
        cy: data.sets.y(s) + data.sets.cy,
        name: style.tooltips ? d.name : '',
        style: style.styles.dot,
        fill: undefined,
        className: clsx("fillNotMember-".concat(style.id), style.classNames.dot)
      });
    }), d.sets.size > 1 && React.createElement("line", {
      x1: data.cs.cx,
      y1: data.sets.y(data.sets.v.find(function (p) {
        return data.cs.has(d, p);
      })) + data.sets.cy - (data.r - 1),
      x2: data.cs.cx,
      y2: data.sets.y(data.sets.rv.find(function (p) {
        return data.cs.has(d, p);
      })) + data.sets.cy + (data.r - 1),
      style: d.color ? {
        stroke: d.color
      } : undefined,
      className: "upsetLine-".concat(data.id)
    }), data.sets.v.map(function (s, i) {
      var _a;
      if (!data.cs.has(d, s)) {
        return null;
      }
      return React.createElement(UpSetDot, {
        key: data.sets.keys[i],
        r: data.r,
        cx: data.cs.cx,
        cy: data.sets.y(s) + data.sets.cy,
        name: style.tooltips ? s.name : '',
        style: style.styles.dot,
        fill: (_a = s.color) !== null && _a !== void 0 ? _a : d.color,
        className: clsx("fillPrimary-".concat(style.id), style.classNames.dot)
      });
    }), size.cs.addons.map(function (addon) {
      return React.createElement("g", {
        key: addon.name,
        transform: "translate(0,".concat(genPosition(addon), ")")
      }, addon.render({
        set: d,
        width: data.cs.bandWidth,
        height: addon.size,
        theme: style.theme
      }));
    }), children);
  });
  var SetChart =
  /*!#__PURE__*/
  React.memo(function SetChart(_ref14) {
    var d = _ref14.d,
        i = _ref14.i,
        h = _ref14.h,
        className = _ref14.className,
        size = _ref14.size,
        data = _ref14.data,
        style = _ref14.style,
        children = _ref14.children;
    var xValues = computeOverflowValues(d.cardinality, data.sets.max, data.sets.x);
    var genPosition = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
    var anchorOffset = style.setLabelAlignment === 'center' ? size.labels.w / 2 : style.setLabelAlignment === 'left' ? 2 : size.labels.w - 2;
    return React.createElement("g", {
      transform: "translate(0, ".concat(data.sets.y(d), ")"),
      onMouseEnter: h.onMouseEnter(d, size.sets.addons),
      onMouseLeave: h.onMouseLeave,
      onClick: h.onClick(d, size.sets.addons),
      onContextMenu: h.onContextMenu(d, size.sets.addons),
      onMouseMove: h.onMouseMove(d, size.sets.addons),
      className: className,
      "data-cardinality": d.cardinality
    }, style.tooltips && React.createElement("title", null, d.name, ": ", data.sets.format(d.cardinality)), React.createElement("rect", {
      x: -size.sets.before,
      width: size.sets.w + size.labels.w + size.cs.w + size.sets.after,
      height: data.sets.bandWidth,
      className: "hoverBar-".concat(style.id)
    }), i % 2 === 1 && React.createElement("rect", {
      x: size.sets.w,
      width: size.labels.w + size.cs.w + size.sets.after,
      height: data.sets.bandWidth,
      className: "fillAlternating-".concat(style.id)
    }), size.sets.w > 0 && React.createElement(React.Fragment, null, xValues.map(function (x, i) {
      var offset = i > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;
      return React.createElement("rect", {
        key: i,
        x: x,
        y: offset,
        width: size.sets.w - x,
        height: data.sets.bandWidth - offset * 2,
        className: clsx("fillPrimary-".concat(style.id), i < xValues.length - 1 && "fillOverflow".concat(xValues.length - 1 - i, "-").concat(style.id), style.classNames.bar),
        style: mergeColor(style.styles.bar, d.color)
      });
    }), React.createElement("text", {
      x: xValues[0],
      dx: -style.barLabelOffset,
      y: data.sets.bandWidth / 2,
      style: style.styles.barLabel,
      className: clsx("sBarTextStyle-".concat(style.id), style.classNames.barLabel)
    }, data.sets.format(d.cardinality))), React.createElement("text", {
      x: size.sets.w + anchorOffset,
      y: data.sets.bandWidth / 2,
      className: clsx("setTextStyle-".concat(style.id), style.classNames.setLabel),
      style: style.styles.setLabel,
      clipPath: "url(#clip-".concat(size.id, ")")
    }, d.name), size.sets.addons.map(function (addon) {
      return React.createElement("g", {
        key: addon.name,
        transform: "translate(".concat(genPosition(addon), ",0)")
      }, addon.render({
        set: d,
        width: addon.size,
        height: data.sets.bandWidth,
        theme: style.theme
      }));
    }), children);
  });
  var UpSetChart =
  /*!#__PURE__*/
  React.memo(function UpSetChart(_ref15) {
    var data = _ref15.data,
        size = _ref15.size,
        style = _ref15.style,
        h = _ref15.h,
        setChildrenFactory = _ref15.setChildrenFactory,
        combinationChildrenFactory = _ref15.combinationChildrenFactory;
    return React.createElement("g", {
      className: h.hasClick ? "clickAble-".concat(style.id) : undefined
    }, React.createElement("g", {
      transform: "translate(".concat(size.sets.x, ",").concat(size.sets.y, ")"),
      "data-upset": "sets"
    }, data.sets.v.map(function (d, i) {
      return React.createElement(SetChart, {
        key: data.sets.keys[i],
        d: d,
        i: i,
        h: h,
        className: h.hasClick || h.hasHover ? "interactive-".concat(style.id) : undefined,
        data: data,
        style: style,
        size: size
      }, setChildrenFactory && setChildrenFactory(d));
    })), React.createElement("g", {
      transform: "translate(".concat(size.cs.x, ",").concat(size.cs.y, ")"),
      "data-upset": "cs"
    }, data.cs.v.map(function (d, i) {
      return React.createElement(CombinationChart, {
        key: data.cs.keys[i],
        d: d,
        h: h,
        className: h.hasClick || h.hasHover ? "interactive-".concat(style.id) : undefined,
        data: data,
        style: style,
        size: size
      }, combinationChildrenFactory && combinationChildrenFactory(d));
    })));
  });
  function CombinationSelectionChart(_ref16) {
    var data = _ref16.data,
        size = _ref16.size,
        style = _ref16.style,
        elemOverlap = _ref16.elemOverlap,
        secondary = _ref16.secondary,
        tooltip = _ref16.tooltip,
        suffix = _ref16.suffix,
        transform = _ref16.transform,
        empty = _ref16.empty,
        combinationAddons = _ref16.combinationAddons;
    var width = data.cs.bandWidth;
    var totalHeight = size.cs.h + size.sets.h;
    var height = size.cs.h;
    var className = clsx("fill".concat(suffix), !tooltip && "pnone-".concat(style.id), style.classNames.bar);
    return React.createElement("g", {
      transform: transform,
      "data-upset": secondary ? 'cs-q' : 'cs-s'
    }, data.cs.v.map(function (d, i) {
      var x = data.cs.x(d);
      var key = data.cs.keys[i];
      if (empty && !secondary) {
        return React.createElement("rect", {
          key: key,
          x: x,
          y: height,
          height: 0,
          width: width,
          className: className,
          style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
        }, tooltip && React.createElement("title", null));
      }
      var o = elemOverlap(d);
      if (o === 0) {
        return null;
      }
      var yValues = computeOverflowValues(o, data.cs.max, data.cs.y);
      var title = tooltip && React.createElement("title", null, "".concat(d.name, " \u2229 ").concat(tooltip, ": ").concat(o));
      var content = secondary ? React.createElement("path", {
        key: key,
        transform: "translate(".concat(x, ", ").concat(yValues[0], ")"),
        d: "M0,-1 l".concat(width, ",0 l0,2 l").concat(-width, ",0 L-").concat(data.triangleSize, ",-").concat(data.triangleSize, " L-").concat(data.triangleSize, ",").concat(data.triangleSize, " Z"),
        className: className,
        "data-i": i,
        "data-cardinality": o,
        style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
      }, title) : yValues.map(function (y, j) {
        var offset = j > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;
        return React.createElement("rect", {
          key: j,
          x: x + offset,
          y: y,
          height: height - y,
          width: width - offset * 2,
          "data-i": j > 0 ? null : i,
          "data-cardinality": j > 0 ? null : o,
          className: clsx(className, j < yValues.length - 1 && "fillOverflow".concat(yValues.length - 1 - j, "-").concat(style.id)),
          style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
        }, title);
      });
      var genPosition = addonPositionGenerator(totalHeight, size.cs.addonPadding);
      var addons = combinationAddons.map(function (addon) {
        var v = genPosition(addon);
        var content = addon.render({
          set: d,
          width: width,
          height: addon.size,
          theme: style.theme
        });
        if (!content) {
          return null;
        }
        return React.createElement("g", {
          key: addon.name,
          transform: "translate(".concat(x, ",").concat(v, ")")
        }, content);
      }).filter(Boolean);
      if (addons.length === 0) {
        return content;
      }
      return React.createElement("g", {
        key: key
      }, content, addons);
    }));
  }
  function SetSelectionChart(_ref17) {
    var data = _ref17.data,
        size = _ref17.size,
        style = _ref17.style,
        elemOverlap = _ref17.elemOverlap,
        suffix = _ref17.suffix,
        secondary = _ref17.secondary,
        empty = _ref17.empty,
        tooltip = _ref17.tooltip,
        setAddons = _ref17.setAddons,
        transform = _ref17.transform;
    var width = size.sets.w;
    var totalWidth = size.sets.w + size.labels.w + size.cs.w;
    var height = data.sets.bandWidth;
    var className = clsx("fill".concat(suffix), !tooltip && " pnone-".concat(style.id), style.classNames.bar);
    return React.createElement("g", {
      transform: transform,
      "data-upset": secondary ? 'sets-q' : 'sets-s'
    }, data.sets.v.map(function (d, i) {
      var y = data.sets.y(d);
      var key = data.sets.keys[i];
      if (empty && !secondary) {
        return React.createElement("rect", {
          key: key,
          x: width,
          y: y,
          width: 0,
          height: height,
          className: className,
          style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
        }, style.tooltips && tooltip && React.createElement("title", null));
      }
      var o = elemOverlap(d);
      if (o === 0) {
        return null;
      }
      var xValues = computeOverflowValues(o, data.sets.max, data.sets.x);
      var title = style.tooltips && tooltip && React.createElement("title", null, "".concat(d.name, " \u2229 ").concat(tooltip, ": ").concat(o));
      var content = secondary ? React.createElement("path", {
        key: key,
        transform: "translate(".concat(xValues[0], ", ").concat(y + height, ")"),
        d: "M1,0 l0,".concat(-height, " l-2,0 l0,").concat(height, " L-").concat(data.triangleSize, ",").concat(data.triangleSize, " L").concat(data.triangleSize, ",").concat(data.triangleSize, " Z"),
        "data-i": i,
        "data-cardinality": o,
        className: className,
        style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
      }, title) : xValues.map(function (x, j) {
        var offset = j > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;
        return React.createElement("rect", {
          key: j,
          "data-i": j > 0 ? null : i,
          "data-cardinality": j > 0 ? null : o,
          x: x,
          y: y + offset,
          width: width - x,
          height: height - offset * 2,
          className: clsx(className, j < xValues.length - 1 && "fillOverflow".concat(xValues.length - 1 - j, "-").concat(style.id)),
          style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
        }, title);
      });
      var genPosition = addonPositionGenerator(totalWidth, size.sets.addonPadding);
      var addons = setAddons.map(function (addon) {
        var v = genPosition(addon);
        var content = addon.render({
          set: d,
          width: addon.size,
          height: height,
          theme: style.theme
        });
        if (!content) {
          return null;
        }
        return React.createElement("g", {
          key: addon.name,
          transform: "translate(".concat(v, ",").concat(y, ")")
        }, content);
      }).filter(Boolean);
      if (addons.length === 0) {
        return content;
      }
      return React.createElement("g", {
        key: key
      }, content, addons);
    }));
  }
  var EMPTY_ARRAY$1 = [];
  var UpSetQueries =
  /*!#__PURE__*/
  React.memo(function UpSetQueries(_ref18) {
    var size = _ref18.size,
        data = _ref18.data,
        style = _ref18.style,
        hasHover = _ref18.hasHover,
        secondary = _ref18.secondary,
        queries = _ref18.queries;
    var someAddon = size.sets.addons.some(function (s) {
      return s.renderQuery != null;
    }) || size.cs.addons.some(function (s) {
      return s.renderQuery != null;
    });
    var qs = d(function () {
      return queries.map(function (q) {
        return Object.assign(Object.assign({}, q), {
          overlap: queryOverlap(q, 'intersection', data.toElemKey),
          elemOverlap: someAddon ? queryElemOverlap(q, 'intersection', data.toElemKey) : null
        });
      });
    }, [queries, someAddon, data.toElemKey]);
    function wrapAddon(addon, query, index, overlapper, secondary) {
      return Object.assign(Object.assign({}, addon), {
        render: function render(props) {
          var overlap = overlapper(props.set);
          return addon.renderQuery ? addon.renderQuery(Object.assign({
            query: query,
            overlap: overlap,
            index: index,
            secondary: secondary
          }, props)) : null;
        }
      });
    }
    return React.createElement("g", {
      className: hasHover && !secondary ? "pnone-".concat(style.id) : undefined
    }, React.createElement("g", {
      transform: "translate(".concat(size.sets.x, ",").concat(size.sets.y, ")")
    }, qs.map(function (q, i) {
      return React.createElement(SetSelectionChart, {
        key: q.name,
        data: data,
        size: size,
        style: style,
        elemOverlap: q.overlap,
        suffix: "Q".concat(i, "-").concat(data.id),
        secondary: secondary || i > 0,
        tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name,
        setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY$1 : size.sets.addons.map(function (a, i) {
          return wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0);
        })
      });
    })), React.createElement("g", {
      transform: "translate(".concat(size.cs.x, ",").concat(size.cs.y, ")")
    }, qs.map(function (q, i) {
      return React.createElement(CombinationSelectionChart, {
        key: q.name,
        data: data,
        size: size,
        style: style,
        elemOverlap: q.overlap,
        suffix: "Q".concat(i, "-").concat(data.id),
        secondary: secondary || i > 0,
        tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name,
        combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY$1 : size.cs.addons.map(function (a, i) {
          return wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0);
        })
      });
    })));
  });
  function LabelsSelection(_ref19) {
    var data = _ref19.data,
        size = _ref19.size,
        style = _ref19.style,
        selection = _ref19.selection;
    if (!selection || selection.type !== 'set' || !data.sets.keys.includes(data.toKey(selection))) {
      return null;
    }
    var d = selection;
    return React.createElement("rect", {
      y: data.sets.y(d),
      width: size.labels.w + size.cs.w + size.sets.after,
      height: data.sets.bandWidth,
      className: "selectionHint-".concat(style.id)
    });
  }
  function UpSetSelectionChart(_ref20) {
    var data = _ref20.data,
        size = _ref20.size,
        style = _ref20.style,
        selection = _ref20.selection;
    var cy = data.sets.bandWidth / 2;
    var cx = data.cs.cx;
    var r = data.r;
    var height = size.sets.h + size.sets.after;
    var width = data.cs.bandWidth;
    if (!selection || selection.type === 'set' || !data.cs) {
      return null;
    }
    var d = selection;
    var index = data.cs.keys.indexOf(data.toKey(d));
    if (index < 0) {
      return null;
    }
    return React.createElement("g", {
      transform: "translate(".concat(size.labels.w + data.cs.x(d), ", 0)"),
      "data-upset": "cs-ss",
      "data-i": index
    }, React.createElement("rect", {
      width: width,
      height: height,
      className: "selectionHint-".concat(style.id)
    }), d.sets.size > 1 && React.createElement("line", {
      x1: cx,
      y1: data.sets.y(data.sets.v.find(function (p) {
        return data.cs.has(d, p);
      })) + cy - (data.r - 1),
      x2: cx,
      y2: data.sets.y(data.sets.rv.find(function (p) {
        return data.cs.has(d, p);
      })) + cy + (data.r - 1),
      className: "upsetSelectionLine-".concat(data.id),
      style: mergeColor(undefined, !style.selectionColor ? d.color : undefined, 'stroke')
    }), data.sets.v.filter(function (s) {
      return data.cs.has(d, s);
    }).map(function (s) {
      return React.createElement(UpSetDot, {
        key: data.toKey(s),
        r: r * 1.1,
        cx: cx,
        cy: data.sets.y(s) + cy,
        name: style.tooltips ? s.name : '',
        className: clsx("fillSelection-".concat(style.id), "pnone-".concat(style.id), style.classNames.dot),
        style: mergeColor(style.styles.dot, !style.selectionColor ? s.color : undefined)
      });
    }));
  }
  var EMPTY_ARRAY = [];
  function UpSetSelection(_ref21) {
    var size = _ref21.size,
        data = _ref21.data,
        style = _ref21.style,
        selection = _ref21.selection,
        hasHover = _ref21.hasHover;
    var empty = style.emptySelection;
    var selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);
    var selectionName = generateSelectionName(selection);
    var someAddon = size.sets.addons.some(function (s) {
      return s.renderSelection != null;
    }) || size.cs.addons.some(function (s) {
      return s.renderSelection != null;
    });
    var selectionElemOverlap = selection && typeof selection !== 'function' && someAddon ? elemElemOverlapOf(Array.isArray(selection) ? selection : selection.elems, data.toElemKey) : null;
    function wrapAddon(addon) {
      return Object.assign(Object.assign({}, addon), {
        render: function render(props) {
          var overlap = selectionElemOverlap ? selectionElemOverlap(props.set) : null;
          return addon.renderSelection ? addon.renderSelection(Object.assign({
            selection: selection,
            selectionColor: style.selectionColor || props.set.color || 'orange',
            overlap: overlap
          }, props)) : null;
        }
      });
    }
    return React.createElement("g", {
      className: hasHover ? "pnone-".concat(style.id) : undefined
    }, (selection || empty) && React.createElement(CombinationSelectionChart, {
      data: data,
      size: size,
      style: style,
      transform: "translate(".concat(size.cs.x, ",").concat(size.cs.y, ")"),
      empty: empty && !selection,
      elemOverlap: selectionOverlap,
      suffix: "Selection-".concat(style.id),
      tooltip: hasHover ? undefined : selectionName,
      combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY : size.cs.addons.map(wrapAddon)
    }), (selection || empty) && React.createElement(SetSelectionChart, {
      data: data,
      size: size,
      style: style,
      transform: "translate(".concat(size.sets.x, ",").concat(size.sets.y, ")"),
      empty: empty && !selection,
      elemOverlap: selectionOverlap,
      suffix: "Selection-".concat(style.id),
      tooltip: hasHover ? undefined : selectionName,
      setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY : size.sets.addons.map(wrapAddon)
    }), React.createElement("g", {
      transform: "translate(".concat(size.labels.x, ",").concat(size.labels.y, ")")
    }, isSetLike(selection) && React.createElement(LabelsSelection, {
      data: data,
      size: size,
      style: style,
      selection: selection
    }), isSetLike(selection) && React.createElement(UpSetSelectionChart, {
      data: data,
      size: size,
      style: style,
      selection: selection
    })));
  }
  function propRule(value) {
    var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'font-size';
    return value ? "".concat(prop, ": ").concat(value, ";") : '';
  }
  function baseRules(styleId, theme, fontFamily, fontSizes) {
    var hasS = [];
    if (theme.hasSelectionColor) {
      hasS.push("fill: ".concat(theme.hasSelectionColor, ";"));
    }
    var hasSelectionOpacity = theme.hasSelectionOpacity != null && theme.hasSelectionOpacity >= 0;
    if (hasSelectionOpacity) {
      hasS.push("fill-opacity: ".concat(theme.hasSelectionOpacity, ";"));
    }
    return {
      p: propRule,
      root: "\n  .root-".concat(styleId, " {\n    ").concat(propRule(fontFamily, 'font-family'), "\n  }\n  "),
      text: "\n  .titleTextStyle-".concat(styleId, " {\n    fill: ").concat(theme.textColor, ";\n    ").concat(propRule(fontSizes.title), "\n  }\n  .descTextStyle-").concat(styleId, " {\n    fill: ").concat(theme.textColor, ";\n    ").concat(propRule(fontSizes.description), "\n  }\n\n  .legendTextStyle-").concat(styleId, " {\n    fill: ").concat(theme.textColor, ";\n    ").concat(propRule(fontSizes.legend), "\n    text-anchor: middle;\n    dominant-baseline: hanging;\n    pointer-events: none;\n  }\n  "),
      hasSFill: hasS.join(' '),
      hasSStroke: hasS.join(' ').replace('fill:', 'stroke:').replace('fill-', 'stroke-'),
      fill: "\n  .fillPrimary-".concat(styleId, " { fill: ").concat(theme.color, "; fill-opacity: ").concat(theme.opacity, "; }\n  .fillOverflow1-").concat(styleId, " { fill-opacity: ").concat(theme.opacity * OVERFLOW_OPACITY_FACTOR[0], "; }\n  .fillOverflow2-").concat(styleId, " { fill-opacity: ").concat(theme.opacity * OVERFLOW_OPACITY_FACTOR[1], "; }\n  ").concat(hasS.length > 0 ? ".root-".concat(styleId, "[data-selection] .fillPrimary-").concat(styleId, " { ").concat(hasS.join(' '), " }") : '', "\n  ").concat(hasSelectionOpacity ? "\n      .root-".concat(styleId, "[data-selection] .fillOverflow1-").concat(styleId, " { fill-opacity: ").concat(theme.opacity * OVERFLOW_OPACITY_FACTOR[0], "; }\n      .root-").concat(styleId, "[data-selection] .fillOverflow2-").concat(styleId, " { fill-opacity: ").concat(theme.opacity * OVERFLOW_OPACITY_FACTOR[1], "; }") : '', "\n  ").concat(theme.selectionColor ? ".fillSelection-".concat(styleId, " { fill: ").concat(theme.selectionColor, "; }") : '', "\n  .fillTransparent-").concat(styleId, " { fill: transparent; }\n\n  .selectionHint-").concat(styleId, " {\n    fill: transparent;\n    pointer-events: none;\n    ").concat(propRule(theme.selectionColor, 'stroke'), "\n  }\n  .clickAble-").concat(styleId, " {\n    cursor: pointer;\n  }\n\n  .startText-").concat(styleId, " {\n    text-anchor: start;\n  }\n  .endText-").concat(styleId, " {\n    text-anchor: end;\n  }\n  .pnone-").concat(styleId, " {\n    pointer-events: none;\n  }"),
      "export": "\n  .exportTextStyle-".concat(styleId, " {\n    fill: ").concat(theme.textColor, ";\n    ").concat(propRule(fontSizes.exportLabel), "\n  }\n  .exportButtons-").concat(styleId, " {\n    text-anchor: middle;\n  }\n  .exportButton-").concat(styleId, " {\n    cursor: pointer;\n    opacity: 0.5;\n  }\n  .exportButton-").concat(styleId, ":hover {\n    opacity: 1;\n  }\n  .exportButton-").concat(styleId, " > rect {\n    fill: none;\n    stroke: ").concat(theme.textColor, ";\n  }\n  ")
    };
  }
  function useHandler(p) {
    var onClick = p.onClick;
    return d(function () {
      return {
        hasClick: onClick != null,
        hasHover: p.onHover != null,
        onClick: wrap(onClick),
        onMouseEnter: wrap(p.onHover),
        onContextMenu: wrap(p.onContextMenu),
        onMouseLeave: p.onHover ? function (evt) {
          return p.onHover(null, evt.nativeEvent, []);
        } : undefined,
        onMouseMove: wrap(p.onMouseMove),
        reset: function reset(evt) {
          return onClick ? onClick(null, evt.nativeEvent, []) : null;
        }
      };
    }, [onClick, p.onHover, p.onContextMenu, p.onMouseMove]);
  }
  var UpSetJS =
  /*!#__PURE__*/
  React.forwardRef(function UpSetJS(props, ref) {
    var _a;
    var p = fillDefaults$1(props);
    var _p$selection = p.selection,
        selection = _p$selection === void 0 ? null : _p$selection,
        _p$queries = p.queries,
        queries = _p$queries === void 0 ? [] : _p$queries,
        fontSizes = p.fontSizes;
    var styleId = d(function () {
      return p.id ? p.id : generateId([p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.chartLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.hoverHintColor, p.color, p.hasSelectionColor, p.selectionColor, p.notMemberColor, p.alternatingBackgroundColor, p.opacity, p.hasSelectionOpacity]);
    }, [p.id, p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.chartLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.hoverHintColor, p.color, p.hasSelectionColor, p.selectionColor, p.notMemberColor, p.alternatingBackgroundColor, p.opacity, p.hasSelectionOpacity]);
    var styleInfo = d(function () {
      return deriveStyleDependent$1(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips, p.setLabelAlignment);
    }, [p.theme, p.styles, p.classNames, p.barLabelOffset, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips, p.setLabelAlignment]);
    var sizeInfo = d(function () {
      return deriveSizeDependent(p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding);
    }, [p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding]);
    var dataInfo = d(function () {
      return deriveDataDependent(p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.dotPadding, p.barPadding, parseFontSize(fontSizes.axisTick), p.combinationAddons, p.toKey, p.toElemKey, p.id, p.setMaxScale, p.combinationMaxScale);
    }, [p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset, fontSizes.barLabel, p.dotPadding, p.barPadding, fontSizes.axisTick, p.combinationAddons, p.toKey, p.toElemKey, p.id, p.setMaxScale, p.combinationMaxScale]);
    var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    var h = useHandler(p);
    var rules = "\n  ".concat(rulesHelper.root, "\n  ").concat(rulesHelper.text, "\n\n  .axisTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.axisTick), "\n    text-anchor: middle;\n  }\n  .barTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.barLabel), "\n  }\n  .cBarTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.barLabel), "\n    text-anchor: middle;\n  }\n  .sBarTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.barLabel), "\n    text-anchor: end;\n    dominant-baseline: central;\n  }\n  .hoverBarTextStyle-").concat(styleId, " {\n    ").concat(rulesHelper.p(fontSizes.barLabel), "\n    fill: ").concat(p.hoverHintColor, ";\n    display: none;\n    text-anchor: middle;\n  }\n  .setTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.setLabel), "\n    text-anchor: ").concat(toAnchor(p.setLabelAlignment), ";\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.chartLabel), "\n    text-anchor: middle;\n  }\n  .sChartTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.chartLabel), "\n    text-anchor: middle;\n    dominant-baseline: hanging;\n  }\n\n  ").concat(rulesHelper.fill, "\n  .fillNotMember-").concat(styleId, " { fill: ").concat(p.notMemberColor, "; }\n  .fillAlternating-").concat(styleId, " { fill: ").concat(p.alternatingBackgroundColor || 'transparent', "; }\n\n  .axisLine-").concat(styleId, " {\n    fill: none;\n    stroke: ").concat(p.textColor, ";\n  }\n  .hoverBar-").concat(styleId, " {\n    fill: transparent;\n  }\n\n  .interactive-").concat(styleId, ":hover > .hoverBar-").concat(styleId, " {\n    stroke: ").concat(p.hoverHintColor, ";\n  }\n  .interactive-").concat(styleId, ":hover > .hoverBarTextStyle-").concat(styleId, " {\n    display: unset;\n  }\n\n  ").concat(rulesHelper["export"], "\n\n  .upsetLine-").concat(dataInfo.id, " {\n    stroke-width: ").concat(dataInfo.r * 0.6, ";\n    stroke: ").concat(p.color, ";\n    stroke-opacity: ").concat(p.opacity, ";\n  }\n  ").concat(rulesHelper.hasSStroke ? ".root-".concat(styleId, "[data-selection] .upsetLine-").concat(dataInfo.id, " { ").concat(rulesHelper.hasSStroke, " }") : '', "\n\n  .upsetSelectionLine-").concat(dataInfo.id, " {\n    stroke-width: ").concat(dataInfo.r * 0.6 * 1.1, ";\n    ").concat(rulesHelper.p(p.selectionColor, 'stroke'), "\n    pointer-events: none;\n  }\n\n  ").concat(queries.map(function (q, i) {
      return ".fillQ".concat(i, "-").concat(dataInfo.id, " {\n    fill: ").concat(q.color, ";\n  }");
    }).join('\n'), "\n  ");
    var exportChart = A$1(function (evt) {
      var svg = evt.currentTarget.closest('svg');
      var type = evt.currentTarget.dataset.type || 'png';
      switch (type) {
        case 'vega':
          exportVegaLite(svg);
          break;
        case 'dump':
          exportDump(svg, props, dataInfo);
          break;
        case 'share':
          exportSharedLink(props, dataInfo);
          break;
        case 'svg':
        case 'png':
          exportSVG$1(svg, {
            type: type,
            toRemove: ".".concat(evt.currentTarget.getAttribute('class'))
          });
      }
    }, [dataInfo, props]);
    var selectionName = generateSelectionName(selection);
    return React.createElement("svg", {
      id: p.id,
      className: clsx("root-".concat(styleId), p.className),
      style: p.style,
      width: p.width,
      height: p.height,
      ref: ref,
      viewBox: "0 0 ".concat(p.width, " ").concat(p.height),
      "data-theme": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light',
      "data-selection": selectionName ? selectionName : undefined
    }, p.styleFactory(rules), React.createElement("defs", null, React.createElement("clipPath", {
      id: "clip-".concat(sizeInfo.id)
    }, React.createElement("rect", {
      x: sizeInfo.sets.w,
      y: 0,
      width: sizeInfo.labels.w,
      height: sizeInfo.sets.h
    }))), p.queryLegend && React.createElement(QueryLegend, {
      queries: queries,
      x: sizeInfo.legend.x,
      style: styleInfo,
      data: dataInfo
    }), React.createElement(ExportButtons, {
      transform: "translate(".concat(sizeInfo.w - 2, ",").concat(sizeInfo.h - 3, ")"),
      styleId: styleId,
      exportButtons: p.exportButtons,
      exportChart: exportChart
    }), React.createElement("g", {
      transform: "translate(".concat(p.padding, ",").concat(p.padding, ")"),
      "data-upset": "base"
    }, p.onClick && React.createElement("rect", {
      width: sizeInfo.cs.x,
      height: sizeInfo.sets.y,
      onClick: h.reset,
      className: "fillTransparent-".concat(styleId)
    }), React.createElement(UpSetAxis, {
      size: sizeInfo,
      style: styleInfo,
      data: dataInfo
    }), React.createElement(UpSetChart, {
      size: sizeInfo,
      style: styleInfo,
      data: dataInfo,
      h: h,
      setChildrenFactory: p.setChildrenFactory,
      combinationChildrenFactory: p.combinationChildrenFactory
    }), React.createElement(UpSetSelection, {
      size: sizeInfo,
      style: styleInfo,
      data: dataInfo,
      hasHover: h.hasHover,
      selection: selection
    }), React.createElement(UpSetQueries, {
      size: sizeInfo,
      style: styleInfo,
      data: dataInfo,
      hasHover: h.hasHover,
      queries: queries,
      secondary: p.onHover != null || selection != null
    })), props.children);
  });
  function SVGWrapper(_ref22) {
    var rules = _ref22.rules,
        style = _ref22.style,
        size = _ref22.size,
        p = _ref22.p,
        data = _ref22.data,
        tRef = _ref22.tRef,
        children = _ref22.children,
        exportChart = _ref22.exportChart,
        selectionName = _ref22.selectionName,
        h = _ref22.h;
    var _a, _b;
    return React.createElement("svg", {
      id: p.id,
      className: clsx("root-".concat(style.id), p.className),
      style: p.style,
      width: p.width,
      height: p.height,
      ref: tRef,
      viewBox: "0 0 ".concat(p.width, " ").concat(p.height),
      "data-theme": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light',
      "data-selection": selectionName ? selectionName : undefined
    }, p.styleFactory(rules), p.onClick && React.createElement("rect", {
      width: size.w,
      height: size.h,
      onClick: h.reset,
      className: "fillTransparent-".concat(style.id)
    }), p.queryLegend && React.createElement(QueryLegend, {
      queries: (_b = p.queries) !== null && _b !== void 0 ? _b : [],
      x: size.legend.x,
      style: style,
      data: data
    }), React.createElement(ExportButtons, {
      transform: "translate(".concat(size.w - 2, ",").concat(size.h - 3, ")"),
      styleId: style.id,
      exportButtons: p.exportButtons,
      exportChart: exportChart
    }), React.createElement("g", {
      transform: "translate(".concat(p.padding, ",").concat(p.padding, ")"),
      "data-upset": "base"
    }, children), p.children);
  }
  function generateArcSlicePath(s, refs) {
    var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    if (s.path) {
      return s.path;
    }
    return "M ".concat(s.x1 - p, ",").concat(s.y1 - p, " ").concat(s.arcs.map(function (arc) {
      var ref = refs[arc.ref].l;
      var rx = isEllipse(ref) ? ref.rx : ref.r;
      var ry = isEllipse(ref) ? ref.ry : ref.r;
      var rot = isEllipse(ref) ? ref.rotation : 0;
      return "A ".concat(rx - p, " ").concat(ry - p, " ").concat(rot, " ").concat(arc.large ? 1 : 0, " ").concat(arc.sweep ? 1 : 0, " ").concat(arc.x2 - p, " ").concat(arc.y2 - p);
    }).join(' '));
  }
  function SelectionPattern(p) {
    var _a;
    if (p.v >= 1 || p.v <= 0) {
      return null;
    }
    var ratio = Math.round(p.v * 10.0) / 100;
    return React.createElement("defs", null, React.createElement("pattern", {
      id: p.id,
      width: "1",
      height: "0.1",
      patternContentUnits: "objectBoundingBox",
      patternTransform: "rotate(".concat((_a = p.rotate) !== null && _a !== void 0 ? _a : 0, ")")
    }, p.bgFilled && React.createElement("rect", {
      x: "0",
      y: "0",
      width: "1",
      height: "0.1",
      style: {
        fill: p.bgFill
      },
      className: "fillPrimary-".concat(p.styleId)
    }), React.createElement("rect", {
      x: "0",
      y: "0",
      width: "1",
      height: ratio,
      className: "fill".concat(p.suffix),
      style: p.fill ? {
        fill: p.fill
      } : undefined
    })));
  }
  function sliceRotate(slice, center) {
    if (slice.text.x === center.cx) {
      return 0;
    }
    if (slice.text.x > center.cx) {
      return slice.text.y <= center.cy ? 60 : -60;
    }
    return slice.text.y <= center.cy ? -60 : 60;
  }
  function generateTitle(d, s, sName, secondary, qs, queries, data, cx) {
    var dc = data.format(d.cardinality);
    var baseName = !sName ? d.name : "".concat(d.name, " \u2229 ").concat(sName);
    var baseCardinality = !sName ? dc : "".concat(data.format(s), "/").concat(dc);
    if (qs.length === 0) {
      return {
        tooltip: "".concat(baseName, ": ").concat(baseCardinality),
        title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
          dy: "-0.6em"
        }, d.name), React.createElement("tspan", {
          x: cx,
          dy: "1.2em"
        }, baseCardinality)) : baseCardinality
      };
    }
    if (qs.length === 1 && !secondary && !sName) {
      return {
        tooltip: "".concat(d.name, " \u2229 ").concat(queries[0].name, ": ").concat(data.format(qs[0]), "/").concat(dc),
        title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
          dy: "-0.6em"
        }, d.name), React.createElement("tspan", {
          x: cx,
          dy: "1.2em"
        }, "".concat(data.format(qs[0]), "/").concat(dc))) : "".concat(data.format(qs[0]), "/").concat(dc)
      };
    }
    var queryLine = React.createElement("tspan", {
      x: cx,
      dy: "1.2em"
    }, queries.map(function (q, i) {
      return React.createElement(React.Fragment, {
        key: q.name
      }, React.createElement("tspan", {
        className: "fillQ".concat(i, "-").concat(data.id)
      }, '⬤'), React.createElement("tspan", null, " ".concat(data.format(qs[i]), "/").concat(dc).concat(i < queries.length - 1 ? ' ' : '')));
    }));
    return {
      tooltip: "".concat(baseName, ": ").concat(baseCardinality, "\n").concat(queries.map(function (q, i) {
        return "".concat(d.name, " \u2229 ").concat(q.name, ": ").concat(data.format(qs[i]), "/").concat(dc);
      }).join('\n')),
      title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
        dy: "-1.2em"
      }, d.name), React.createElement("tspan", {
        x: cx,
        dy: "1.2em"
      }, baseCardinality), queryLine) : React.createElement(React.Fragment, null, React.createElement("tspan", {
        dy: "-0.6em"
      }, baseCardinality), queryLine)
    };
  }
  function VennArcSliceSelection(_ref23) {
    var slice = _ref23.slice,
        d = _ref23.d,
        i = _ref23.i,
        data = _ref23.data,
        style = _ref23.style,
        elemOverlap = _ref23.elemOverlap,
        selected = _ref23.selected,
        selectionName = _ref23.selectionName,
        h = _ref23.h,
        queries = _ref23.queries,
        size = _ref23.size,
        fill = _ref23.fill,
        qs = _ref23.qs;
    var p = generateArcSlicePath(slice, data.sets.d);
    var rotate = sliceRotate(slice, size.area);
    var o = elemOverlap ? elemOverlap(d) : 0;
    var fillFullSelection = o === d.cardinality && d.cardinality > 0 || selected;
    var className = clsx("arc-".concat(style.id), o === 0 && !selected && "".concat(fill ? 'fillPrimary' : 'arcP', "-").concat(style.id), fillFullSelection && "fillSelection-".concat(style.id), style.classNames.set);
    var id = "upset-".concat(style.id, "-").concat(i);
    var secondary = elemOverlap != null || h.onMouseLeave != null;
    var qsOverlaps = qs.map(function (q) {
      return q(d);
    });
    var _generateTitle = generateTitle(d, o, selectionName, secondary, qsOverlaps, queries, data, slice.text.x),
        title = _generateTitle.title,
        tooltip = _generateTitle.tooltip;
    return React.createElement("g", null, React.createElement(SelectionPattern, {
      id: id,
      v: o === 0 ? 0 : o / d.cardinality,
      suffix: "Selection-".concat(style.id),
      rotate: rotate,
      bgFill: d.color,
      bgFilled: d.color != null || fill,
      fill: !style.selectionColor ? d.color : undefined,
      styleId: style.id
    }), React.createElement("path", {
      onMouseEnter: h.onMouseEnter(d, []),
      onMouseLeave: h.onMouseLeave,
      onClick: h.onClick(d, []),
      onContextMenu: h.onContextMenu(d, []),
      onMouseMove: h.onMouseMove(d, []),
      d: p,
      className: className,
      style: mergeColor(style.styles.set, o > 0 && o < d.cardinality ? "url(#".concat(id, ")") : !fillFullSelection || !style.selectionColor ? d.color : undefined)
    }, style.tooltips && React.createElement("title", null, tooltip)), React.createElement("text", {
      x: slice.text.x,
      y: slice.text.y,
      className: clsx("".concat(d.type === 'set' ? 'set' : 'value', "TextStyle-").concat(style.id), "pnone-".concat(style.id), d.type === 'set' ? style.classNames.setLabel : style.classNames.valueLabel
      )
    }, title));
  }
  function deriveVennDataDependent(sets, combinations, size, layout, format, toKey, toElemKey, id, setLabelOffsets) {
    var ss = sets.length > layout.maxSets ? sets.slice(0, layout.maxSets) : sets;
    var _calculateCombination = calculateCombinations(ss, toKey, combinations),
        cs = _calculateCombination.cs,
        setKeys = _calculateCombination.setKeys,
        csKeys = _calculateCombination.csKeys;
    var l = layout.compute(ss, cs, size.area.w, size.area.h);
    return {
      id: id ? id : generateId(),
      sets: {
        d: l.sets.map(function (l, i) {
          return {
            v: ss[i],
            l: l,
            key: setKeys[i],
            offset: setLabelOffsets != null && i < setLabelOffsets.length ? setLabelOffsets[i] : {
              x: 0,
              y: 0
            }
          };
        }),
        v: ss,
        format: format
      },
      format: format,
      cs: {
        d: l.intersections.map(function (l, i) {
          return {
            v: cs[i],
            l: l,
            key: csKeys[i]
          };
        }),
        v: cs,
        has: function has(v, s) {
          var sk = toKey(s);
          return Array.from(v.sets).some(function (ss) {
            return toKey(ss) === sk;
          });
        }
      },
      toKey: toKey,
      toElemKey: toElemKey,
      overlapGuesser: generateDistinctOverlapFunction(cs, noGuessPossible, toKey)
    };
  }
  function calculateCombinations(ss, toKey, combinations) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      min: 1
    };
    var setKeys = ss.map(toKey);
    var cs = [];
    if (areCombinations(combinations)) {
      var given = new Map(combinations.map(function (c) {
        return [Array.from(c.sets).map(toKey).sort().join('#'), c];
      }));
      var helperSets = ss.map(function (s) {
        return {
          type: 'set',
          cardinality: 0,
          elems: [],
          name: s.name,
          s: s
        };
      });
      cs = generateCombinations(helperSets, Object.assign({
        type: 'distinctIntersection',
        empty: true,
        order: ['degree:asc', 'group:asc']
      }, options)).map(function (c) {
        var key = Array.from(c.sets).map(function (s) {
          return toKey(s.s);
        }).sort().join('#');
        if (given.has(key)) {
          return given.get(key);
        }
        return {
          name: c.name,
          cardinality: 0,
          degree: c.degree,
          elems: [],
          sets: new Set(Array.from(c.sets).map(function (s) {
            return s.s;
          })),
          type: 'distinctIntersection'
        };
      });
    } else {
      cs = generateCombinations(ss, Object.assign({
        type: 'distinctIntersection',
        empty: true,
        order: ['degree:asc', 'group:asc']
      }, options, combinations !== null && combinations !== void 0 ? combinations : {}));
    }
    var csKeys = cs.map(toKey);
    return {
      cs: cs,
      setKeys: setKeys,
      csKeys: csKeys
    };
  }
  function deriveVennSizeDependent(width, height, margin, id) {
    var h = height - 2 * margin;
    var w = width - 2 * margin;
    var r = Math.min(w, h) / 2;
    return {
      id: id ? id : generateId(),
      legend: {
        x: width / 2
      },
      area: {
        w: w,
        h: h,
        cx: w / 2,
        cy: h / 2,
        r: r
      },
      margin: margin,
      w: width,
      h: height
    };
  }
  function deriveVennStyleDependent(theme, styles, classNames, styleId, selectionColor, title, description, tooltips) {
    return {
      theme: theme,
      styles: styles,
      classNames: classNames,
      id: styleId,
      selectionColor: selectionColor,
      title: title,
      description: description,
      tooltips: tooltips
    };
  }
  function useCreateCommon(p) {
    var _p$queries2 = p.queries,
        queries = _p$queries2 === void 0 ? [] : _p$queries2,
        fontSizes = p.fontSizes;
    var styleId = d(function () {
      return p.id ? p.id : generateId([p.fontFamily, fontSizes.valueLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.valueTextColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
    }, [p.id, p.fontFamily, fontSizes.valueLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.valueTextColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
    var styleInfo = d(function () {
      return deriveVennStyleDependent(p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips);
    }, [p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips]);
    var sizeInfo = d(function () {
      return deriveVennSizeDependent(p.width, p.height, p.padding, p.id);
    }, [p.width, p.height, p.padding, p.id]);
    var h = useHandler(p);
    var qs = React.useMemo(function () {
      return queries.map(function (q) {
        return queryOverlap(q, 'intersection', p.toElemKey);
      });
    }, [queries, p.toElemKey]);
    var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    return {
      styleId: styleId,
      size: sizeInfo,
      style: styleInfo,
      h: h,
      qs: qs,
      rulesHelper: rulesHelper
    };
  }
  function useExportChart(dataInfo, props, mode) {
    return A$1(function (evt) {
      var svg = evt.currentTarget.closest('svg');
      var type = evt.currentTarget.dataset.type || 'png';
      switch (type) {
        case 'dump':
          exportDump(svg, props, dataInfo, mode);
          break;
        case 'share':
          exportSharedLink(props, dataInfo, mode);
          break;
        case 'svg':
        case 'png':
          exportSVG$1(svg, {
            type: type,
            toRemove: ".".concat(evt.currentTarget.getAttribute('class'))
          });
      }
    }, [dataInfo, props, mode]);
  }
  var VennDiagram =
  /*!#__PURE__*/
  React.forwardRef(function VennDiagram(props, ref) {
    var p = fillVennDiagramDefaults$1(props);
    var _p$selection2 = p.selection,
        selection = _p$selection2 === void 0 ? null : _p$selection2,
        _p$queries3 = p.queries,
        queries = _p$queries3 === void 0 ? [] : _p$queries3,
        fontSizes = p.fontSizes;
    var v = useCreateCommon(p);
    var size = v.size,
        style = v.style,
        rulesHelper = v.rulesHelper;
    var dataInfo = d(function () {
      return deriveVennDataDependent(p.sets, p.combinations, size, p.layout, p.valueFormat, p.toKey, p.toElemKey, p.id, p.setLabelOffsets);
    }, [p.sets, p.combinations, size, p.valueFormat, p.toKey, p.toElemKey, p.id, p.layout, p.setLabelOffsets]);
    var selectionKey = selection != null && isSetLike$1(selection) ? p.toKey(selection) : null;
    var selectionOverlap = selection == null ? null : generateSelectionOverlap(selection, dataInfo.overlapGuesser, dataInfo.toElemKey);
    var selectionName = generateSelectionName(selection);
    var rules = "\n  ".concat(rulesHelper.root, "\n  ").concat(rulesHelper.text, "\n\n  .valueTextStyle-").concat(style.id, " {\n    fill: ").concat(p.valueTextColor, ";\n    ").concat(rulesHelper.p(fontSizes.valueLabel), "\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .setTextStyle-").concat(style.id, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.setLabel), "\n    text-anchor: middle;\n  }\n\n  .topText-").concat(style.id, " {\n    dominant-baseline: hanging;\n  }\n\n  .stroke-circle-").concat(style.id, " {\n    fill: none;\n    stroke: ").concat(p.strokeColor, ";\n  }\n\n  .arc-").concat(style.id, " {\n    fill-rule: evenodd;\n  }\n  .arcP-").concat(style.id, " {\n    fill: transparent;\n    fill-opacity: ").concat(p.opacity, ";\n  }\n  ").concat(rulesHelper.fill, "\n  ").concat(rulesHelper["export"], "\n\n  ").concat(rulesHelper.hasSFill ? ".root-".concat(style.id, "[data-selection] .arcP-").concat(style.id, " { ").concat(rulesHelper.hasSFill, " }") : '', "\n\n  ").concat(queries.map(function (q, i) {
      return ".fillQ".concat(i, "-").concat(dataInfo.id, " {\n    fill: ").concat(q.color, ";\n  }");
    }).join('\n'), "\n  ");
    var exportChart = useExportChart(dataInfo, p, 'venn');
    var maxWidth = dataInfo.sets.d.reduce(function (acc, d) {
      return Math.min(acc, d.l.cx - (isEllipse(d.l) ? d.l.rx : d.l.r));
    }, size.area.w);
    return React.createElement(SVGWrapper, {
      rules: rules,
      style: style,
      selectionName: selectionName,
      size: size,
      p: p,
      data: dataInfo,
      tRef: ref,
      h: v.h,
      exportChart: exportChart
    }, React.createElement(UpSetTitle, {
      style: style,
      width: maxWidth
    }), React.createElement("g", {
      className: clsx(p.onClick && "clickAble-".concat(style.id))
    }, dataInfo.sets.d.map(function (d, i) {
      return React.createElement("text", {
        key: d.key,
        x: d.l.text.x + d.offset.x,
        y: d.l.text.y + d.offset.y,
        onClick: v.h.onClick(dataInfo.sets.v[i], []),
        onMouseEnter: v.h.onMouseEnter(dataInfo.sets.v[i], []),
        onMouseLeave: v.h.onMouseLeave,
        onContextMenu: v.h.onContextMenu(dataInfo.sets.v[i], []),
        onMouseMove: v.h.onMouseMove(dataInfo.sets.v[i], []),
        className: clsx("setTextStyle-".concat(style.id), "".concat(d.l.align, "Text-").concat(style.id), "".concat(d.l.verticalAlign, "Text-").concat(style.id), style.classNames.setLabel)
      }, style.tooltips && React.createElement("title", null, dataInfo.sets.v[i].name, ": ", dataInfo.format(dataInfo.sets.v[i].cardinality)), dataInfo.sets.v[i].name);
    })), React.createElement("g", {
      className: clsx(p.onClick && "clickAble-".concat(style.id))
    }, dataInfo.cs.d.map(function (l, i) {
      return React.createElement(VennArcSliceSelection, {
        key: l.key,
        d: l.v,
        i: i,
        slice: l.l,
        size: size,
        style: style,
        data: dataInfo,
        fill: p.filled,
        h: v.h,
        selectionName: selectionName,
        selected: selectionKey === l.key || isSet(selection) && dataInfo.cs.has(l.v, selection),
        elemOverlap: selectionOverlap,
        queries: queries,
        qs: v.qs
      });
    })), React.createElement("g", null, dataInfo.sets.d.map(function (l) {
      return isEllipse(l.l) ? React.createElement("ellipse", {
        key: l.key,
        rx: l.l.rx,
        ry: l.l.ry,
        transform: "translate(".concat(l.l.cx, ",").concat(l.l.cy, ")rotate(").concat(l.l.rotation, ")"),
        className: clsx("stroke-circle-".concat(style.id), style.classNames.set),
        style: style.styles.set
      }) : React.createElement("circle", {
        key: l.key,
        cx: l.l.cx,
        cy: l.l.cy,
        r: l.l.r,
        className: clsx("stroke-circle-".concat(style.id), style.classNames.set),
        style: style.styles.set
      });
    })));
  });
  var KMapCell =
  /*!#__PURE__*/
  React.memo(function KMapCell(_ref24) {
    var d = _ref24.d,
        i = _ref24.i,
        h = _ref24.h,
        className = _ref24.className,
        data = _ref24.data,
        style = _ref24.style;
    var l = data.cs.l[i];
    var y = data.cs.scale(d.cardinality);
    var x = (data.cell - data.cs.bandWidth) / 2;
    return React.createElement("g", {
      transform: "translate(".concat(l.x, ", ").concat(l.y, ")"),
      onMouseEnter: h.onMouseEnter(d, []),
      onMouseLeave: h.onMouseLeave,
      onClick: h.onClick(d, []),
      onContextMenu: h.onContextMenu(d, []),
      onMouseMove: h.onMouseMove(d, []),
      className: className,
      "data-cardinality": d.cardinality
    }, style.tooltips && React.createElement("title", null, d.name, ": ", data.sets.format(d.cardinality)), React.createElement("rect", {
      width: data.cell,
      height: data.cell,
      className: "fillTransparent-".concat(style.id)
    }), React.createElement("rect", {
      x: x,
      y: y,
      height: data.cell - y,
      width: data.cs.bandWidth,
      className: clsx("fillPrimary-".concat(style.id), style.classNames.bar),
      style: mergeColor(style.styles.bar, d.color)
    }), React.createElement("text", {
      y: y - style.barLabelOffset,
      x: data.cell / 2,
      style: style.styles.barLabel,
      className: clsx("barTextStyle-".concat(style.id), style.classNames.barLabel)
    }, data.sets.format(d.cardinality)));
  });
  function generateGridPath(cell, vCells, hCells, level) {
    var h = cell * vCells;
    var w = cell * hCells;
    return [level.x.map(function (x) {
      return "M ".concat(x * cell, ",0 l0,").concat(h);
    }), level.y.map(function (y) {
      return "M 0,".concat(y * cell, " l").concat(w, ",0");
    })].flat().join(' ');
  }
  var KMapChart =
  /*!#__PURE__*/
  React.memo(function KMapChart(_ref25) {
    var data = _ref25.data,
        style = _ref25.style,
        size = _ref25.size,
        h = _ref25.h;
    var csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
    return React.createElement("g", null, React.createElement("g", {
      transform: "translate(".concat(size.w - csNameOffset - 2, ", ").concat(size.h - data.cell - 50, ")")
    }, React.createElement(Axis, {
      scale: data.cs.scale,
      orient: "left",
      size: data.cell,
      start: data.cs.barLabelFontSize,
      style: style
    }), React.createElement("text", {
      className: clsx("cChartTextStyle-".concat(style.id), style.classNames.chartLabel),
      style: style.styles.chartLabel,
      transform: "translate(".concat(-csNameOffset, ", ").concat(data.cell, ")rotate(-90)")
    }, style.cs.name)), React.createElement("g", null, data.sets.l.map(function (l, i) {
      var s = data.sets.v[i];
      var name = s.name;
      return React.createElement("g", {
        key: name,
        onClick: h.onClick(s, []),
        onMouseEnter: h.onMouseEnter(s, []),
        onMouseLeave: h.onMouseLeave,
        onContextMenu: h.onContextMenu(s, []),
        onMouseMove: h.onMouseMove(s, []),
        className: clsx(h.hasClick && "clickAble-".concat(style.id))
      }, l.text.map(function (p, i) {
        return React.createElement("text", {
          key: i,
          transform: "translate(".concat(p.x, ",").concat(p.y, ")").concat(!l.hor ? 'rotate(-90)' : ''),
          className: clsx("setTextStyle-".concat(style.id))
        }, name);
      }));
    }), data.sets.l.map(function (l, i) {
      var name = data.sets.v[i].name;
      return React.createElement(React.Fragment, {
        key: name
      }, l.notText.map(function (p, i) {
        return React.createElement("text", {
          key: i,
          transform: "translate(".concat(p.x, ",").concat(p.y, ")").concat(!l.hor ? 'rotate(-90)' : ''),
          className: clsx("setTextStyle-".concat(style.id), "not-".concat(style.id))
        }, name);
      }));
    })), React.createElement("g", {
      className: clsx(h.hasClick && "clickAble-".concat(style.id))
    }, data.cs.v.map(function (c, i) {
      return React.createElement(KMapCell, {
        key: data.cs.keys[i],
        d: c,
        i: i,
        h: h,
        style: style,
        data: data
      });
    })), React.createElement("g", {
      transform: "translate(".concat(data.grid.x, ", ").concat(data.grid.y, ")")
    }, data.grid.levels.map(function (l, i) {
      return React.createElement("path", {
        key: i,
        d: generateGridPath(data.cell, data.grid.vCells, data.grid.hCells, l),
        className: "gridStyle-".concat(style.id, " gridStyle-").concat(style.id, "-").concat(i)
      });
    })));
  });
  function KMapQueries$1(_ref26) {
    var data = _ref26.data,
        style = _ref26.style,
        elemOverlap = _ref26.elemOverlap,
        secondary = _ref26.secondary,
        tooltip = _ref26.tooltip,
        suffix = _ref26.suffix,
        empty = _ref26.empty;
    var width = data.cs.bandWidth;
    var offset = (data.cell - width) / 2;
    var className = clsx("fill".concat(suffix), !tooltip && "pnone-".concat(style.id), style.classNames.bar);
    return React.createElement("g", {
      "data-upset": secondary ? 'cs-q' : 'cs-s'
    }, data.cs.v.map(function (d, i) {
      var l = data.cs.l[i];
      var key = data.cs.keys[i];
      if (empty && !secondary) {
        return React.createElement("rect", {
          key: key,
          x: l.x + offset,
          y: l.y + data.cell,
          height: 0,
          width: width,
          className: className,
          style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
        }, tooltip && React.createElement("title", null));
      }
      var o = elemOverlap(d);
      if (o === 0) {
        return null;
      }
      var y = data.cs.scale(o);
      var title = tooltip && React.createElement("title", null, "".concat(d.name, " \u2229 ").concat(tooltip, ": ").concat(o));
      return secondary ? React.createElement("path", {
        key: key,
        transform: "translate(".concat(l.x + offset, ", ").concat(l.y + y, ")"),
        d: "M0,-1 l".concat(width, ",0 l0,2 l").concat(-width, ",0 L-").concat(data.triangleSize, ",-").concat(data.triangleSize, " L-").concat(data.triangleSize, ",").concat(data.triangleSize, " Z"),
        className: className,
        "data-i": i,
        "data-cardinality": o,
        style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
      }, title) : React.createElement("rect", {
        key: key,
        x: l.x + offset,
        y: l.y + y,
        height: data.cell - y,
        "data-i": i,
        "data-cardinality": o,
        width: width,
        className: className,
        style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
      }, title);
    }));
  }
  var KMapQueries =
  /*!#__PURE__*/
  React.memo(function KMapQueries(_ref27) {
    var data = _ref27.data,
        style = _ref27.style,
        hasHover = _ref27.hasHover,
        secondary = _ref27.secondary,
        queries = _ref27.queries;
    var qs = d(function () {
      return queries.map(function (q) {
        return Object.assign(Object.assign({}, q), {
          overlap: queryOverlap(q, 'intersection', data.toElemKey)
        });
      });
    }, [queries, data.toElemKey]);
    return React.createElement("g", {
      className: hasHover && !secondary ? "pnone-".concat(style.id) : undefined
    }, qs.map(function (q, i) {
      return React.createElement(KMapQueries$1, {
        key: q.name,
        data: data,
        style: style,
        elemOverlap: q.overlap,
        suffix: "Q".concat(i, "-").concat(data.id),
        secondary: secondary || i > 0,
        tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name
      });
    }));
  });
  function KMapSelection(_ref28) {
    var data = _ref28.data,
        style = _ref28.style,
        selection = _ref28.selection,
        hasHover = _ref28.hasHover;
    var empty = style.emptySelection;
    var selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);
    var selectionName = generateSelectionName(selection);
    return React.createElement("g", {
      className: hasHover ? "pnone-".concat(style.id) : undefined
    }, (selection || empty) && React.createElement(KMapQueries$1, {
      data: data,
      style: style,
      empty: empty && !selection,
      elemOverlap: selectionOverlap,
      suffix: "Selection-".concat(style.id),
      tooltip: hasHover ? undefined : selectionName
    }));
  }
  function ranged(count, cb) {
    return Array(count).fill(0).map(function (_, i) {
      return cb(i);
    });
  }
  function generateLevels(numSets) {
    var lines = Array(Math.pow(2, numSets)).fill(0);
    ranged(numSets, function (i) {
      var shift = Math.pow(2, i);
      for (var _i = 0; _i < lines.length; _i += shift) {
        lines[_i]++;
      }
    });
    var levels = ranged(Math.max(numSets, 1), function () {
      return [];
    });
    lines.forEach(function (l, i) {
      var level = Math.max(0, l - 1);
      levels[level].push(i);
    });
    levels[levels.length - 1].push(lines.length);
    return levels;
  }
  function generate(sets, cs, has, options) {
    var _bounds = bounds(sets.length, options),
        xBefore = _bounds.xBefore,
        yBefore = _bounds.yBefore,
        cell = _bounds.cell,
        hCells = _bounds.hCells,
        vCells = _bounds.vCells,
        horizontalSets = _bounds.horizontalSets,
        verticalSets = _bounds.verticalSets;
    var s = setLabels(sets.length, options);
    var shifts = generateShiftLookup(sets, hCells, vCells, has);
    var c = cs.map(function (c) {
      var _shifts$reduceRight = shifts.reduceRight(function (acc, s) {
        return s(c, acc);
      }, [0, 0]),
          _shifts$reduceRight2 = _slicedToArray(_shifts$reduceRight, 2),
          i = _shifts$reduceRight2[0],
          j = _shifts$reduceRight2[1];
      return {
        x: xBefore + i * cell,
        y: yBefore + j * cell
      };
    });
    var hLevels = generateLevels(horizontalSets);
    var vLevels = generateLevels(verticalSets);
    return {
      s: s,
      c: c,
      cell: cell,
      grid: {
        x: xBefore,
        y: yBefore,
        hCells: hCells,
        vCells: vCells,
        levels: hLevels.map(function (l, i) {
          return {
            x: l,
            y: i < vLevels.length ? vLevels[i] : []
          };
        })
      }
    };
  }
  function generateShiftLookup(sets, hCells, vCells, has) {
    return sets.map(function (s, k) {
      var index = Math.floor(k / 2);
      var hor = k % 2 === 0;
      var numLabels = Math.pow(2, index);
      var span = (hor ? hCells : vCells) / numLabels / 2;
      return function (cs, _ref29) {
        var _ref30 = _slicedToArray(_ref29, 2),
            i = _ref30[0],
            j = _ref30[1];
        if (has(cs, s)) {
          return [i, j];
        }
        if (span > 1) {
          if (hor) {
            return [span - 1 - i + span, j];
          }
          return [i, span - 1 - j + span];
        }
        if (hor) {
          return [i + span, j];
        }
        return [i, j + span];
      };
    });
  }
  function setLabels(sets, options) {
    var _bounds2 = bounds(sets, options),
        xOffset = _bounds2.xOffset,
        yOffset = _bounds2.yOffset,
        cell = _bounds2.cell,
        xBefore = _bounds2.xBefore,
        yBefore = _bounds2.yBefore,
        hCells = _bounds2.hCells,
        vCells = _bounds2.vCells;
    var xAfterEnd = options.width - xOffset;
    var yAfterEnd = options.height - yOffset;
    return ranged(sets, function (k) {
      var index = Math.floor(k / 2);
      var hor = k % 2 === 0;
      var numLabels = Math.pow(2, index);
      var span = (hor ? hCells : vCells) / numLabels / 2;
      var xPos = hor ? xBefore : yBefore;
      var labels = [{
        v: true,
        x: xPos + span * cell * 0.5
      }, {
        v: false,
        x: xPos + span * cell * 1.5
      }];
      var _loop = function _loop(i) {
        var offset = span * Math.pow(2, i) * cell;
        var l = labels.length - 1;
        labels.push.apply(labels, _toConsumableArray(labels.map(function (li, i) {
          return {
            v: labels[l - i].v,
            x: li.x + offset
          };
        })));
      };
      for (var i = 1; i <= index; i++) {
        _loop(i);
      }
      var inAfterGroup = index % 2 === 1;
      var withinGroupIndex = Math.floor(index / 2);
      var yPos = 0;
      if (inAfterGroup) {
        var end = hor ? yAfterEnd : xAfterEnd;
        yPos = end - options.labelHeight * (0.5 + withinGroupIndex);
      } else {
        var start = hor ? yOffset : xOffset;
        yPos = start + options.labelHeight * (0.5 + withinGroupIndex);
      }
      if (hor) {
        return {
          hor: true,
          span: span,
          text: labels.filter(function (d) {
            return d.v;
          }).map(function (l) {
            return {
              x: l.x,
              y: yPos
            };
          }),
          notText: labels.filter(function (d) {
            return !d.v;
          }).map(function (l) {
            return {
              x: l.x,
              y: yPos
            };
          })
        };
      }
      return {
        hor: false,
        span: span,
        text: labels.filter(function (d) {
          return d.v;
        }).map(function (l) {
          return {
            x: yPos,
            y: l.x
          };
        }),
        notText: labels.filter(function (d) {
          return !d.v;
        }).map(function (l) {
          return {
            x: yPos,
            y: l.x
          };
        })
      };
    });
  }
  function bounds(sets, options) {
    var horizontalSets = Math.ceil(sets / 2);
    var verticalSets = Math.floor(sets / 2);
    var hCells = Math.pow(2, horizontalSets);
    var vCells = Math.pow(2, verticalSets);
    var cell = Math.floor(Math.min((options.width - options.labelHeight * verticalSets) / hCells, (options.height - options.labelHeight * horizontalSets) / vCells));
    var xOffset = (options.width - hCells * cell - options.labelHeight * verticalSets) / 2;
    var yOffset = (options.height - vCells * cell - options.labelHeight * horizontalSets) / 2;
    var xBefore = xOffset + Math.ceil(verticalSets / 2) * options.labelHeight;
    var yBefore = yOffset + Math.ceil(horizontalSets / 2) * options.labelHeight;
    return {
      xOffset: xOffset,
      horizontalSets: horizontalSets,
      yOffset: yOffset,
      verticalSets: verticalSets,
      cell: cell,
      xBefore: xBefore,
      yBefore: yBefore,
      hCells: hCells,
      vCells: vCells
    };
  }
  function deriveKarnaughDataDependent(sets, combinations, size, numericScale, barLabelFontSize, barPadding, setLabelFontSize, tickFontSize, toKey, toElemKey, id, combinationMaxScale) {
    var numericScaleFactory = resolveNumericScale(numericScale);
    var setKeys = sets.map(toKey);
    var cs = areCombinations(combinations) ? combinations : generateCombinations(sets, Object.assign({
      type: 'distinctIntersection'
    }, combinations !== null && combinations !== void 0 ? combinations : {}));
    var csKeys = cs.map(toKey);
    var has = function has(v, s) {
      var sk = toKey(s);
      return Array.from(v.sets).some(function (ss) {
        return toKey(ss) === sk;
      });
    };
    var labelHeight = Math.ceil(setLabelFontSize * 1.2);
    var l = generate(sets, cs, has, {
      width: size.area.w,
      height: size.area.h,
      labelHeight: labelHeight
    });
    var maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : cs.reduce(function (acc, d) {
      return Math.max(acc, d.cardinality);
    }, 0);
    var scale = numericScaleFactory(maxCSCardinality, [l.cell, barLabelFontSize], {
      orientation: 'vertical',
      fontSizeHint: tickFontSize
    });
    var bandWidth = Math.round(l.cell * (1 - barPadding));
    var triangleSize = Math.min(Math.max(2, bandWidth / 2 * barPadding), 5);
    var guessLabelWidth = function guessLabelWidth(v) {
      return Math.floor(barLabelFontSize / 1.4 * 0.7 * scale.tickFormat()(v).length);
    };
    var largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
    return {
      id: id ? id : generateId(),
      grid: l.grid,
      sets: {
        keys: setKeys,
        l: l.s,
        v: sets,
        labelHeight: labelHeight,
        format: scale.tickFormat()
      },
      triangleSize: triangleSize,
      cell: l.cell,
      cs: {
        keys: csKeys,
        l: l.c,
        v: cs,
        barLabelFontSize: barLabelFontSize,
        has: has,
        scale: scale,
        bandWidth: bandWidth,
        labelOffset: largestCSLabelWidth + 9 + 6
      },
      toKey: toKey,
      toElemKey: toElemKey,
      overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey)
    };
  }
  function deriveStyleDependent(theme, styles, classNames, combinationName, combinationNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips) {
    return {
      theme: theme,
      styles: styles,
      classNames: classNames,
      emptySelection: emptySelection,
      id: styleId,
      barLabelOffset: barLabelOffset,
      selectionColor: selectionColor,
      title: title,
      description: description,
      tooltips: tooltips,
      cs: {
        name: combinationName,
        offset: combinationNameAxisOffset
      }
    };
  }
  var KarnaughMap =
  /*!#__PURE__*/
  React.forwardRef(function KarnaughMap(props, ref) {
    var p = fillKarnaughMapDefaults$1(props);
    var _p$queries4 = p.queries,
        queries = _p$queries4 === void 0 ? [] : _p$queries4,
        fontSizes = p.fontSizes,
        _p$selection3 = p.selection,
        selection = _p$selection3 === void 0 ? null : _p$selection3;
    var styleId = d(function () {
      return p.id ? p.id : generateId([p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
    }, [p.id, p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
    var style = d(function () {
      return deriveStyleDependent(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips);
    }, [p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips]);
    var size = d(function () {
      return deriveVennSizeDependent(p.width, p.height, p.padding, p.id);
    }, [p.width, p.height, p.padding, p.id]);
    var data = d(function () {
      return deriveKarnaughDataDependent(p.sets, p.combinations, size, p.numericScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.barPadding, parseFontSize(fontSizes.setLabel), parseFontSize(fontSizes.axisTick), p.toKey, p.toElemKey, p.id, p.combinationMaxScale);
    }, [p.sets, p.combinations, size, p.numericScale, p.barLabelOffset, fontSizes.barLabel, p.barPadding, fontSizes.axisTick, fontSizes.setLabel, p.toKey, p.toElemKey, p.id, p.combinationMaxScale]);
    var h = useHandler(p);
    var selectionName = generateSelectionName(selection);
    var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    var rules = "\n  ".concat(rulesHelper.root, "\n  ").concat(rulesHelper.text, "\n\n  .axisTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.axisTick), "\n    text-anchor: end;\n  }\n  .barTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.barLabel), "\n    text-anchor: middle;\n  }\n  .setTextStyle-").concat(style.id, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.setLabel), "\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-").concat(styleId, " {\n    fill: ").concat(p.textColor, ";\n    ").concat(rulesHelper.p(fontSizes.chartLabel), "\n  }\n\n  .not-").concat(style.id, " {\n    text-decoration: overline;\n  }\n\n  .axisLine-").concat(styleId, " {\n    fill: none;\n    stroke: ").concat(p.textColor, ";\n  }\n\n  .gridStyle-").concat(style.id, " {\n    fill: none;\n    stroke: ").concat(p.strokeColor, ";\n    stroke-linecap: round;\n  }\n  .gridStyle-").concat(style.id, "-1 {\n    stroke-width: 2;\n  }\n  .gridStyle-").concat(style.id, "-2 {\n    stroke-width: 3;\n  }\n\n  ").concat(rulesHelper.fill, "\n  ").concat(rulesHelper["export"], "\n\n  ").concat(queries.map(function (q, i) {
      return ".fillQ".concat(i, "-").concat(data.id, " {\n    fill: ").concat(q.color, ";\n  }");
    }).join('\n'), "\n  ");
    var exportChart = useExportChart(data, p, 'kmap');
    var maxWidth = data.sets.l.reduce(function (acc, d) {
      return Math.min(acc, d.text[0].x - data.sets.labelHeight);
    }, size.area.w);
    return React.createElement(SVGWrapper, {
      rules: rules,
      style: style,
      size: size,
      p: p,
      data: data,
      tRef: ref,
      selectionName: selectionName,
      h: h,
      exportChart: exportChart
    }, React.createElement(UpSetTitle, {
      style: style,
      width: maxWidth
    }), React.createElement(KMapChart, {
      style: style,
      data: data,
      h: h,
      size: size
    }), React.createElement(KMapSelection, {
      style: style,
      data: data,
      hasHover: h.hasHover,
      selection: selection
    }), React.createElement(KMapQueries, {
      style: style,
      data: data,
      hasHover: h.hasHover,
      queries: queries,
      secondary: h.hasHover || selection != null
    }));
  });
  var defaults = {
    background: '#F4F4F4',
    color: '#A6A8AB',
    secondaryColor: '#E1E2E3'
  };
  function prepare(props) {
    var _a, _b, _c, _d;
    var color = (_a = props.color) !== null && _a !== void 0 ? _a : defaults.color;
    var secondary = (_b = props.secondaryColor) !== null && _b !== void 0 ? _b : defaults.secondaryColor;
    var rest = Object.assign({}, props);
    var background = (_c = props.background) !== null && _c !== void 0 ? _c : defaults.background;
    delete rest.color;
    delete rest.secondaryColor;
    delete rest.background;
    if (background) {
      rest.style = Object.assign({
        background: background
      }, (_d = rest.style) !== null && _d !== void 0 ? _d : {});
    }
    return {
      color: color,
      secondary: secondary,
      rest: rest
    };
  }
  var UpSetJSSkeleton =
  /*!#__PURE__*/
  React.memo(
  /*!#__PURE__*/
  React.forwardRef(function UpSetJSSkeleton(props, ref) {
    var _prepare = prepare(props),
        color = _prepare.color,
        secondary = _prepare.secondary,
        rest = _prepare.rest;
    var wi = 20;
    var padding = 10;
    var sWidth = 75;
    var sY = 110;
    var cHeight = 100;
    var csX = 85;
    var cOffsets = [10, 20, 35, 60, 65, 80, 90];
    var sOffsets = [50, 30, 15];
    return React.createElement("svg", Object.assign({
      viewBox: "0 0 300 200",
      ref: ref
    }, rest), cOffsets.map(function (offset, i) {
      return React.createElement("rect", {
        key: i,
        x: csX + i * (wi + padding),
        y: offset,
        width: wi,
        height: cHeight - offset,
        fill: color
      });
    }), sOffsets.map(function (offset, i) {
      return React.createElement("rect", {
        key: i,
        x: offset,
        y: sY + i * (wi + padding),
        width: sWidth - offset,
        height: wi,
        fill: color
      });
    }), cOffsets.map(function (_, i) {
      return sOffsets.map(function (_, j) {
        var filled = j === 2 - i || i === 3 && j > 0 || i === 4 && j !== 1 || i === 5 && j < 2 || i === 6;
        return React.createElement("circle", {
          key: "".concat(i, "x").concat(j),
          cx: csX + i * (wi + padding) + wi / 2,
          cy: sY + j * (wi + padding) + wi / 2,
          r: wi / 2,
          fill: filled ? color : secondary
        });
      });
    }), React.createElement("rect", {
      x: "182",
      y: "150",
      width: "6",
      height: "30",
      fill: color
    }), React.createElement("rect", {
      x: "212",
      y: "120",
      width: "6",
      height: "60",
      fill: color
    }), React.createElement("rect", {
      x: "242",
      y: "120",
      width: "6",
      height: "30",
      fill: color
    }), React.createElement("rect", {
      x: "272",
      y: "120",
      width: "6",
      height: "60",
      fill: color
    }));
  }));
  var VennDiagramSkeleton =
  /*!#__PURE__*/
  React.memo(
  /*!#__PURE__*/
  React.forwardRef(function VennDiagramSkeleton(props, ref) {
    var _prepare2 = prepare(props),
        color = _prepare2.color,
        secondary = _prepare2.secondary,
        rest = _prepare2.rest;
    var padding = 10;
    var l = layoutImpl(3, 300 - padding * 2, 3200 - padding * 2);
    return React.createElement("svg", Object.assign({
      viewBox: "0 0 300 200",
      ref: ref
    }, rest), l.sets.map(function (set, i) {
      return React.createElement("circle", {
        key: i,
        cx: set.cx,
        cy: set.cy + padding,
        r: set.r,
        fill: secondary
      });
    }), l.sets.map(function (set, i) {
      return React.createElement("circle", {
        key: i,
        cx: set.cx,
        cy: set.cy + padding,
        r: set.r,
        stroke: color,
        fill: "none"
      });
    }));
  }));
  var KarnaughMapSkeleton =
  /*!#__PURE__*/
  React.memo(
  /*!#__PURE__*/
  React.forwardRef(function KarnaughMapSkeleton(props, ref) {
    var _prepare3 = prepare(props),
        rest = _prepare3.rest,
        color = _prepare3.color,
        secondary = _prepare3.secondary;
    var _bounds3 = bounds(2, {
      width: 270,
      height: 170,
      labelHeight: 20
    }),
        xBefore = _bounds3.xBefore,
        yBefore = _bounds3.yBefore,
        cell = _bounds3.cell,
        hCells = _bounds3.hCells,
        vCells = _bounds3.vCells;
    var gw = hCells * cell;
    var gh = vCells * cell;
    var v1 = 0.9;
    var v2 = 0.5;
    var v3 = 0.26;
    var v4 = 0.75;
    return React.createElement("svg", Object.assign({
      viewBox: "0 0 300 200",
      ref: ref,
      fontFamily: "sans-serif"
    }, rest), React.createElement("g", {
      transform: "translate(".concat(xBefore + 10, ",").concat(yBefore + 10, ")")
    }, React.createElement("text", {
      x: cell * 0.5,
      y: -3,
      fill: color,
      textAnchor: "middle"
    }, "A"), React.createElement("text", {
      x: cell * 1.5,
      y: -3,
      fill: color,
      textAnchor: "middle",
      style: {
        textDecoration: 'overline'
      }
    }, "A"), React.createElement("text", {
      x: -3,
      y: cell * 0.5,
      fill: color,
      textAnchor: "end",
      dominantBaseline: "central"
    }, "B"), React.createElement("text", {
      x: -3,
      y: cell * 1.5,
      fill: color,
      textAnchor: "end",
      dominantBaseline: "central",
      style: {
        textDecoration: 'overline'
      }
    }, "B"), React.createElement("rect", {
      x: cell * 0.1,
      y: cell * (1 - v1),
      height: cell * v1,
      width: cell * 0.8,
      fill: secondary
    }), React.createElement("rect", {
      x: cell * 1.1,
      y: cell * (1 - v2),
      height: cell * v2,
      width: cell * 0.8,
      fill: secondary
    }), React.createElement("rect", {
      x: cell * 0.1,
      y: cell * (1 - v3 + 1),
      height: cell * v3,
      width: cell * 0.8,
      fill: secondary
    }), React.createElement("rect", {
      x: cell * 1.1,
      y: cell * (1 - v4 + 1),
      height: cell * v4,
      width: cell * 0.8,
      fill: secondary
    }), React.createElement("path", {
      d: "M0,0 l".concat(gw, ",0 l0,").concat(gh, " l").concat(-gw, ",0 l0,").concat(-gh, " M").concat(gw / 2, ",0 l0,").concat(gh, " M0,").concat(gh / 2, " l").concat(gw, ",0"),
      fill: "none",
      stroke: color
    })));
  }));
  var DEG2RAD = 1 / 180 * Math.PI;
  function pointAtCircle(cx, cy, radius, angle) {
    return {
      x: cx + Math.cos(angle * DEG2RAD) * radius,
      y: cy + Math.sin(angle * DEG2RAD) * radius
    };
  }
  function center(circles) {
    var sumX = circles.reduce(function (acc, a) {
      return acc + a.x;
    }, 0);
    var sumY = circles.reduce(function (acc, a) {
      return acc + a.y;
    }, 0);
    return {
      x: sumX / circles.length,
      y: sumY / circles.length
    };
  }
  function angleAtCircle(p, c) {
    var x = p.x - c.x;
    var y = p.y - c.y;
    return Math.atan2(y, x) / DEG2RAD;
  }
  function createVennJSAdapter(layout, options) {
    return {
      maxSets: Infinity,
      compute: function compute(sets, combinations, width, height) {
        var overlaps = combinations.map(function (c) {
          return {
            sets: Array.from(c.sets).map(function (s) {
              return s.name;
            }),
            size: c.cardinality
          };
        });
        var r = layout(overlaps, Object.assign({}, {
          width: width,
          height: height,
          distinct: true
        }, options !== null && options !== void 0 ? options : {}));
        var singleSets = r.filter(function (d) {
          return d.data.sets.length === 1;
        });
        var setNames = new Map(sets.map(function (d, i) {
          return [d.name, i];
        }));
        var setCircles = singleSets.map(function (d) {
          return d.circles[0];
        });
        var eulerCenter = center(setCircles);
        var asArc = function asArc(a) {
          return {
            x2: a.p1.x,
            y2: a.p1.y,
            cx: a.circle.x,
            cy: a.circle.y,
            sweep: true,
            large: a.width > a.circle.radius,
            ref: setCircles.findIndex(function (d) {
              return Math.abs(d.x - a.circle.x) < 0.05 && Math.abs(d.y - a.circle.y) < 0.05;
            }),
            mode: 'i'
          };
        };
        return {
          sets: singleSets.map(function (d) {
            var c = d.circles[0];
            var angle = angleAtCircle(c, eulerCenter);
            return {
              cx: c.x,
              cy: c.y,
              r: c.radius,
              align: angle > 90 ? 'end' : 'start',
              verticalAlign: 'bottom',
              text: pointAtCircle(c.x, c.y, c.radius * 1.1, angle)
            };
          }),
          intersections: r.map(function (d) {
            var arcs = d.arcs;
            var text = {
              x: d.text.x,
              y: d.text.y
            };
            if (arcs.length === 0) {
              return {
                sets: d.data.sets.map(function (s) {
                  return setNames.get(s);
                }),
                text: text,
                x1: 0,
                y1: 0,
                arcs: []
              };
            }
            if (arcs.length === 1) {
              var c = d.arcs[0].circle;
              return {
                sets: d.data.sets.map(function (s) {
                  return setNames.get(s);
                }),
                text: text,
                x1: d.arcs[0].p2.x,
                y1: c.y - c.radius,
                arcs: [asArc(d.arcs[0]), Object.assign(asArc(d.arcs[0]), {
                  y2: c.y - c.radius
                })],
                path: d.distinctPath || d.path
              };
            }
            return {
              sets: d.data.sets.map(function (s) {
                return setNames.get(s);
              }),
              text: text,
              x1: d.arcs[0].p2.x,
              y1: d.arcs[0].p2.y,
              arcs: d.arcs.map(function (e) {
                return asArc(e);
              }),
              path: d.distinctPath || d.path
            };
          })
        };
      }
    };
  }
  function widthRatios(value) {
    return value == null || Array.isArray(value) && value.length >= 2 && value.every(function (v) {
      return typeof v === 'number';
    });
  }
  function heightRatios(value) {
    return value == null || Array.isArray(value) && value.length >= 1 && value.every(function (v) {
      return typeof v === 'number';
    });
  }
  function setLabelAlignment(value) {
    return value == null || value === 'left' || value === 'center' || value === 'right';
  }
  function sets(value) {
    return Array.isArray(value) && value.every(isSet);
  }
  function combinations(value) {
    return value == null || Array.isArray(value) && value.every(isSetCombination) || isGenerateSetCombinationOptions(value);
  }
  function selection(value) {
    return value == null || Array.isArray(value) || isSetLike$1(value);
  }
  function onHover(value) {
    return value == null || typeof value === 'function';
  }
  function onClick(value) {
    return value == null || typeof value === 'function';
  }
  function onContextMenu(value) {
    return value == null || typeof value === 'function';
  }
  function onMouseMove(value) {
    return value == null || typeof value === 'function';
  }
  function queries(value) {
    return !value || Array.isArray(value) && value.every(isUpSetQuery);
  }
  function stringOrFalse(value) {
    return value == null || typeof value === 'string' || value === false;
  }
  function setLabelOffsets(value) {
    return value == null || Array.isArray(value) && value.every(function (v) {
      return null;
    });
  }
  function theme(value) {
    return value == null || value === 'light' || value === 'dark' || value === 'vega';
  }
  function classNames(value) {
    return value == null || Object.keys(value).every(function (k) {
      return MULTI_STYLE_KEYS.includes(k) && typeof value[k] === 'string';
    });
  }
  function fontSizes(value) {
    return value == null || Object.keys(value).every(function (k) {
      return FONT_SIZES_KEYS.includes(k) && typeof value[k] === 'string';
    });
  }
  function numericScale(value) {
    return value == null || value === 'linear' || value === 'log' || typeof value === 'function';
  }
  function bandScale(value) {
    return value == null || value === 'band' || typeof value === 'function';
  }
  function axisOffset(value) {
    return value == null || value === 'auto' || typeof value === 'number';
  }
  function style(value) {
    return value == null || _typeof(value) === 'object';
  }
  function styles(value) {
    return value == null || Object.keys(value).every(function (k) {
      return MULTI_STYLE_KEYS.includes(k);
    });
  }
  function exportButtons(value) {
    return value == null || typeof value === 'boolean' || Object.keys(value).every(function (k) {
      return EXPORT_OPTION_KEYS.includes(k) && typeof value[k] === 'boolean';
    });
  }
  var validators = Object.freeze({
    __proto__: null,
    widthRatios: widthRatios,
    heightRatios: heightRatios,
    setLabelAlignment: setLabelAlignment,
    sets: sets,
    combinations: combinations,
    selection: selection,
    onHover: onHover,
    onClick: onClick,
    onContextMenu: onContextMenu,
    onMouseMove: onMouseMove,
    queries: queries,
    stringOrFalse: stringOrFalse,
    setLabelOffsets: setLabelOffsets,
    theme: theme,
    classNames: classNames,
    fontSizes: fontSizes,
    numericScale: numericScale,
    bandScale: bandScale,
    axisOffset: axisOffset,
    style: style,
    styles: styles,
    exportButtons: exportButtons
  });

  var HELPER = Math.sqrt(2 * Math.PI);
  function gaussian(u) {
    return Math.exp(-0.5 * u * u) / HELPER;
  }
  function toSampleVariance(variance, len) {
    return variance * len / (len - 1);
  }
  function nrd(iqr, variance, len) {
    var s = Math.sqrt(toSampleVariance(variance, len));
    if (typeof iqr === 'number') {
      s = Math.min(s, iqr / 1.34);
    }
    return 1.06 * s * Math.pow(len, -0.2);
  }
  function kde(stats) {
    var len = stats.items.length;
    var bandwidth = nrd(stats.iqr, stats.variance, len);
    return function (x) {
      var i = 0;
      var sum = 0;
      for (i = 0; i < len; i++) {
        var v = stats.items[i];
        sum += gaussian((x - v) / bandwidth);
      }
      return sum / bandwidth / len;
    };
  }
  function quantilesInterpolate(arr, length, interpolate) {
    var n1 = length - 1;
    var compute = function compute(q) {
      var index = q * n1;
      var lo = Math.floor(index);
      var h = index - lo;
      var a = arr[lo];
      return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);
    };
    return {
      q1: compute(0.25),
      median: compute(0.5),
      q3: compute(0.75)
    };
  }
  function quantilesType7(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (a, b, alpha) {
      return a + alpha * (b - a);
    });
  }
  function quantilesLinear(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (i, j, fraction) {
      return i + (j - i) * fraction;
    });
  }
  function quantilesLower(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (i) {
      return i;
    });
  }
  function quantilesHigher(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (_, j) {
      return j;
    });
  }
  function quantilesNearest(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (i, j, fraction) {
      return fraction < 0.5 ? i : j;
    });
  }
  function quantilesMidpoint(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesInterpolate(arr, length, function (i, j) {
      return (i + j) * 0.5;
    });
  }
  function quantilesFivenum(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    var n = length;
    var n4 = Math.floor((n + 3) / 2) / 2;
    var compute = function compute(d) {
      return 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);
    };
    return {
      q1: compute(n4),
      median: compute((n + 1) / 2),
      q3: compute(n + 1 - n4)
    };
  }
  function quantilesHinges(arr) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : arr.length;
    return quantilesFivenum(arr, length);
  }
  function createSortedData(data) {
    var valid = 0;
    var length = data.length;
    var vs = data instanceof Float64Array ? new Float64Array(length) : new Float32Array(length);
    for (var i = 0; i < length; i += 1) {
      var v = data[i];
      if (v == null || Number.isNaN(v)) {
        continue;
      }
      vs[valid] = v;
      valid += 1;
    }
    var missing = length - valid;
    if (valid === 0) {
      return {
        min: Number.NaN,
        max: Number.NaN,
        missing: missing,
        s: []
      };
    }
    var validData = valid === length ? vs : vs.subarray(0, valid);
    validData.sort(function (a, b) {
      return a === b ? 0 : a < b ? -1 : 1;
    });
    var min = validData[0];
    var max = validData[validData.length - 1];
    return {
      min: min,
      max: max,
      missing: missing,
      s: validData
    };
  }
  function withSortedData(data) {
    if (data.length === 0) {
      return {
        min: Number.NaN,
        max: Number.NaN,
        missing: 0,
        s: []
      };
    }
    var min = data[0];
    var max = data[data.length - 1];
    return {
      min: min,
      max: max,
      missing: 0,
      s: data
    };
  }
  function computeWhiskers(s, valid, min, max, _ref) {
    var eps = _ref.eps,
        quantiles = _ref.quantiles,
        coef = _ref.coef,
        whiskersMode = _ref.whiskersMode;
    var same = function same(a, b) {
      return Math.abs(a - b) < eps;
    };
    var _quantiles = quantiles(s, valid),
        median = _quantiles.median,
        q1 = _quantiles.q1,
        q3 = _quantiles.q3;
    var iqr = q3 - q1;
    var isCoefValid = typeof coef === 'number' && coef > 0;
    var whiskerLow = isCoefValid ? Math.max(min, q1 - coef * iqr) : min;
    var whiskerHigh = isCoefValid ? Math.min(max, q3 + coef * iqr) : max;
    var outlierLow = [];
    for (var i = 0; i < valid; i += 1) {
      var v = s[i];
      if (v >= whiskerLow || same(v, whiskerLow)) {
        if (whiskersMode === 'nearest') {
          whiskerLow = v;
        }
        break;
      }
      if (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v)) {
        outlierLow.push(v);
      }
    }
    var reversedOutlierHigh = [];
    for (var _i = valid - 1; _i >= 0; _i -= 1) {
      var _v = s[_i];
      if (_v <= whiskerHigh || same(_v, whiskerHigh)) {
        if (whiskersMode === 'nearest') {
          whiskerHigh = _v;
        }
        break;
      }
      if ((reversedOutlierHigh.length === 0 || !same(reversedOutlierHigh[reversedOutlierHigh.length - 1], _v)) && (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], _v))) {
        reversedOutlierHigh.push(_v);
      }
    }
    var outlier = outlierLow.concat(reversedOutlierHigh.reverse());
    return {
      median: median,
      q1: q1,
      q3: q3,
      iqr: iqr,
      outlier: outlier,
      whiskerHigh: whiskerHigh,
      whiskerLow: whiskerLow
    };
  }
  function computeStats(s, valid) {
    var mean = 0;
    for (var i = 0; i < valid; i++) {
      var v = s[i];
      mean += v;
    }
    mean /= valid;
    var variance = 0;
    for (var _i2 = 0; _i2 < valid; _i2++) {
      var _v2 = s[_i2];
      variance += (_v2 - mean) * (_v2 - mean);
    }
    variance /= valid;
    return {
      mean: mean,
      variance: variance
    };
  }
  function boxplot$1(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fullOptions = _objectSpread2({
      coef: 1.5,
      eps: 10e-3,
      quantiles: quantilesType7,
      validAndSorted: false,
      whiskersMode: 'nearest'
    }, options);
    var _ref2 = fullOptions.validAndSorted ? withSortedData(data) : createSortedData(data),
        missing = _ref2.missing,
        s = _ref2.s,
        min = _ref2.min,
        max = _ref2.max;
    var invalid = {
      min: Number.NaN,
      max: Number.NaN,
      mean: Number.NaN,
      missing: missing,
      iqr: Number.NaN,
      count: data.length,
      whiskerHigh: Number.NaN,
      whiskerLow: Number.NaN,
      outlier: [],
      median: Number.NaN,
      q1: Number.NaN,
      q3: Number.NaN,
      variance: 0,
      items: [],
      kde: function kde() {
        return 0;
      }
    };
    var valid = data.length - missing;
    if (valid === 0) {
      return invalid;
    }
    var result = _objectSpread2(_objectSpread2({
      min: min,
      max: max,
      count: data.length,
      missing: missing,
      items: s
    }, computeStats(s, valid)), computeWhiskers(s, valid, min, max, fullOptions));
    return _objectSpread2(_objectSpread2({}, result), {}, {
      kde: kde(result)
    });
  }

  var methodLookup = {
    hinges: quantilesHinges,
    fivenum: quantilesFivenum,
    type7: quantilesType7,
    quantiles: quantilesType7,
    linear: quantilesLinear,
    lower: quantilesLower,
    higher: quantilesHigher,
    nearest: quantilesNearest,
    midpoint: quantilesMidpoint
  };
  function boxplot(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var o = Object.assign({}, options, {
      quantiles: typeof options.quantiles === 'function' || options.quantiles == null ? options.quantiles : methodLookup[options.quantiles]
    });
    if (o.quantiles == null) {
      delete o.quantiles;
    }
    return boxplot$1(data, o);
  }
  function denormalize(range) {
    var delta = range[1] - range[0];
    return function (v) {
      return v * delta + range[0];
    };
  }
  function normalize(domain) {
    var delta = domain[1] - domain[0];
    return function (v) {
      return (v - domain[0]) / delta;
    };
  }
  function colorGen(dark) {
    var schemeDark2 = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d'];
    var schemeSet2 = ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494'];
    var set = dark ? schemeDark2.concat(schemeSet2) : schemeSet2.concat(schemeDark2);
    var acc = 0;
    return function () {
      return set[acc++ % set.length];
    };
  }
  function bin(hist, values) {
    var map = new Map(hist.map(function (bin) {
      return [bin.value, 0];
    }));
    values.forEach(function (value) {
      if (value == null) {
        return;
      }
      var key = value.toString();
      if (!map.has(key)) {
        return;
      }
      map.set(key, map.get(key) + 1);
    });
    return map;
  }
  function categoricalHistogram(values, categories, base) {
    var dark = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var nextColor = colorGen(dark);
    var generateCat = function generateCat(value) {
      return {
        value: value,
        label: value.length > 0 ? "".concat(value[0].toUpperCase()).concat(value.slice(1)) : value,
        color: nextColor()
      };
    };
    var hist = categories.map(function (cat) {
      return Object.assign({
        count: 0,
        acc: 0,
        percentage: 0
      }, generateCat(typeof cat === 'string' ? cat : cat.value), typeof cat === 'string' ? {} : cat);
    });
    var map = bin(hist, values);
    var baseMap = base ? bin(hist, base) : null;
    var total = Array.from(map.values()).reduce(function (acc, v) {
      return acc + v;
    }, 0);
    var acc = 0;
    hist.forEach(function (bin) {
      bin.acc = acc;
      bin.count = map.get(bin.value);
      bin.percentage = bin.count / total;
      acc += baseMap ? baseMap.get(bin.value) : bin.count;
    });
    return hist;
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  function __rest(s, e) {
    var t = {};
    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function round2(v) {
    return Math.round(v * 100) / 100;
  }
  function simpleScale(domain, range) {
    var orient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'horizontal';
    var n = normalize(domain);
    var dnDomain = denormalize(domain);
    var dn = denormalize(range);
    var f = function f(v) {
      return dn(n(v));
    };
    var defaultTicks = orient === 'horizontal' ? 5 : 7;
    f.ticks = function () {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultTicks;
      return Array(count).fill(0).map(function (_, i) {
        var v = dnDomain(i / (count - 1));
        return {
          value: v,
          label: v.toLocaleString(undefined, {
            maximumFractionDigits: 2
          })
        };
      });
    };
    f.tickFormat = function () {
      return function (v) {
        return v.toFixed(2);
      };
    };
    return f;
  }
  var defaultFormatter = function defaultFormatter(v) {
    return v.toFixed(2);
  };
  function toString$1(b, nf) {
    return "Min: ".concat(nf(b.min), ", 25% Quantile: ").concat(nf(b.q1), ", Median: ").concat(nf(b.median), ", 75% Quantile: ").concat(nf(b.q3), ", Max: ").concat(nf(b.max));
  }
  var Boxplot = function Boxplot(p) {
    var _p$theme = p.theme,
        theme = _p$theme === void 0 ? 'light' : _p$theme,
        _p$mode = p.mode,
        mode = _p$mode === void 0 ? 'normal' : _p$mode,
        boxStyle = p.boxStyle,
        lineStyle = p.lineStyle,
        outlierStyle = p.outlierStyle,
        _p$margin = p.margin,
        margin = _p$margin === void 0 ? 0 : _p$margin,
        _p$boxPadding = p.boxPadding,
        bpp = _p$boxPadding === void 0 ? 0.1 : _p$boxPadding,
        _p$outlierRadius = p.outlierRadius,
        outlierRadius = _p$outlierRadius === void 0 ? 3 : _p$outlierRadius,
        _p$numberFormat = p.numberFormat,
        nf = _p$numberFormat === void 0 ? defaultFormatter : _p$numberFormat,
        options = __rest(p, ["theme", "mode", "boxStyle", "lineStyle", "outlierStyle", "margin", "boxPadding", "outlierRadius", "numberFormat"]);
    var b = Array.isArray(p.values) ? boxplot(p.values, options) : p.values;
    if (Number.isNaN(b.median)) {
      return React.createElement("g", null);
    }
    var hor = p.orient !== 'vertical';
    var n = normalize([p.min, p.max]);
    var dn = denormalize([0, hor ? p.width : p.height]);
    var scale = function scale(v) {
      return round2(dn(n(v)));
    };
    var s = {
      max: scale(b.max),
      avg: scale(b.mean),
      med: scale(b.median),
      min: scale(b.min),
      q1: scale(b.q1),
      q3: scale(b.q3),
      wh: scale(b.whiskerHigh),
      wl: scale(b.whiskerLow)
    };
    var title = p.tooltips !== false && React.createElement("title", null, toString$1(b, nf));
    var inner = getDefaultTheme(theme).notMemberColor;
    var styles = {
      box: Object.assign({
        fill: inner
      }, boxStyle),
      line: Object.assign({
        fill: 'none',
        stroke: theme === 'light' ? 'black' : '#cccccc'
      }, lineStyle),
      outlier: Object.assign({
        fill: inner
      }, outlierStyle)
    };
    if (hor) {
      var c = p.height / 2;
      var bp = round2(p.height * bpp) + margin;
      var hp = p.height - bp;
      var w1 = "M".concat(s.wl, ",").concat(margin, " l0,").concat(p.height - margin * 2, " M").concat(s.wl, ",").concat(c, " L").concat(s.q1, ",").concat(c);
      var w2 = "M".concat(s.q3, ",").concat(c, " L").concat(s.wh, ",").concat(c, " M").concat(s.wh, ",").concat(margin, " L").concat(s.wh, ",").concat(p.height - margin);
      var box = "M".concat(s.q1, ",").concat(bp, " L").concat(s.q3, ",").concat(bp, " L").concat(s.q3, ",").concat(hp, " L").concat(s.q1, ",").concat(hp, " L").concat(s.q1, ",").concat(bp, " M").concat(s.med, ",").concat(bp, " l0,").concat(hp - bp);
      var path = React.createElement("path", {
        d: "".concat(w1, " ").concat(w2, " ").concat(box),
        style: styles.line
      });
      if (mode === 'indicator') {
        return path;
      }
      return React.createElement("g", null, title, mode === 'normal' && React.createElement("rect", {
        x: s.q1,
        y: bp,
        width: s.q3 - s.q1,
        height: p.height - 2 * bp,
        style: styles.box
      }), path, b.outlier.map(function (o) {
        return React.createElement("circle", {
          key: o,
          r: outlierRadius,
          cy: c,
          cx: scale(o),
          style: styles.outlier
        }, React.createElement("title", null, "$", nf(o)));
      }));
    }
    {
      var _c = p.width / 2;
      var _bp = round2(p.width * bpp) + margin;
      var wp = p.width - _bp;
      var _w = "M".concat(margin, ",").concat(s.wl, " l").concat(p.width - 2 * margin, ",0 M").concat(_c, ",").concat(s.wl, " L").concat(_c, ",").concat(s.q1);
      var _w2 = "M".concat(_c, ",").concat(s.q3, " L").concat(_c, ",").concat(s.wh, " M").concat(margin, ",").concat(s.wh, " L").concat(p.width - margin, ",").concat(s.wh);
      var _box = "M".concat(_bp, ",").concat(s.q1, " L").concat(_bp, ",").concat(s.q3, " l").concat(wp - _bp, ",0 L").concat(wp, ",").concat(s.q1, " L").concat(_bp, ",").concat(s.q1, " M").concat(_bp, ",").concat(s.med, " l").concat(wp - _bp, ",0");
      var _path = React.createElement("path", {
        d: "".concat(_w, " ").concat(_w2, " ").concat(_box),
        style: styles.line
      });
      if (mode === 'indicator') {
        return _path;
      }
      return React.createElement("g", null, title, mode === 'normal' && React.createElement("rect", {
        y: s.q1,
        x: _bp,
        height: s.q3 - s.q1,
        width: p.width - 2 * _bp,
        style: styles.box
      }), _path, b.outlier.map(function (o) {
        return React.createElement("circle", {
          key: o,
          r: outlierRadius,
          cx: _c,
          cy: scale(o),
          style: styles.outlier
        }, React.createElement("title", null, "$", nf(o)));
      }));
    }
  };
  var BoxplotMemo =
  /*!#__PURE__*/
  React.memo(Boxplot);
  function boxplotAddon$1(prop, elems) {
    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a$size = _a.size,
        size = _a$size === void 0 ? 100 : _a$size,
        position = _a.position,
        _a$name = _a.name,
        name = _a$name === void 0 ? prop.toString() : _a$name,
        extras = __rest(_a, ["size", "position", "name"]);
    var acc = typeof prop === 'function' ? prop : function (v) {
      return v[prop];
    };
    var min = Number.POSITIVE_INFINITY;
    var max = Number.NEGATIVE_INFINITY;
    if (Array.isArray(elems)) {
      elems.forEach(function (elem) {
        var v = acc(elem);
        if (v == null || Number.isNaN(v)) {
          return;
        }
        if (v < min) {
          min = v;
        }
        if (v > max) {
          max = v;
        }
      });
    } else {
      var d = elems;
      min = d.min;
      max = d.max;
    }
    var scale = simpleScale([min, max], [0, size], extras.orient);
    return {
      name: name,
      position: position,
      size: size,
      scale: scale,
      createOnHandlerData: function createOnHandlerData(set) {
        var b = boxplot(set.elems.map(acc), extras);
        return {
          id: 'boxplot',
          name: name,
          value: Object.assign(Object.assign(Object.assign({}, b), {
            toString: function toString() {
              var _a;
              return toString$1(this, (_a = extras.numberFormat) !== null && _a !== void 0 ? _a : defaultFormatter);
            }
          }), b)
        };
      },
      render: function render(_ref) {
        var width = _ref.width,
            height = _ref.height,
            set = _ref.set,
            theme = _ref.theme;
        var values = set.elems.map(acc);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          theme: theme
        }, extras));
      },
      renderSelection: function renderSelection(_ref2) {
        var width = _ref2.width,
            height = _ref2.height,
            overlap = _ref2.overlap,
            selectionColor = _ref2.selectionColor,
            theme = _ref2.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = overlap.map(acc);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          mode: "box",
          lineStyle: {
            stroke: selectionColor,
            strokeWidth: 2
          },
          outlierStyle: {
            fill: selectionColor
          },
          theme: theme
        }, extras));
      },
      renderQuery: function renderQuery(_ref3) {
        var width = _ref3.width,
            height = _ref3.height,
            overlap = _ref3.overlap,
            query = _ref3.query,
            secondary = _ref3.secondary,
            index = _ref3.index,
            theme = _ref3.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = overlap.map(acc);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          mode: secondary ? 'indicator' : 'box',
          margin: secondary ? index + 2 : 0,
          lineStyle: {
            stroke: query.color,
            strokeWidth: secondary ? 1 : 2
          },
          outlierStyle: {
            fill: query.color
          },
          theme: theme
        }, extras));
      }
    };
  }
  function boxplotAggregatedAddon$1(acc, domain) {
    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a$size2 = _a.size,
        size = _a$size2 === void 0 ? 100 : _a$size2,
        position = _a.position,
        _a$name2 = _a.name,
        name = _a$name2 === void 0 ? 'BoxPlot' : _a$name2,
        extras = __rest(_a, ["size", "position", "name"]);
    var min = domain.min;
    var max = domain.max;
    var scale = simpleScale([min, max], [0, size], extras.orient);
    return {
      name: name,
      position: position,
      size: size,
      scale: scale,
      createOnHandlerData: function createOnHandlerData(set) {
        var b = acc(set.elems);
        b.toString = function () {
          var _a;
          return toString$1(this, (_a = extras.numberFormat) !== null && _a !== void 0 ? _a : defaultFormatter);
        };
        return {
          id: 'boxplot',
          name: name,
          value: b
        };
      },
      render: function render(_ref4) {
        var width = _ref4.width,
            height = _ref4.height,
            set = _ref4.set,
            theme = _ref4.theme;
        var values = acc(set.elems);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          theme: theme
        }, extras));
      },
      renderSelection: function renderSelection(_ref5) {
        var width = _ref5.width,
            height = _ref5.height,
            overlap = _ref5.overlap,
            selectionColor = _ref5.selectionColor,
            theme = _ref5.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = acc(overlap);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          mode: "box",
          lineStyle: {
            stroke: selectionColor,
            strokeWidth: 2
          },
          outlierStyle: {
            fill: selectionColor
          },
          theme: theme
        }, extras));
      },
      renderQuery: function renderQuery(_ref6) {
        var width = _ref6.width,
            height = _ref6.height,
            overlap = _ref6.overlap,
            query = _ref6.query,
            secondary = _ref6.secondary,
            index = _ref6.index,
            theme = _ref6.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = acc(overlap);
        return React.createElement(BoxplotMemo, Object.assign({
          values: values,
          width: width,
          height: height,
          min: min,
          max: max,
          mode: secondary ? 'indicator' : 'box',
          margin: secondary ? index + 2 : 0,
          lineStyle: {
            stroke: query.color,
            strokeWidth: secondary ? 1 : 2
          },
          outlierStyle: {
            fill: query.color
          },
          theme: theme
        }, extras));
      }
    };
  }
  function isGiven(p) {
    return Array.isArray(p.bins);
  }
  function _toString(cat) {
    return cat.map(function (bin) {
      return "".concat(bin.label, ": ").concat(bin.count);
    }).join(', ');
  }
  var Categorical = function Categorical(p) {
    var _a, _b;
    var _p$margin2 = p.margin,
        margin = _p$margin2 === void 0 ? 0 : _p$margin2,
        _p$rectStyle = p.rectStyle,
        rectStyle = _p$rectStyle === void 0 ? {} : _p$rectStyle;
    var bins = isGiven(p) ? p.bins : categoricalHistogram(p.values, p.categories, p.base, p.theme === 'dark');
    var n = normalize([0, isGiven(p) ? p.bins.reduce(function (acc, v) {
      return acc + v.count;
    }, 0) : (_b = (_a = p.base) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : p.values.length]);
    var hor = p.orient !== 'vertical';
    var dn = denormalize([0, hor ? p.width : p.height]);
    var scale = function scale(v) {
      return dn(n(v));
    };
    if (hor) {
      return React.createElement("g", null, bins.map(function (bin) {
        return React.createElement("rect", {
          key: bin.value,
          x: scale(bin.acc),
          width: scale(bin.count),
          y: margin,
          height: p.height - 2 * margin,
          style: Object.assign({
            fill: bin.color
          }, rectStyle)
        }, p.tooltips !== false && React.createElement("title", null, "".concat(bin.label, ": ").concat(bin.count)));
      }));
    }
    return React.createElement("g", null, bins.map(function (bin) {
      return React.createElement("rect", {
        key: bin.value,
        y: scale(bin.acc),
        height: scale(bin.count),
        x: margin,
        width: p.width - 2 * margin,
        style: Object.assign({
          fill: bin.color
        }, rectStyle)
      }, p.tooltips !== false && React.createElement("title", null, "".concat(bin.label, ": ").concat(bin.count)));
    }));
  };
  var CategoricalMemo =
  /*!#__PURE__*/
  React.memo(Categorical);
  var lightOverlap = 'rgba(255,255,255,0.2)';
  var darkOverlap = 'rgba(0,0,0,0.1)';
  function categoricalAddon$1(prop, elems) {
    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a$size3 = _a.size,
        size = _a$size3 === void 0 ? 100 : _a$size3,
        position = _a.position,
        _a$name3 = _a.name,
        name = _a$name3 === void 0 ? prop.toString() : _a$name3,
        extras = __rest(_a, ["size", "position", "name"]);
    var acc = typeof prop === 'function' ? prop : function (v) {
      return v[prop];
    };
    var categories = [];
    if (Array.isArray(elems)) {
      var cats = new Set();
      elems.forEach(function (elem) {
        var v = acc(elem);
        if (v == null) {
          return;
        }
        cats.add(v.toString());
      });
      categories = Array.from(cats).sort();
    } else {
      categories = elems.categories;
    }
    return {
      name: name,
      position: position,
      size: size,
      createOnHandlerData: function createOnHandlerData(set) {
        var b = categoricalHistogram(set.elems.map(acc), categories, undefined, extras.theme === 'dark');
        b.toString = function () {
          return _toString(this);
        };
        return {
          id: 'categorical',
          name: name,
          value: b
        };
      },
      render: function render(_ref7) {
        var width = _ref7.width,
            height = _ref7.height,
            set = _ref7.set,
            theme = _ref7.theme;
        var values = set.elems.map(acc);
        return React.createElement(CategoricalMemo, Object.assign({
          values: values,
          categories: categories,
          width: width,
          height: height,
          theme: theme
        }, extras));
      },
      renderSelection: function renderSelection(_ref8) {
        var width = _ref8.width,
            height = _ref8.height,
            set = _ref8.set,
            theme = _ref8.theme,
            overlap = _ref8.overlap,
            selectionColor = _ref8.selectionColor;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var base = set.elems.map(acc);
        var values = overlap.map(acc);
        return React.createElement(CategoricalMemo, Object.assign({
          values: values,
          base: base,
          categories: categories,
          width: width,
          height: height,
          theme: theme,
          rectStyle: {
            stroke: selectionColor,
            strokeWidth: 2,
            fill: theme === 'light' ? darkOverlap : lightOverlap
          }
        }, extras));
      },
      renderQuery: function renderQuery(_ref9) {
        var width = _ref9.width,
            height = _ref9.height,
            overlap = _ref9.overlap,
            set = _ref9.set,
            query = _ref9.query,
            secondary = _ref9.secondary,
            index = _ref9.index,
            theme = _ref9.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var base = set.elems.map(acc);
        var values = overlap.map(acc);
        return React.createElement(CategoricalMemo, Object.assign({
          values: values,
          base: base,
          categories: categories,
          width: width,
          height: height,
          margin: secondary ? index + 2 : 0,
          rectStyle: {
            stroke: query.color,
            fill: theme === 'light' ? darkOverlap : lightOverlap
          },
          theme: theme
        }, extras));
      }
    };
  }
  function categoricalAggregatedAddon$1(acc) {
    var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a$size4 = _a.size,
        size = _a$size4 === void 0 ? 100 : _a$size4,
        position = _a.position,
        _a$name4 = _a.name,
        name = _a$name4 === void 0 ? 'Histogram' : _a$name4,
        extras = __rest(_a, ["size", "position", "name"]);
    return {
      name: name,
      position: position,
      size: size,
      createOnHandlerData: function createOnHandlerData(set) {
        var b = acc(set.elems);
        return {
          id: 'categorical',
          name: name,
          value: Object.assign(Object.assign(Object.assign({}, b), {
            toString: function toString() {
              return _toString(this);
            }
          }), b)
        };
      },
      render: function render(_ref10) {
        var width = _ref10.width,
            height = _ref10.height,
            set = _ref10.set,
            theme = _ref10.theme;
        var values = acc(set.elems);
        return React.createElement(CategoricalMemo, Object.assign({
          bins: values,
          width: width,
          height: height,
          theme: theme
        }, extras));
      },
      renderSelection: function renderSelection(_ref11) {
        var width = _ref11.width,
            height = _ref11.height,
            theme = _ref11.theme,
            overlap = _ref11.overlap,
            selectionColor = _ref11.selectionColor;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = acc(overlap);
        return React.createElement(CategoricalMemo, Object.assign({
          bins: values,
          width: width,
          height: height,
          theme: theme,
          rectStyle: {
            stroke: selectionColor,
            strokeWidth: 2,
            fill: theme === 'light' ? darkOverlap : lightOverlap
          }
        }, extras));
      },
      renderQuery: function renderQuery(_ref12) {
        var width = _ref12.width,
            height = _ref12.height,
            overlap = _ref12.overlap,
            query = _ref12.query,
            secondary = _ref12.secondary,
            index = _ref12.index,
            theme = _ref12.theme;
        if (overlap == null || overlap.length === 0) {
          return null;
        }
        var values = acc(overlap);
        return React.createElement(CategoricalMemo, Object.assign({
          bins: values,
          width: width,
          height: height,
          margin: secondary ? index + 2 : 0,
          rectStyle: {
            stroke: query.color,
            fill: theme === 'light' ? darkOverlap : lightOverlap
          },
          theme: theme
        }, extras));
      }
    };
  }

  function boxplotAddon(prop, elems, options) {
      if (options === void 0) { options = {}; }
      return boxplotAddon$1(prop, elems, options);
  }
  function boxplotAggregatedAddon(acc, domain, options) {
      if (options === void 0) { options = {}; }
      return boxplotAggregatedAddon$1(acc, domain, options);
  }

  function categoricalAddon(prop, elems, options) {
      if (options === void 0) { options = {}; }
      return categoricalAddon$1(prop, elems, options);
  }
  function categoricalAggregatedAddon(acc, options) {
      if (options === void 0) { options = {}; }
      return categoricalAggregatedAddon$1(acc, options);
  }

  function fillDefaults(props) {
      var p = props;
      return fillDefaults$1(p);
  }
  function fillVennDiagramDefaults(props) {
      var p = props;
      return fillVennDiagramDefaults$1(p);
  }
  function fillKarnaughMapDefaults(props) {
      var p = props;
      return fillKarnaughMapDefaults$1(p);
  }
  function render(node, props) {
      var p = props;
      S$1(v$1(UpSetJS, p), node);
  }
  function renderUpSet(node, props) {
      var p = props;
      S$1(v$1(UpSetJS, p), node);
  }
  function renderVennDiagram(node, props) {
      var p = props;
      S$1(v$1(VennDiagram, p), node);
  }
  function renderKarnaughMap(node, props) {
      var p = props;
      S$1(v$1(KarnaughMap, p), node);
  }
  function renderSkeleton(node, props) {
      var p = props;
      S$1(v$1(UpSetJSSkeleton, p), node);
  }
  function renderVennDiagramSkeleton(node, props) {
      var p = props;
      S$1(v$1(VennDiagramSkeleton, p), node);
  }
  function renderKarnaughMapSkeleton(node, props) {
      var p = props;
      S$1(v$1(KarnaughMapSkeleton, p), node);
  }
  function hydrate(node, props) {
      var p = props;
      q$1(v$1(UpSetJS, p), node);
  }
  function hydrateVennDiagram(node, props) {
      var p = props;
      q$1(v$1(VennDiagram, p), node);
  }
  function hydrateKarnaughMap(node, props) {
      var p = props;
      q$1(v$1(KarnaughMap, p), node);
  }
  function hydrateSkeleton(node, props) {
      var p = props;
      q$1(v$1(UpSetJSSkeleton, p), node);
  }
  function hydrateVennDiagramSkeleton(node, props) {
      var p = props;
      q$1(v$1(VennDiagramSkeleton, p), node);
  }
  function hydrateKarnaughMapSkeleton(node, props) {
      var p = props;
      q$1(v$1(KarnaughMapSkeleton, p), node);
  }
  var hydrateUpSet = hydrate;
  function exportSVG(node, options) {
      return exportSVG$1(node, options);
  }
  function downloadUrl(url, title, doc) {
      downloadUrl$1(url, title, doc);
  }
  function toUpSetJSDump(dump, elements, props, author, mode) {
      return toUpSetJSDump$1(dump, elements, props, author, mode);
  }
  function toUpSetJSStaticDump(dump, props, author, mode) {
      return toUpSetJSStaticDump$1(dump, props, author, mode);
  }
  function createElement(type, props) {
      var children = [];
      for (var _i = 2; _i < arguments.length; _i++) {
          children[_i - 2] = arguments[_i];
      }
      return v$1.apply(void 0, __spreadArray([type, props], children, false));
  }

  exports.SET_JOINERS = SET_JOINERS;
  exports.asCombination = asCombination;
  exports.asCombinations = asCombinations;
  exports.asSet = asSet;
  exports.asSets = asSets;
  exports.bandScale = bandScale$1;
  exports.boxplot = boxplot;
  exports.boxplotAddon = boxplotAddon;
  exports.boxplotAggregatedAddon = boxplotAggregatedAddon;
  exports.categoricalAddon = categoricalAddon;
  exports.categoricalAggregatedAddon = categoricalAggregatedAddon;
  exports.categoricalHistogram = categoricalHistogram;
  exports.createElement = createElement;
  exports.createVennJSAdapter = createVennJSAdapter;
  exports.downloadUrl = downloadUrl;
  exports.exportSVG = exportSVG;
  exports.extractCombinations = extractCombinations;
  exports.extractFromExpression = extractFromExpression;
  exports.extractSets = extractSets;
  exports.fillDefaults = fillDefaults;
  exports.fillKarnaughMapDefaults = fillKarnaughMapDefaults;
  exports.fillVennDiagramDefaults = fillVennDiagramDefaults;
  exports.fromDump = fromDump;
  exports.fromIndicesArray = fromIndicesArray;
  exports.fromSetName = fromSetName;
  exports.fromStaticDump = fromStaticDump;
  exports.generateCombinations = generateCombinations;
  exports.generateDistinctOverlapFunction = generateDistinctOverlapFunction;
  exports.generateIntersectionOverlapFunction = generateIntersectionOverlapFunction;
  exports.generateOverlapFunction = generateOverlapFunction;
  exports.generateOverlapLookup = generateOverlapLookup;
  exports.generateOverlapLookupFunction = generateOverlapLookupFunction;
  exports.generateUnionOverlapFunction = generateUnionOverlapFunction;
  exports.getDefaultTheme = getDefaultTheme;
  exports.hydrate = hydrate;
  exports.hydrateKarnaughMap = hydrateKarnaughMap;
  exports.hydrateKarnaughMapSkeleton = hydrateKarnaughMapSkeleton;
  exports.hydrateSkeleton = hydrateSkeleton;
  exports.hydrateUpSet = hydrateUpSet;
  exports.hydrateVennDiagram = hydrateVennDiagram;
  exports.hydrateVennDiagramSkeleton = hydrateVennDiagramSkeleton;
  exports.isCalcQuery = isCalcQuery;
  exports.isElemQuery = isElemQuery;
  exports.isGenerateSetCombinationOptions = isGenerateSetCombinationOptions;
  exports.isSet = isSet;
  exports.isSetCombination = isSetCombination;
  exports.isSetLike = isSetLike$1;
  exports.isSetQuery = isSetQuery;
  exports.isUpSetQuery = isUpSetQuery;
  exports.linearScale = linearScale;
  exports.logScale = logScale;
  exports.mergeColors = mergeColors;
  exports.parseColor = parseColor;
  exports.propValidators = validators;
  exports.queryElemOverlap = queryElemOverlap;
  exports.queryOverlap = queryOverlap;
  exports.render = render;
  exports.renderKarnaughMap = renderKarnaughMap;
  exports.renderKarnaughMapSkeleton = renderKarnaughMapSkeleton;
  exports.renderSkeleton = renderSkeleton;
  exports.renderUpSet = renderUpSet;
  exports.renderVennDiagram = renderVennDiagram;
  exports.renderVennDiagramSkeleton = renderVennDiagramSkeleton;
  exports.setElemIntersectionFactory = setElemIntersectionFactory;
  exports.setElemOverlap = setElemOverlap;
  exports.setElemOverlapFactory = setElemOverlapFactory;
  exports.setOverlap = setOverlap;
  exports.setOverlapFactory = setOverlapFactory;
  exports.toDump = toDump;
  exports.toIndicesArray = toIndicesArray;
  exports.toKey = toKey;
  exports.toStaticDump = toStaticDump;
  exports.toUpSetJSDump = toUpSetJSDump;
  exports.toUpSetJSStaticDump = toUpSetJSStaticDump;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
