{"version":3,"file":"index.cjs.js","sources":["../../../.yarn/cache/tslib-npm-2.3.1-0e21e18015-de17a98d46.zip/node_modules/tslib/tslib.es6.js","../../../.yarn/cache/preact-npm-10.6.4-71f87668fe-09c496bb3c.zip/node_modules/preact/dist/preact.mjs","../../../.yarn/cache/preact-npm-10.6.4-71f87668fe-09c496bb3c.zip/node_modules/preact/hooks/dist/hooks.mjs","../../../.yarn/cache/preact-npm-10.6.4-71f87668fe-09c496bb3c.zip/node_modules/preact/compat/dist/compat.module.js","../../model/dist/index.js","../../../.yarn/cache/lz-string-npm-1.4.4-59a2091d3f-54e31238a6.zip/node_modules/lz-string/libs/lz-string.js","../../../.yarn/__virtual__/@upsetjs-react-virtual-06be4ef03d/1/packages/react/dist/index.js","../../../.yarn/cache/@sgratzl-boxplots-npm-1.3.0-2ad9d2aedb-38d204c4a0.zip/node_modules/@sgratzl/boxplots/build/index.js","../../math/dist/index.js","../../../.yarn/__virtual__/@upsetjs-addons-virtual-231481f159/1/packages/addons/dist/index.js","../src/addons/boxplot.ts","../src/addons/categorical.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","var n,l,u,i,t,r,o,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,r,o,f={};for(o in u)\"key\"==o?t=u[o]:\"ref\"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return y(l,f,t,r,null)}function y(n,i,t,r,o){var f={type:n,props:i,key:t,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u:o};return null==o&&null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,r,o;n.__d&&(r=(t=(l=n).__v).__e,(o=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(o,t,i,l.__n,void 0!==o.ownerSVGElement,null!=t.__h?[r]:null,u,null==r?k(t):r,t.__h),z(u,t),t.__e!=r&&b(t)))})}function w(n,l,u,i,t,r,o,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,r,o,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),\"function\"==typeof u.type&&(u.__d=s)):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){for(var i,t=n.__k,r=0;t&&r<t.length;r++)(i=t[r])&&(i.__=n,l=\"function\"==typeof i.type?x(i,l,u):P(u,i,i,t,i.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else{for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,r),o=r}return void 0!==o?o:t.nextSibling}function C(n,l,u,i,t){var r;for(r in u)\"children\"===r||\"key\"===r||r in l||H(n,r,null,u[r],i);for(r in l)t&&\"function\"!=typeof l[r]||\"children\"===r||\"key\"===r||\"value\"===r||\"checked\"===r||u[r]===l[r]||H(n,r,l[r],u[r],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var r;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])r=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?T:I,r):n.removeEventListener(l,r?T:I,r);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink[H:h]/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,r,o,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,r,o,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,r,o,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,r,o,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(r=!0),null!=o)for(;_<o.length;_++)if((s=o[_])&&\"setAttribute\"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,o[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=r?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),o=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(o=o&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=o)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,r,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,r&&\"foreignObject\"!==d,o,f,o?o[0]:i.__k&&k(i,0),c),null!=o)for(_=o.length;_--;)null!=o[_]&&h(o[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==y.value||_!==l.value||\"progress\"===d&&!_)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,r;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(r=0;r<t.length;r++)t[r]&&N(t[r],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var r,o,f;l.__&&l.__(u,i),o=(r=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!r&&t||i).__k=v(d,null,[u]),o||e,e,void 0!==i.ownerSVGElement,!r&&t?[t]:o?null:i.firstChild?n.call(i.childNodes):null,f,!r&&t?t:o?o.__e:i.firstChild,r),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,r,o,f=a({},l.props);for(o in u)\"key\"==o?t=u[o]:\"ref\"==o?r=u[o]:f[o]=u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,r||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],r=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;export{S as render,q as hydrate,v as createElement,v as h,d as Fragment,p as createRef,i as isValidElement,_ as Component,B as cloneElement,D as createContext,A as toChildArray,l as options};\n//# sourceMappingURL=preact.module.js.map\n","import{options as n}from\"preact\";var t,u,r,o=0,i=[],c=n.__b,f=n.__r,e=n.diffed,a=n.__c,v=n.unmount;function m(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!n.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function h(r,o){var i=m(t++,4);!n.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function s(n){return o=5,d(function(){return{current:n}},[])}function _(n,t,u){o=6,h(function(){\"function\"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function q(n){var r=m(t++,10),o=l();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function x(){var t;for(i.sort(function(n,t){return n.__v.__b-t.__v.__b});t=i.pop();)if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[]}catch(u){t.__H.__h=[],n.__e(u,t.__v)}}n.__b=function(n){u=null,c&&c(n)},n.__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[])},n.diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u))})(x)),u=null},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return!n.__||j(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),a&&a(t,u)},n.unmount=function(t){v&&v(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{g(n)}catch(n){u=n}}),u&&n.__e(u,r.__v))};var b=\"function\"==typeof requestAnimationFrame;function g(n){var t=u,r=n.__c;\"function\"==typeof r&&(n.__c=void 0,r()),u=t}function j(n){var t=u;n.__c=n.__(),u=t}function k(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return\"function\"==typeof t?t(n):t}export{l as useState,p as useReducer,y as useEffect,h as useLayoutEffect,s as useRef,_ as useImperativeHandle,d as useMemo,A as useCallback,F as useContext,T as useDebugValue,q as useErrorBoundary};\n//# sourceMappingURL=hooks.module.js.map\n","import{useState as n,useReducer as t,useEffect as e,useLayoutEffect as r,useRef as u,useImperativeHandle as o,useMemo as i,useCallback as l,useContext as c,useDebugValue as f}from\"preact/hooks\";export*from\"preact/hooks\";import{Component as a,createElement as s,options as h,toChildArray as d,Fragment as v,render as p,hydrate as m,cloneElement as y,createRef as b,createContext as _}from\"preact\";export{createElement,createContext,createRef,Fragment,Component}from\"preact\";function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if(\"__source\"!==e&&!(e in t))return!0;for(var r in t)if(\"__source\"!==r&&n[r]!==t[r])return!0;return!1}function E(n){this.props=n}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,s(n,t)}return r.displayName=\"Memo(\"+(n.displayName||n.name)+\")\",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new a).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w=h.__b;h.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n)};var R=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.forward_ref\")||3911;function x(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&(\"object\"!=typeof e||\"current\"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName=\"ForwardRef(\"+(n.displayName||n.name)+\")\",t}var N=function(n,t){return null==n?null:d(d(n).map(t))},k={map:N,forEach:N,count:function(n){return n?d(n).length:0},only:function(n){var t=d(n);if(1!==t.length)throw\"Children.only\";return t[0]},toArray:d},A=h.__e;h.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A(n,t,e)};var O=h.unmount;function L(){this.__u=0,this.t=null,this.__b=null}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function F(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return s(e,u)}return u.displayName=\"Lazy\",u.__f=!0,u}function M(){this.u=null,this.o=null}h.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n)},(L.prototype=new a).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l())};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O)}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate()}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i)},L.prototype.componentWillUnmount=function(){this.t=[]},L.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement(\"div\"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){\"function\"==typeof n.__c&&n.__c()}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P)}this.__b=null}var u=t.__e&&s(v,null,n.fallback);return u&&(u.__h=null),[s(v,null,t.__e?null:n.children),u]};var T=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&(\"t\"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function D(n){return this.getChildContext=function(){return n.context},n.children}function I(n){var t=this,e=n.i;t.componentWillUnmount=function(){p(null,t.l),t.l=null,t.i=null},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n)},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n)},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n)}}),p(s(D,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount()}function W(n,t){return s(I,{__v:n,i:t})}(M.prototype=new a).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),T(t,n,r)):u()};e?e(o):o()}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=d(n.children);n.revealOrder&&\"b\"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){T(n,e,t)})};var j=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.element\")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V=\"undefined\"!=typeof document,z=function(n){return(\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function B(n,t,e){return null==t.__k&&(t.textContent=\"\"),p(n,t),\"function\"==typeof e&&e(),n?n.__c:null}function $(n,t,e){return m(n,t),\"function\"==typeof e&&e(),n?n.__c:null}a.prototype.isReactComponent={},[\"componentWillMount\",\"componentWillReceiveProps\",\"componentWillUpdate\"].forEach(function(n){Object.defineProperty(a.prototype,n,{configurable:!0,get:function(){return this[\"UNSAFE_\"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var H=h.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}h.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var G,J={configurable:!0,get:function(){return this.class}},K=h.vnode;h.vnode=function(n){var t=n.type,e=n.props,r=e;if(\"string\"==typeof t){var u=-1===t.indexOf(\"-\");for(var o in r={},e){var i=e[o];V&&\"children\"===o&&\"noscript\"===t||\"value\"===o&&\"defaultValue\"in e&&null==i||(\"defaultValue\"===o&&\"value\"in e&&null==e.value?o=\"value\":\"download\"===o&&!0===i?i=\"\":/ondoubleclick/i.test(o)?o=\"ondblclick\":/^onchange(textarea|input)/i.test(o+t)&&!z(e.type)?o=\"oninput\":/^onfocus$/i.test(o)?o=\"onfocusin\":/^onblur$/i.test(o)?o=\"onfocusout\":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,\"-$&\").toLowerCase():null===i&&(i=void 0),r[o]=i)}\"select\"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=d(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value)})),\"select\"==t&&null!=r.defaultValue&&(r.value=d(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value})),n.props=r,e.class!=e.className&&(J.enumerable=\"className\"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,\"className\",J))}n.$$typeof=j,K&&K(n)};var Q=h.__r;h.__r=function(n){Q&&Q(n),G=n.__c};var X={ReactCurrentDispatcher:{current:{readContext:function(n){return G.__n[n.__c].props.value}}}},nn=\"17.0.2\";function tn(n){return s.bind(null,n)}function en(n){return!!n&&n.$$typeof===j}function rn(n){return en(n)?y.apply(null,arguments):n}function un(n){return!!n.__k&&(p(null,n),!0)}function on(n){return n&&(n.base||1===n.nodeType&&n)||null}var ln=function(n,t){return n(t)},cn=function(n,t){return n(t)},fn=v;export default{useState:n,useReducer:t,useEffect:e,useLayoutEffect:r,useRef:u,useImperativeHandle:o,useMemo:i,useCallback:l,useContext:c,useDebugValue:f,version:\"17.0.2\",Children:k,render:B,hydrate:$,unmountComponentAtNode:un,createPortal:W,createElement:s,createContext:_,createFactory:tn,cloneElement:rn,createRef:b,Fragment:v,isValidElement:en,findDOMNode:on,Component:a,PureComponent:E,memo:g,forwardRef:x,flushSync:cn,unstable_batchedUpdates:ln,StrictMode:v,Suspense:L,SuspenseList:M,lazy:F,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:X};export{nn as version,k as Children,B as render,$ as hydrate,un as unmountComponentAtNode,W as createPortal,tn as createFactory,rn as cloneElement,en as isValidElement,on as findDOMNode,E as PureComponent,g as memo,x as forwardRef,cn as flushSync,ln as unstable_batchedUpdates,fn as StrictMode,L as Suspense,M as SuspenseList,F as lazy,X as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED};\n//# sourceMappingURL=compat.module.js.map\n","/**\n * @upsetjs/model\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2022 Samuel Gratzl <sam@sgratzl.com>\n */\n\nfunction len(a) {\r\n    return a instanceof Set ? a.size : a.length;\r\n}\r\nfunction setOverlapFactory(a, toElemKey) {\r\n    const elems = !toElemKey\r\n        ? a instanceof Set\r\n            ? a\r\n            : new Set(a)\r\n        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\r\n    const setA = elems.size;\r\n    const same = {\r\n        setA,\r\n        setB: setA,\r\n        union: setA,\r\n        intersection: setA,\r\n    };\r\n    return (b) => {\r\n        if (b === a) {\r\n            return same;\r\n        }\r\n        let intersection = 0;\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection++;\r\n            }\r\n        });\r\n        const setB = len(b);\r\n        return {\r\n            setA,\r\n            setB,\r\n            intersection,\r\n            union: setA + setB - intersection,\r\n        };\r\n    };\r\n}\r\nfunction setOverlap(a, b, toElemKey) {\r\n    if (len(a) < len(b) || a instanceof Set) {\r\n        return setOverlapFactory(a, toElemKey)(b);\r\n    }\r\n    const r = setOverlapFactory(b, toElemKey)(a);\r\n    return Object.assign({}, r, {\r\n        setA: r.setB,\r\n        setB: r.setA,\r\n    });\r\n}\r\nfunction setElemOverlapFactory(a, toElemKey) {\r\n    const elems = !toElemKey\r\n        ? a instanceof Set\r\n            ? a\r\n            : new Set(a)\r\n        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\r\n    const setA = Array.isArray(a) ? a : Array.from(a);\r\n    const same = {\r\n        setA,\r\n        setB: setA,\r\n        union: setA,\r\n        intersection: setA,\r\n    };\r\n    return (b) => {\r\n        if (b === a) {\r\n            return same;\r\n        }\r\n        const intersection = [];\r\n        const union = setA.slice();\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection.push(e);\r\n            }\r\n            else {\r\n                union.push(e);\r\n            }\r\n        });\r\n        return {\r\n            setA: setA,\r\n            setB: Array.isArray(b) ? b : Array.from(b),\r\n            intersection,\r\n            union,\r\n        };\r\n    };\r\n}\r\nfunction setElemOverlap(a, b, toElemKey) {\r\n    if (len(a) < len(b) || a instanceof Set) {\r\n        return setElemOverlapFactory(a, toElemKey)(b);\r\n    }\r\n    const r = setElemOverlapFactory(b, toElemKey)(a);\r\n    return Object.assign({}, r, {\r\n        setA: r.setB,\r\n        setB: r.setA,\r\n    });\r\n}\r\nfunction setElemIntersectionFactory(a, toElemKey) {\r\n    const arr = a instanceof Set ? Array.from(a) : a;\r\n    const elems = !toElemKey ? (a instanceof Set ? a : new Set(a)) : new Set(arr.map(toElemKey));\r\n    return (b) => {\r\n        if (b === a) {\r\n            return arr;\r\n        }\r\n        const intersection = [];\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection.push(e);\r\n            }\r\n        });\r\n        return intersection;\r\n    };\r\n}\n\nfunction isElemQuery(q) {\r\n    return Array.isArray(q.elems);\r\n}\r\nfunction isCalcQuery(q) {\r\n    return typeof q.overlap === 'function';\r\n}\r\nfunction isSetQuery(q) {\r\n    return q.set != null;\r\n}\r\nfunction queryOverlap(query, what, toElemKey) {\r\n    if (isCalcQuery(query)) {\r\n        return query.overlap;\r\n    }\r\n    if (isSetQuery(query) && query.set.overlap) {\r\n        return query.set.overlap;\r\n    }\r\n    const f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n    return (s) => {\r\n        if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {\r\n            return s.overlap(query.elems);\r\n        }\r\n        if (s.overlap && isSetQuery(query)) {\r\n            return s.overlap(query.set);\r\n        }\r\n        return f(s.elems)[what];\r\n    };\r\n}\r\nfunction queryElemOverlap(query, what, toElemKey) {\r\n    if (isCalcQuery(query)) {\r\n        return () => null;\r\n    }\r\n    if (what === 'intersection') {\r\n        const f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n        return (s) => f(s.elems);\r\n    }\r\n    const f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n    return (s) => {\r\n        return f(s.elems)[what];\r\n    };\r\n}\n\nfunction isBaseSet(v) {\r\n    const vt = v;\r\n    return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);\r\n}\r\nfunction isSet(v) {\r\n    return isBaseSet(v) && v.type === 'set';\r\n}\r\nfunction isSetCombination(v) {\r\n    const vt = v;\r\n    return (isBaseSet(v) &&\r\n        ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) &&\r\n        vt.sets instanceof Set &&\r\n        typeof vt.degree === 'number');\r\n}\r\nfunction isSetLike(v) {\r\n    return isSet(v) || isSetCombination(v);\r\n}\r\nfunction isGenerateSetCombinationOptions(v) {\r\n    const vt = v;\r\n    return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));\r\n}\r\nfunction isUpSetQuery(v) {\r\n    const vt = v;\r\n    return (v != null &&\r\n        typeof vt.name === 'string' &&\r\n        typeof vt.color === 'string' &&\r\n        (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt)));\r\n}\n\nfunction byName(a, b) {\r\n    return a.name.localeCompare(b.name);\r\n}\r\nfunction byCardinality(a, b) {\r\n    return b.cardinality - a.cardinality;\r\n}\r\nfunction byDegree(a, b) {\r\n    return a.degree - b.degree;\r\n}\r\nfunction byComposite(func) {\r\n    return (a, b) => {\r\n        return func.reduce((acc, f) => (acc === 0 ? f(a, b) : acc), 0);\r\n    };\r\n}\r\nfunction negate(func) {\r\n    return (a, b) => -func(a, b);\r\n}\r\nfunction byGroup(sets) {\r\n    return (a, b) => {\r\n        const fixNotFound = (v) => (v < 0 ? Number.POSITIVE_INFINITY : v);\r\n        const aIndex = fixNotFound(sets.findIndex((s) => a.sets.has(s)));\r\n        const bIndex = fixNotFound(sets.findIndex((s) => b.sets.has(s)));\r\n        return aIndex - bIndex;\r\n    };\r\n}\n\nfunction fromSetName(sets, symbol = /[∩∪&|]/) {\r\n    const byName = new Map(sets.map((s) => [s.name, s]));\r\n    return (s) => {\r\n        return s.name.split(symbol).map((setName) => byName.get(setName.trim()));\r\n    };\r\n}\r\nfunction toOrder$1(sets, order) {\r\n    if (!order) {\r\n        return byName;\r\n    }\r\n    const arr = (Array.isArray(order) ? order : [order]);\r\n    if (arr.length === 0) {\r\n        return byName;\r\n    }\r\n    return byComposite(arr.map((o) => {\r\n        switch (o) {\r\n            case 'cardinality':\r\n            case 'cardinality:desc':\r\n                return byCardinality;\r\n            case 'cardinality:asc':\r\n                return negate(byCardinality);\r\n            case 'name:desc':\r\n                return negate(byName);\r\n            case 'degree':\r\n            case 'degree:asc':\r\n                return byDegree;\r\n            case 'degree:desc':\r\n                return negate(byDegree);\r\n            case 'group':\r\n            case 'group:asc':\r\n                return byGroup(sets);\r\n            case 'group:desc':\r\n                return negate(byGroup(sets));\r\n            default:\r\n                return byName;\r\n        }\r\n    }));\r\n}\r\nfunction postprocessCombinations(sets, combinations, options = {}) {\r\n    let r = combinations;\r\n    if (options.order) {\r\n        r = r.sort(toOrder$1(sets, options.order));\r\n    }\r\n    if (options.limit != null) {\r\n        return r.slice(0, options.limit);\r\n    }\r\n    return r;\r\n}\r\nfunction asCombination(set, type, toSets) {\r\n    const sets = toSets(set);\r\n    return Object.assign({\r\n        type,\r\n        cardinality: set.elems.length,\r\n        sets: new Set(sets),\r\n        degree: sets.length,\r\n    }, set);\r\n}\r\nfunction asCombinations(sets, type, toSets) {\r\n    return sets.map((set) => asCombination(set, type, toSets));\r\n}\n\nconst SET_JOINERS = {\r\n    distinctIntersection: ' ∩ ',\r\n    intersection: ' ∩ ',\r\n    union: ' ∪ ',\r\n    composite: ',',\r\n};\n\nfunction parseColor(color) {\r\n    if (!color) {\r\n        return [255, 255, 255];\r\n    }\r\n    const hex = color.match(/#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})/i);\r\n    if (hex) {\r\n        return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];\r\n    }\r\n    const rgb = color.match(/\\(([\\d]+)[, ]([\\d]+)[, ]([\\d]+)\\)/i);\r\n    if (rgb) {\r\n        return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];\r\n    }\r\n    return [255, 255, 255];\r\n}\r\nfunction mergeColors(colors) {\r\n    if (colors.length === 1) {\r\n        return colors[0];\r\n    }\r\n    if (colors.every((d) => d == null)) {\r\n        return undefined;\r\n    }\r\n    const rgb = colors.map(parseColor);\r\n    const r = Math.floor(rgb.reduce((acc, v) => acc + v[0], 0) / rgb.length);\r\n    const g = Math.floor(rgb.reduce((acc, v) => acc + v[1], 0) / rgb.length);\r\n    const b = Math.floor(rgb.reduce((acc, v) => acc + v[2], 0) / rgb.length);\r\n    return `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`;\r\n}\n\nfunction generateName$1(combo, setIndex, joiner) {\r\n    const sorted = Array.from(combo).sort((a, b) => setIndex.get(a) - setIndex.get(b));\r\n    return sorted.length === 1 ? sorted[0].name : `(${sorted.map((d) => d.name).join(joiner)})`;\r\n}\r\nfunction generateSet(type, name, combo, elems, mergeColors) {\r\n    return {\r\n        type: combo.size === 0 ? 'composite' : type,\r\n        elems,\r\n        color: mergeColors(Array.from(combo).map((s) => s.color)),\r\n        sets: combo,\r\n        name,\r\n        cardinality: elems.length,\r\n        degree: combo.size,\r\n    };\r\n}\r\nfunction mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {\r\n    const merged = new Set(a.sets);\r\n    b.sets.forEach((s) => merged.add(s));\r\n    const name = generateName$1(merged, setIndex, SET_JOINERS[type]);\r\n    if (a.cardinality === 0 || b.cardinality === 0) {\r\n        return generateSet(type, name, merged, [], mergeColors);\r\n    }\r\n    let small = a;\r\n    let big = b;\r\n    if (a.cardinality > b.cardinality) {\r\n        small = b;\r\n        big = a;\r\n    }\r\n    const keySet = new Set();\r\n    const bigLookup = lookup.get(big);\r\n    const elems = [];\r\n    const l = small.elems.length;\r\n    for (let i = 0; i < l; i++) {\r\n        const e = small.elems[i];\r\n        const key = toKey(e);\r\n        if (!bigLookup.has(key)) {\r\n            continue;\r\n        }\r\n        keySet.add(key);\r\n        elems.push(e);\r\n    }\r\n    const r = generateSet(type, name, merged, elems, mergeColors);\r\n    lookup.set(r, keySet);\r\n    return r;\r\n}\r\nfunction mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {\r\n    const merged = new Set(a.sets);\r\n    b.sets.forEach((s) => merged.add(s));\r\n    const name = generateName$1(merged, setIndex, SET_JOINERS[type]);\r\n    if (a.cardinality === 0) {\r\n        const r = generateSet(type, name, merged, b.elems, mergeColors);\r\n        lookup.set(r, lookup.get(b));\r\n        return r;\r\n    }\r\n    if (b.cardinality === 0) {\r\n        const r = generateSet(type, name, merged, a.elems, mergeColors);\r\n        lookup.set(r, lookup.get(a));\r\n        return r;\r\n    }\r\n    let small = a;\r\n    let big = b;\r\n    if (a.cardinality > b.cardinality) {\r\n        small = b;\r\n        big = a;\r\n    }\r\n    const keySet = new Set(lookup.get(big));\r\n    const bigLookup = lookup.get(big);\r\n    const elems = big.elems.slice();\r\n    small.elems.forEach((e) => {\r\n        const key = toKey(e);\r\n        if (bigLookup.has(key)) {\r\n            return;\r\n        }\r\n        keySet.add(key);\r\n        elems.push(e);\r\n    });\r\n    const r = generateSet(type, name, merged, elems, mergeColors);\r\n    lookup.set(r, keySet);\r\n    return r;\r\n}\r\nfunction generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {\r\n    if (typeof notPartOfAnySet === 'number') {\r\n        return {\r\n            type: 'composite',\r\n            elems: [],\r\n            color: mergeColors ? mergeColors([]) : undefined,\r\n            sets: new Set(),\r\n            name: '()',\r\n            cardinality: notPartOfAnySet,\r\n            overlap(s) {\r\n                return s === this || (isSetLike(s) && s.name === this.name && s.cardinality === this.cardinality)\r\n                    ? this.cardinality\r\n                    : 0;\r\n            },\r\n            degree: 0,\r\n        };\r\n    }\r\n    if (Array.isArray(notPartOfAnySet)) {\r\n        return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);\r\n    }\r\n    const lookupArr = Array.from(lookup.values());\r\n    const elems = allElements.filter((e) => {\r\n        const k = toKey(e);\r\n        return lookupArr.every((s) => !s.has(k));\r\n    });\r\n    return generateSet(type, '()', new Set(), elems, mergeColors);\r\n}\r\nfunction generateCombinations(sets, options = {}) {\r\n    const { type = 'intersection', min = 0, max = Number.POSITIVE_INFINITY, empty = false, elems: allElements = [], notPartOfAnySet, toElemKey, mergeColors: mergeColors$1 = mergeColors, } = options;\r\n    const combinations = [];\r\n    const setIndex = new Map(sets.map((s, i) => [s, i]));\r\n    const setElems = new Map(sets.map((s) => [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)]));\r\n    const setDirectElems = toElemKey ? null : setElems;\r\n    const setKeyElems = toElemKey ? setElems : null;\r\n    const calc = type === 'union' ? mergeUnion : mergeIntersection;\r\n    function push(s) {\r\n        if (s.degree < min || s.degree > max || (s.cardinality === 0 && !empty)) {\r\n            return;\r\n        }\r\n        if (type !== 'distinctIntersection') {\r\n            combinations.push(s);\r\n            return;\r\n        }\r\n        const others = sets.filter((d) => !s.sets.has(d));\r\n        let elems = [];\r\n        if (toElemKey) {\r\n            const othersSets = others.map((o) => setKeyElems.get(o));\r\n            elems = s.elems.filter((e) => {\r\n                const key = toElemKey(e);\r\n                return othersSets.every((o) => !o.has(key));\r\n            });\r\n        }\r\n        else {\r\n            const othersSets = others.map((o) => setDirectElems.get(o));\r\n            elems = s.elems.filter((e) => othersSets.every((o) => !o.has(e)));\r\n        }\r\n        if (elems.length === s.cardinality) {\r\n            combinations.push(s);\r\n            return;\r\n        }\r\n        const sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);\r\n        if (sDistinct.cardinality === 0 && !empty) {\r\n            return;\r\n        }\r\n        combinations.push(sDistinct);\r\n    }\r\n    function generateLevel(arr, degree, lookup, toKey) {\r\n        if (degree > max) {\r\n            return;\r\n        }\r\n        const l = arr.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const a = arr[i];\r\n            const sub = [];\r\n            for (let j = i + 1; j < l; j++) {\r\n                const b = arr[j];\r\n                const ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);\r\n                push(ab);\r\n                if (type === 'union' || ab.cardinality > 0 || empty) {\r\n                    sub.push(ab);\r\n                }\r\n            }\r\n            if (sub.length > 1) {\r\n                generateLevel(sub, degree + 1, lookup, toKey);\r\n            }\r\n        }\r\n    }\r\n    if (min <= 0) {\r\n        if (toElemKey) {\r\n            push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));\r\n        }\r\n        else {\r\n            push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, (v) => v, mergeColors$1));\r\n        }\r\n    }\r\n    const degree1 = sets.map((s) => {\r\n        const r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);\r\n        setElems.set(r, setElems.get(s));\r\n        push(r);\r\n        return r;\r\n    });\r\n    if (toElemKey) {\r\n        generateLevel(degree1, 2, setKeyElems, toElemKey);\r\n    }\r\n    else {\r\n        generateLevel(degree1, 2, setDirectElems, (v) => v);\r\n    }\r\n    return postprocessCombinations(sets, combinations, options);\r\n}\n\nfunction asSet(set) {\r\n    return Object.assign({\r\n        type: 'set',\r\n        cardinality: set.elems.length,\r\n    }, set);\r\n}\r\nfunction toOrder(order) {\r\n    if (!order) {\r\n        return byName;\r\n    }\r\n    switch (order) {\r\n        case 'cardinality':\r\n        case 'cardinality:desc':\r\n            return byComposite([byCardinality, byName]);\r\n        case 'cardinality:asc':\r\n            return byComposite([negate(byCardinality), byName]);\r\n        case 'name:desc':\r\n            return negate(byName);\r\n        default:\r\n            return byName;\r\n    }\r\n}\r\nfunction postprocessSets(sets, options = {}) {\r\n    let r = sets;\r\n    if (options.order) {\r\n        const order = toOrder(options.order);\r\n        r = r.slice().sort(order);\r\n    }\r\n    if (options.limit != null) {\r\n        return r.slice(0, options.limit);\r\n    }\r\n    return r;\r\n}\r\nfunction asSets(sets, options = {}) {\r\n    return postprocessSets(sets.map(asSet), options);\r\n}\n\nfunction extractFromExpression(combinations, accOrOptions, o = {}) {\r\n    var _a, _b, _c;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\r\n    const joiner = (_c = options.joiner) !== null && _c !== void 0 ? _c : SET_JOINERS[type];\r\n    const sets = [];\r\n    const setLookup = new Map();\r\n    const cs = combinations.map((c) => {\r\n        const containedSets = acc(c);\r\n        const containedSetsObjects = containedSets.map((s) => {\r\n            if (setLookup.has(s)) {\r\n                return setLookup.get(s);\r\n            }\r\n            const set = {\r\n                cardinality: 0,\r\n                elems: [],\r\n                name: s,\r\n                type: 'set',\r\n            };\r\n            sets.push(set);\r\n            setLookup.set(set.name, set);\r\n            return set;\r\n        });\r\n        if (type === 'distinctIntersection') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality += c.cardinality;\r\n            }\r\n        }\r\n        else if (containedSets.length === 1) {\r\n            Object.assign(containedSetsObjects[0], {\r\n                cardinality: c.cardinality,\r\n            }, c);\r\n        }\r\n        else if (type === 'intersection') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality = Math.max(s.cardinality, c.cardinality);\r\n            }\r\n        }\r\n        else if (type === 'union') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality = Math.min(s.cardinality, c.cardinality);\r\n            }\r\n        }\r\n        const name = containedSets.join(joiner);\r\n        return Object.assign({\r\n            type,\r\n            elems: [],\r\n            name,\r\n        }, c, {\r\n            cardinality: c.cardinality,\r\n            degree: containedSets.length,\r\n            sets: new Set(containedSetsObjects),\r\n        });\r\n    });\r\n    const sortedSets = postprocessSets(sets, {\r\n        order: options.setOrder,\r\n    });\r\n    const sortedCombinations = postprocessCombinations(sortedSets, cs, {\r\n        order: options.combinationOrder,\r\n    });\r\n    return {\r\n        sets: sortedSets,\r\n        combinations: sortedCombinations,\r\n    };\r\n}\n\nfunction extractSets(elements, accOrOptions, o = {}) {\r\n    var _a;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const sets = Object.create(null);\r\n    elements.forEach((elem) => {\r\n        acc(elem).forEach((set) => {\r\n            const s = typeof set === 'string' ? set : String(set);\r\n            const r = sets[s];\r\n            if (r == null) {\r\n                sets[s] = [elem];\r\n            }\r\n            else {\r\n                r.push(elem);\r\n            }\r\n        });\r\n    });\r\n    return postprocessSets(Object.entries(sets).map(([set, elems]) => {\r\n        const r = {\r\n            type: 'set',\r\n            elems,\r\n            name: String(set),\r\n            cardinality: elems.length,\r\n        };\r\n        return r;\r\n    }), options);\r\n}\n\nfunction createTree(byDegree, getOrCreateCombination) {\r\n    const children = new Map();\r\n    byDegree\r\n        .slice()\r\n        .reverse()\r\n        .forEach((csOfDegree) => {\r\n        if (csOfDegree.length === 0 || csOfDegree[0].degree === 1) {\r\n            return;\r\n        }\r\n        csOfDegree.forEach((c) => {\r\n            const sets = Array.from(c.sets).map((d) => d.name);\r\n            for (let i = 0; i < sets.length; i++) {\r\n                const subSet = sets.slice();\r\n                subSet.splice(i, 1);\r\n                const parent = getOrCreateCombination(subSet);\r\n                if (children.has(parent)) {\r\n                    children.get(parent).push(c);\r\n                }\r\n                else {\r\n                    children.set(parent, [c]);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return children;\r\n}\r\nfunction extractCombinations(elements, accOrOptions, o = {}) {\r\n    var _a, _b, _c, _d;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\r\n    const sets = (_c = options.sets) !== null && _c !== void 0 ? _c : extractSets(elements, acc, {\r\n        limit: options.setLimit,\r\n        order: options.setOrder,\r\n    });\r\n    if (type === 'union') {\r\n        return {\r\n            sets,\r\n            combinations: generateCombinations(sets, {\r\n                type: 'union',\r\n                limit: options.combinationLimit,\r\n                order: options.combinationOrder,\r\n            }),\r\n        };\r\n    }\r\n    const setLookup = Object.create(null);\r\n    sets.forEach((set, i) => {\r\n        setLookup[set.name] = [set, i];\r\n    });\r\n    const isSortedAlphabetically = sets\r\n        .map((d) => d.name)\r\n        .sort()\r\n        .every((d, i) => sets[i].name === d);\r\n    const bySet = isSortedAlphabetically\r\n        ? undefined\r\n        : (a, b) => {\r\n            var _a, _b, _c, _d;\r\n            const ai = (_b = (_a = setLookup[a]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : -1;\r\n            const bi = (_d = (_c = setLookup[b]) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : -1;\r\n            return ai - bi;\r\n        };\r\n    const validSet = options.sets == null && options.setLimit == null ? null : new Set(sets.map((d) => d.name));\r\n    const joiner = (_d = options.joiner) !== null && _d !== void 0 ? _d : SET_JOINERS[type];\r\n    const cs = [];\r\n    const csLookup = Object.create(null);\r\n    const byDegree = Array(sets.length + 1)\r\n        .fill(0)\r\n        .map((_) => []);\r\n    function genName(setsOfElem) {\r\n        switch (setsOfElem.length) {\r\n            case 0:\r\n                return '()';\r\n            case 1:\r\n                return setsOfElem[0];\r\n            default:\r\n                const sorted = setsOfElem.slice().sort(bySet);\r\n                const joined = sorted.join(joiner);\r\n                return '(' + joined + ')';\r\n        }\r\n    }\r\n    function genKey(setsOfElem) {\r\n        switch (setsOfElem.length) {\r\n            case 0:\r\n                return '';\r\n            case 1:\r\n                return setsOfElem[0];\r\n            case 2: {\r\n                if ((bySet != null && bySet(setsOfElem[0], setsOfElem[1]) > 0) ||\r\n                    (bySet == null && setsOfElem[1] > setsOfElem[0])) {\r\n                    return setsOfElem[1] + '&' + setsOfElem[0];\r\n                }\r\n                return setsOfElem[0] + '&' + setsOfElem[1];\r\n            }\r\n            default:\r\n                const sorted = setsOfElem.slice().sort(bySet);\r\n                return sorted.join('&');\r\n        }\r\n    }\r\n    function getOrCreateCombination(setsOfElem) {\r\n        const key = genKey(setsOfElem);\r\n        const entry = csLookup[key];\r\n        if (entry) {\r\n            return entry;\r\n        }\r\n        const newEntry = {\r\n            type,\r\n            name: genName(setsOfElem),\r\n            degree: setsOfElem.length,\r\n            sets: new Set(setsOfElem.map((s) => setLookup[s][0])),\r\n            cardinality: 0,\r\n            elems: [],\r\n        };\r\n        csLookup[key] = newEntry;\r\n        cs.push(newEntry);\r\n        byDegree[newEntry.degree].push(newEntry);\r\n        return newEntry;\r\n    }\r\n    elements.forEach((elem) => {\r\n        let setsOfElem = acc(elem);\r\n        if (validSet) {\r\n            setsOfElem = setsOfElem.filter((d) => validSet.has(d));\r\n        }\r\n        const c = getOrCreateCombination(setsOfElem);\r\n        c.elems.push(elem);\r\n        c.cardinality++;\r\n    });\r\n    const finalize = () => {\r\n        return {\r\n            sets,\r\n            combinations: postprocessCombinations(sets, cs, {\r\n                order: options.combinationOrder,\r\n                limit: options.combinationLimit,\r\n            }),\r\n        };\r\n    };\r\n    if (type === 'distinctIntersection') {\r\n        return finalize();\r\n    }\r\n    const children = createTree(byDegree, getOrCreateCombination);\r\n    function visit(node, visited, agg) {\r\n        var _a;\r\n        if (visited.has(node)) {\r\n            return;\r\n        }\r\n        visited.add(node);\r\n        if (node.elems.length < 1000) {\r\n            agg[0].push(...node.elems);\r\n        }\r\n        else {\r\n            agg.push(node.elems);\r\n        }\r\n        ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => visit(child, visited, agg));\r\n    }\r\n    byDegree.slice(1).forEach((level) => {\r\n        level.forEach((node) => {\r\n            var _a;\r\n            const visited = new Set();\r\n            const agg = [node.elems];\r\n            ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => {\r\n                visit(child, visited, agg);\r\n            });\r\n            const elems = agg.length === 1 ? agg[0] : agg.flat();\r\n            Object.assign(node, { elems, cardinality: elems.length });\r\n        });\r\n    });\r\n    return finalize();\r\n}\n\nfunction toKey(s) {\r\n    return `${s.name}:${s.type}#${s.cardinality}`;\r\n}\n\nfunction isUniverse(s) {\r\n    return s.sets.size === 0;\r\n}\r\nfunction common(a, b, toKey$1 = toKey) {\r\n    const r = {\r\n        done: null,\r\n        aKey: '',\r\n        bKey: '',\r\n        aIsSet: false,\r\n        bIsSet: false,\r\n        toKey: toKey$1,\r\n    };\r\n    if (a === b) {\r\n        r.done = a.cardinality;\r\n        return r;\r\n    }\r\n    if (a.cardinality === 0 || b.cardinality === 0) {\r\n        r.done = 0;\r\n        return r;\r\n    }\r\n    r.aKey = toKey$1(a);\r\n    r.bKey = toKey$1(b);\r\n    if (r.aKey === r.bKey) {\r\n        r.done = a.cardinality;\r\n        return r;\r\n    }\r\n    r.aIsSet = isSet(a);\r\n    r.bIsSet = isSet(b);\r\n    if ((!r.aIsSet && isUniverse(a)) || (!r.bIsSet && isUniverse(b))) {\r\n        r.done = 0;\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\nfunction aInB(b, r) {\r\n    if (r.bIsSet || !r.aIsSet) {\r\n        return false;\r\n    }\r\n    return Array.from(b.sets)\r\n        .map(r.toKey)\r\n        .includes(r.aKey);\r\n}\r\nfunction bInA(a, r) {\r\n    if (!r.bIsSet || r.aIsSet) {\r\n        return false;\r\n    }\r\n    return Array.from(a.sets)\r\n        .map(r.toKey)\r\n        .includes(r.bKey);\r\n}\r\nfunction keyedCombinations(combinations, toKey$1 = toKey) {\r\n    return combinations.map((c) => {\r\n        const s = Array.from(c.sets).map(toKey$1).sort();\r\n        return {\r\n            key: s.join('&'),\r\n            s,\r\n            sets: new Set(s),\r\n            degree: c.degree,\r\n            cardinality: c.cardinality,\r\n        };\r\n    });\r\n}\r\nfunction combinedKey(a, b, r) {\r\n    const sets = new Set();\r\n    if (r.aIsSet) {\r\n        sets.add(r.aKey);\r\n    }\r\n    else {\r\n        for (const s of Array.from(a.sets)) {\r\n            sets.add(r.toKey(s));\r\n        }\r\n    }\r\n    if (r.bIsSet) {\r\n        sets.add(r.bKey);\r\n    }\r\n    else {\r\n        for (const s of Array.from(b.sets)) {\r\n            sets.add(r.toKey(s));\r\n        }\r\n    }\r\n    return Array.from(sets).sort().join('&');\r\n}\r\nfunction generateDistinctOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsBySet = new Map();\r\n    for (const c of keyedCombinations(combinations, toKey$1)) {\r\n        for (const s of c.s) {\r\n            if (combinationsBySet.has(s)) {\r\n                combinationsBySet.get(s).push(c);\r\n            }\r\n            else {\r\n                combinationsBySet.set(s, [c]);\r\n            }\r\n        }\r\n    }\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (!r.aIsSet && !r.bIsSet) {\r\n            return 0;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet) {\r\n            return aInB(b, r) ? b.cardinality : 0;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet) {\r\n            return bInA(a, r) ? a.cardinality : 0;\r\n        }\r\n        const hasA = combinationsBySet.get(r.aKey);\r\n        const hasB = combinationsBySet.get(r.bKey);\r\n        if (!hasA || !hasB) {\r\n            return fallback(a, b);\r\n        }\r\n        if (hasA.length < hasB.length) {\r\n            return hasA.reduce((acc, c) => acc + (c.sets.has(r.bKey) ? c.cardinality : 0), 0);\r\n        }\r\n        return hasB.reduce((acc, c) => acc + (c.sets.has(r.aKey) ? c.cardinality : 0), 0);\r\n    };\r\n}\r\nfunction generateIntersectionOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\r\n            return b.cardinality;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\r\n            return a.cardinality;\r\n        }\r\n        const key = combinedKey(a, b, r);\r\n        if (!combinationsByKey.has(key)) {\r\n            return fallback(a, b);\r\n        }\r\n        return combinationsByKey.get(key);\r\n    };\r\n}\r\nfunction generateUnionOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\r\n            return a.cardinality;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\r\n            return b.cardinality;\r\n        }\r\n        const key = combinedKey(a, b, r);\r\n        if (!combinationsByKey.has(key)) {\r\n            return fallback(a, b);\r\n        }\r\n        return a.cardinality + b.cardinality - combinationsByKey.get(key);\r\n    };\r\n}\r\nfunction generateOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    if (combinations.length === 0) {\r\n        return fallback;\r\n    }\r\n    const firstType = combinations[0].type;\r\n    if (combinations.some((s) => s.type !== firstType)) {\r\n        return fallback;\r\n    }\r\n    switch (firstType) {\r\n        case 'union':\r\n            return generateUnionOverlapFunction(combinations, fallback, toKey$1);\r\n        case 'intersection':\r\n            return generateIntersectionOverlapFunction(combinations, fallback, toKey$1);\r\n        case 'distinctIntersection':\r\n            return generateDistinctOverlapFunction(combinations, fallback, toKey$1);\r\n    }\r\n    return fallback;\r\n}\n\nfunction compressLine(line) {\r\n    if (line.length === 0) {\r\n        return '';\r\n    }\r\n    const r = [];\r\n    let start = line[0];\r\n    let len = 1;\r\n    for (let i = 1; i < line.length; i++) {\r\n        const v = line[i];\r\n        if (v === start) {\r\n            len++;\r\n        }\r\n        else {\r\n            if (len > 1) {\r\n                r.push(`${start}=${len - 1}`);\r\n            }\r\n            else if (start === 0) {\r\n                r.push('');\r\n            }\r\n            else {\r\n                r.push(start.toString());\r\n            }\r\n            start = v;\r\n            len = 1;\r\n        }\r\n    }\r\n    if (len > 1) {\r\n        r.push(`${start}=${len}`);\r\n    }\r\n    else if (start === 0) {\r\n        r.push('');\r\n    }\r\n    else {\r\n        r.push(start.toString());\r\n    }\r\n    return r.join(',');\r\n}\r\nfunction decompressLine(line) {\r\n    if (line.length === 0) {\r\n        return [];\r\n    }\r\n    return line\r\n        .split(',')\r\n        .map((v) => {\r\n        if (v === '') {\r\n            return 0;\r\n        }\r\n        if (v.includes('=')) {\r\n            const [value, length] = v.split('=').map((v) => Number.parseInt(v, 10));\r\n            return Array(length + 1).fill(value);\r\n        }\r\n        return Number.parseInt(v, 10);\r\n    })\r\n        .flat();\r\n}\r\nfunction compressMatrix(matrix) {\r\n    if (matrix.length === 0) {\r\n        return '';\r\n    }\r\n    const rows = matrix.length;\r\n    const flat = matrix.flat();\r\n    return `${rows};${compressLine(flat)}`;\r\n}\r\nfunction decompressMatrix(matrix) {\r\n    if (matrix.length === 0) {\r\n        return [];\r\n    }\r\n    const [rowsInfo, data] = matrix.split(';');\r\n    const rows = Number.parseInt(rowsInfo, 10);\r\n    const values = decompressLine(data);\r\n    const r = [];\r\n    let acc = 0;\r\n    for (let i = rows; i > 0; i--) {\r\n        r.push(values.slice(acc, acc + i));\r\n        acc += i;\r\n    }\r\n    return r;\r\n}\r\nfunction generateOverlapLookup(sets, combinations, { toElemKey, what = 'intersection', compress = 'auto' } = {}) {\r\n    const data = sets.concat(combinations);\r\n    function overlapF(set) {\r\n        if (set.overlap) {\r\n            return set.overlap;\r\n        }\r\n        const f = setOverlapFactory(set.elems, toElemKey);\r\n        return (v) => {\r\n            if (v.overlap) {\r\n                return v.overlap(set);\r\n            }\r\n            return f(v.elems)[what];\r\n        };\r\n    }\r\n    const matrix = data.map((set, i) => {\r\n        const overlap = overlapF(set);\r\n        const r = [];\r\n        for (let j = i + 1; j < data.length; j++) {\r\n            r.push(overlap(data[j]));\r\n        }\r\n        return r;\r\n    });\r\n    matrix.pop();\r\n    if (compress === 'no') {\r\n        return matrix;\r\n    }\r\n    const compressed = compressMatrix(matrix);\r\n    if (compress === 'yes') {\r\n        return compressed;\r\n    }\r\n    const encodedLength = JSON.stringify(matrix).length;\r\n    const compressedLength = compressed.length + 2;\r\n    return compressedLength < encodedLength * 0.6 ? compressed : matrix;\r\n}\r\nfunction generateOverlapLookupFunction(matrix, sets, combinations, toKey$1 = toKey) {\r\n    const lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;\r\n    const setIndex = new Map(sets.map((set, i) => [toKey$1(set), i]));\r\n    const combinationIndex = new Map(combinations.map((set, i) => [toKey$1(set), i + sets.length]));\r\n    const compute = (a, b) => {\r\n        if (a === b) {\r\n            return a.cardinality;\r\n        }\r\n        const aKey = toKey$1(a);\r\n        const bKey = toKey$1(b);\r\n        const aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);\r\n        const bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);\r\n        if (aIndex === bIndex) {\r\n            return a.cardinality;\r\n        }\r\n        const row = Math.min(aIndex, bIndex);\r\n        const col = Math.max(aIndex, bIndex) - row - 1;\r\n        if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {\r\n            return 0;\r\n        }\r\n        return lookup[row][col];\r\n    };\r\n    return {\r\n        setIndex,\r\n        compute,\r\n        combinationIndex,\r\n    };\r\n}\n\nconst bandScale = (domain, size, padding) => {\r\n    const blocks = domain.length + padding;\r\n    const step = size / Math.max(1, blocks);\r\n    const start = size - step * domain.length;\r\n    const lookup = new Map(domain.map((d, i) => [d, i]));\r\n    const bandwidth = step / (1 + padding);\r\n    const scale = (v) => {\r\n        const index = lookup.get(v);\r\n        if (index == null) {\r\n            return undefined;\r\n        }\r\n        return start + step * index;\r\n    };\r\n    scale.bandwidth = () => bandwidth;\r\n    return scale;\r\n};\n\nfunction hasOverlap(positions, heights, stride = 1) {\r\n    for (let i = 0; i < positions.length - stride; i += stride) {\r\n        const pos_i = positions[i];\r\n        const pos_n = positions[i + 1];\r\n        if (pos_i < pos_n) {\r\n            const right = pos_i + heights[i] / 2;\r\n            const left = pos_n - heights[i + 1] / 2;\r\n            if (right > left) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            const left = pos_i - heights[i] / 2;\r\n            const right = pos_n + heights[i + 1] / 2;\r\n            if (right > left) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction ensureLast(ticks, max, scale, heightPerTick, toStr) {\r\n    let last = ticks[ticks.length - 1];\r\n    if (!last.label) {\r\n        for (let j = ticks.length - 2; j > 0; --j) {\r\n            if (ticks[j].label) {\r\n                last = ticks[j];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (last.value < max) {\r\n        const pos_l = scale(last.value);\r\n        const pos_max = scale(max);\r\n        if (pos_l < pos_max) {\r\n            const right = pos_l + heightPerTick(last.value) / 2;\r\n            const left = pos_max - heightPerTick(max) / 2;\r\n            if (right < left) {\r\n                ticks.push({ value: max, label: toStr(max) });\r\n            }\r\n        }\r\n        else {\r\n            const left = pos_l - heightPerTick(last.value) / 2;\r\n            const right = pos_max + heightPerTick(max) / 2;\r\n            if (right < left) {\r\n                ticks.push({ value: max, label: toStr(max) });\r\n            }\r\n        }\r\n    }\r\n    return ticks;\r\n}\r\nfunction genTicks(values, toStr = String, stride = 1) {\r\n    return values.map((v, i) => ({\r\n        value: v,\r\n        label: stride === 1 || i % stride === 0 ? toStr(v) : undefined,\r\n    }));\r\n}\r\nfunction checkValues(values, scale, heightPerTick, max, toStr) {\r\n    const positions = values.map((v) => scale(v));\r\n    const heights = values.map((v) => heightPerTick(v));\r\n    if (!hasOverlap(positions, heights)) {\r\n        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\r\n    }\r\n    if (!hasOverlap(positions, heights, 2)) {\r\n        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\r\n    }\r\n    return null;\r\n}\n\nfunction toStr$1(v) {\r\n    return v.toLocaleString();\r\n}\r\nfunction niceFactors(max, maxCount = 11) {\r\n    const digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));\r\n    const factor = Math.pow(10, digits);\r\n    const factors = [1, 2, 5];\r\n    const r = factors.map((f) => f * factor);\r\n    if (digits > 0) {\r\n        r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));\r\n    }\r\n    r.push(factors[0] * Math.pow(10, digits + 1));\r\n    const lower = Math.ceil(max / maxCount);\r\n    return r.filter((d) => d >= lower && d <= max);\r\n}\r\nfunction range$1(max, inc = 1) {\r\n    const values = [];\r\n    for (let v = 0; v <= max; v += inc) {\r\n        values.push(v);\r\n    }\r\n    return values;\r\n}\r\nfunction distributeTicks$1(max, maxCount, scale, heightPerTick) {\r\n    if (maxCount <= 0) {\r\n        return [];\r\n    }\r\n    const factors = niceFactors(max, maxCount);\r\n    for (let i = 0; i < factors.length; i++) {\r\n        const values = range$1(max, factors[i]);\r\n        const r = checkValues(values, scale, heightPerTick, max, toStr$1);\r\n        if (r) {\r\n            return r;\r\n        }\r\n    }\r\n    return genTicks([0, max], toStr$1);\r\n}\r\nconst linearScale = (max, range, options) => {\r\n    const size = range[1] - range[0];\r\n    const domain = max;\r\n    const scale = (v) => {\r\n        const cv = Math.max(0, Math.min(v, domain));\r\n        const n = cv / domain;\r\n        return range[0] + n * size;\r\n    };\r\n    scale.ticks = (count = 10) => {\r\n        if (options.orientation === 'vertical') {\r\n            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\r\n            return distributeTicks$1(max, count + 1, scale, () => heightPerTick);\r\n        }\r\n        const widthPerChar = options.fontSizeHint / 1.4;\r\n        return distributeTicks$1(max, count + 1, scale, (v) => Math.ceil(toStr$1(v).length * widthPerChar));\r\n    };\r\n    scale.tickFormat = () => toStr$1;\r\n    return scale;\r\n};\n\nfunction toStr(v) {\r\n    const orders = ['', 'k', 'M', 'G'];\r\n    const order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));\r\n    const vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;\r\n    return `${vi.toLocaleString()}${orders[order]}`;\r\n}\r\nfunction range(max, factor) {\r\n    const values = [];\r\n    const inc = Math.pow(10, factor);\r\n    for (let v = 1; v <= max; v *= inc) {\r\n        values.push(v);\r\n    }\r\n    return values;\r\n}\r\nfunction generateInnerTicks(max, factor) {\r\n    const values = [];\r\n    const inc = 10;\r\n    for (let v = 1, i = 0; v <= max; v *= inc, i++) {\r\n        values.push({\r\n            value: v,\r\n            label: factor === 1 || i % factor === 0 ? toStr(v) : undefined,\r\n        });\r\n        for (let vv = v + v; vv < v * inc && vv < max; vv += v * factor) {\r\n            values.push({ value: vv });\r\n        }\r\n    }\r\n    return values;\r\n}\r\nfunction distributeTicks(max, maxCount, scale, heightPerTick) {\r\n    if (maxCount <= 0) {\r\n        return [];\r\n    }\r\n    for (const factor of [1, 2, 5]) {\r\n        const values = range(max, factor);\r\n        const r = checkValues(values, scale, heightPerTick, max, toStr);\r\n        if (r) {\r\n            return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr);\r\n        }\r\n    }\r\n    return genTicks([0, max], toStr);\r\n}\r\nconst logScale = (max, range, options) => {\r\n    const size = range[1] - range[0];\r\n    const domain = max < 1 ? 1 : Math.log10(max);\r\n    const scale = (v) => {\r\n        const cv = Math.max(0, Math.min(v, domain));\r\n        const n = cv <= 1 ? 0 : Math.log10(cv) / domain;\r\n        return range[0] + n * size;\r\n    };\r\n    scale.ticks = (count = 10) => {\r\n        if (options.orientation === 'vertical') {\r\n            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\r\n            return distributeTicks(max, count + 1, scale, () => heightPerTick);\r\n        }\r\n        const widthPerChar = options.fontSizeHint / 1.4;\r\n        return distributeTicks(max, count + 1, scale, (v) => Math.ceil(toStr(v).length * widthPerChar));\r\n    };\r\n    scale.tickFormat = () => toStr;\r\n    return scale;\r\n};\n\nfunction compressIndicesArray(arr) {\r\n    if (arr.length === 0) {\r\n        return '';\r\n    }\r\n    const encoded = [];\r\n    let startIndex = 0;\r\n    const push = (i) => {\r\n        if (i === startIndex + 1) {\r\n            encoded.push(arr[startIndex].toString());\r\n        }\r\n        else if (i === startIndex + 2 && i < 10) {\r\n            encoded.push(`${arr[startIndex]},${arr[startIndex + 1]}`);\r\n        }\r\n        else {\r\n            encoded.push(`${arr[startIndex]}+${i - startIndex - 1}`);\r\n        }\r\n        return i;\r\n    };\r\n    for (let i = 1; i < arr.length; i++) {\r\n        const expected = arr[i - 1] + 1;\r\n        const v = arr[i];\r\n        if (v !== expected) {\r\n            startIndex = push(i);\r\n            startIndex = i;\r\n        }\r\n    }\r\n    push(arr.length);\r\n    return encoded.join(',');\r\n}\r\nfunction toIndicesArray(arr, toIndex, { sortAble, compress = 'auto' } = {}) {\r\n    if (arr.length === 0) {\r\n        return [];\r\n    }\r\n    const base = arr.map((v) => toIndex(v));\r\n    if (compress === 'no') {\r\n        return base;\r\n    }\r\n    if (sortAble) {\r\n        base.sort((a, b) => a - b);\r\n    }\r\n    const encoded = compressIndicesArray(base);\r\n    const baseLength = JSON.stringify(base).length;\r\n    const encodedLength = encoded.length + 2;\r\n    if (encodedLength < baseLength * 0.6 ||\r\n        baseLength - encodedLength > 50 ||\r\n        (compress === 'yes' && encodedLength < baseLength)) {\r\n        return encoded;\r\n    }\r\n    return base;\r\n}\r\nfunction fromIndicesArray(indices, elements) {\r\n    if (typeof indices === 'string') {\r\n        if (indices.length === 0) {\r\n            return [];\r\n        }\r\n        return indices\r\n            .split(',')\r\n            .map((s) => {\r\n            if (s.includes('+')) {\r\n                const [start, length] = s.split('+').map((si) => Number.parseInt(si, 10));\r\n                return elements.slice(start, start + length + 1);\r\n            }\r\n            return elements[Number.parseInt(s, 10)];\r\n        })\r\n            .flat();\r\n    }\r\n    return indices.map((i) => elements[i]);\r\n}\n\nfunction withColor(v, s) {\r\n    if (s.color) {\r\n        v.color = s.color;\r\n    }\r\n    return v;\r\n}\n\nfunction fromDump(dump, elems, options = {}) {\r\n    const sets = dump.sets.map((set) => asSet(Object.assign(Object.assign({}, set), { elems: fromIndicesArray(set.elems, elems) })));\r\n    const gen = () => {\r\n        var _a;\r\n        return generateCombinations(sets, Object.assign({ type: 'intersection', elems, toElemKey: options.toElemKey }, (_a = dump.combinationOptions) !== null && _a !== void 0 ? _a : {}));\r\n    };\r\n    const combinations = dump.combinations\r\n        ? dump.combinations.map((c) => asCombination(Object.assign(Object.assign({}, c), { elems: fromIndicesArray(c.elems, elems) }), c.type, (v) => v.sets.map((i) => sets[i])))\r\n        : gen();\r\n    function fromSetRef(ref) {\r\n        if (ref.type === 'set') {\r\n            return sets[ref.index];\r\n        }\r\n        return combinations[ref.index];\r\n    }\r\n    return {\r\n        sets,\r\n        combinations,\r\n        selection: dump.selection\r\n            ? typeof dump.selection === 'string' || Array.isArray(dump.selection)\r\n                ? fromIndicesArray(dump.selection, elems)\r\n                : fromSetRef(dump.selection)\r\n            : undefined,\r\n        queries: dump.queries.map((query) => {\r\n            if (query.set) {\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: fromSetRef(query.set),\r\n                };\r\n            }\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                elems: fromIndicesArray(query.elems, elems),\r\n            };\r\n        }),\r\n    };\r\n}\r\nfunction toDump(data, config = {}) {\r\n    var _a;\r\n    const indicesOptions = Object.assign({ sortAble: true }, config);\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\r\n    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\r\n    const toSetRef = (s) => {\r\n        if (s.type === 'set') {\r\n            return {\r\n                type: s.type,\r\n                index: bySetKey.get(toKey$1(s)),\r\n            };\r\n        }\r\n        const index = byCombinationKey.get(toKey$1(s));\r\n        if (index == null || index < 0) {\r\n            return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);\r\n        }\r\n        return {\r\n            type: s.type,\r\n            index,\r\n        };\r\n    };\r\n    const setLookup = data.sets.map((s, i) => ({\r\n        key: toKey$1(s),\r\n        i,\r\n    }));\r\n    return {\r\n        sets: data.sets.map((set) => withColor({\r\n            name: set.name,\r\n            cardinality: set.cardinality,\r\n            elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions),\r\n        }, set)),\r\n        combinations: config.compress === 'no'\r\n            ? data.combinations.map((c) => {\r\n                const setKeys = new Set(Array.from(c.sets).map(toKey$1));\r\n                return withColor({\r\n                    name: c.name,\r\n                    type: c.type,\r\n                    cardinality: c.cardinality,\r\n                    degree: c.degree,\r\n                    sets: setLookup.filter(({ key }) => setKeys.has(key)).map(({ i }) => i),\r\n                    elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions),\r\n                }, c);\r\n            })\r\n            : undefined,\r\n        combinationOptions: data.combinationOptions,\r\n        selection: data.selection\r\n            ? Array.isArray(data.selection)\r\n                ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions)\r\n                : toSetRef(data.selection)\r\n            : undefined,\r\n        queries: data.queries.map((query) => {\r\n            const elems = isSetQuery(query)\r\n                ? toSetRef(query.set)\r\n                : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,\r\n                elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined,\r\n            };\r\n        }),\r\n    };\r\n}\n\nfunction generateName(sets, type) {\r\n    if (sets.length === 1) {\r\n        return sets[0].name;\r\n    }\r\n    return `(${sets.map((set) => set.name).join(SET_JOINERS[type])})`;\r\n}\r\nfunction toStaticDump(data, config = {}) {\r\n    var _a;\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\r\n    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\r\n    const toSelectionSetRef = (s) => {\r\n        if (isSetLike(s)) {\r\n            if (s.type === 'set') {\r\n                return {\r\n                    type: s.type,\r\n                    index: bySetKey.get(toKey$1(s)),\r\n                };\r\n            }\r\n            const index = byCombinationKey.get(toKey$1(s));\r\n            if (index != null && index >= 0) {\r\n                return {\r\n                    type: s.type,\r\n                    index,\r\n                };\r\n            }\r\n        }\r\n        const overlapF = setOverlapFactory(isSetLike(s) ? s.elems : s);\r\n        return data.sets\r\n            .map((set) => overlapF(set.elems).intersection)\r\n            .concat(data.combinations.map((set) => overlapF(set.elems).intersection));\r\n    };\r\n    const setIndex = new Map(data.sets.map((set, i) => [toKey$1(set), i]));\r\n    const overlaps = generateOverlapLookup(data.sets, data.combinations, config);\r\n    const shortNames = config.compress === 'yes';\r\n    const compressCombination = (set) => {\r\n        const partOf = Array.from(set.sets)\r\n            .map((s) => setIndex.get(toKey$1(s)))\r\n            .sort((a, b) => a - b);\r\n        const r = {\r\n            c: set.cardinality,\r\n            s: partOf.reduce((acc, i) => acc + Math.pow(2, i), 0),\r\n        };\r\n        if (set.name !==\r\n            generateName(partOf.map((i) => data.sets[i]), set.type)) {\r\n            r.n = set.name;\r\n        }\r\n        if (set.type !== 'intersection') {\r\n            r.type = set.type[0];\r\n        }\r\n        if (set.color) {\r\n            r.cc = set.color;\r\n        }\r\n        return r;\r\n    };\r\n    return {\r\n        sets: shortNames\r\n            ? data.sets.map((set) => ({ n: set.name, cc: set.color, c: set.cardinality }))\r\n            : data.sets.map((set) => withColor({ name: set.name, cardinality: set.cardinality }, set)),\r\n        combinations: shortNames\r\n            ? data.combinations.map(compressCombination)\r\n            : data.combinations.map((set) => withColor({\r\n                name: set.name,\r\n                cardinality: set.cardinality,\r\n                type: set.type,\r\n                sets: Array.from(set.sets)\r\n                    .map((s) => setIndex.get(toKey$1(s)))\r\n                    .sort((a, b) => a - b),\r\n            }, set)),\r\n        overlaps,\r\n        selection: data.selection ? toSelectionSetRef(data.selection) : undefined,\r\n        queries: data.queries.map((query) => {\r\n            if (isSetQuery(query)) {\r\n                const ref = toSelectionSetRef(query.set);\r\n                if (Array.isArray(ref)) {\r\n                    return {\r\n                        name: query.name,\r\n                        color: query.color,\r\n                        overlaps: ref,\r\n                    };\r\n                }\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: ref,\r\n                };\r\n            }\r\n            const overlapF = setOverlapFactory(query.elems);\r\n            const overlaps = data.sets\r\n                .map((set) => overlapF(set.elems).intersection)\r\n                .concat(data.combinations.map((set) => overlapF(set.elems).intersection));\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                overlaps,\r\n            };\r\n        }),\r\n    };\r\n}\r\nfunction isCompressed(s) {\r\n    return typeof s.c === 'number';\r\n}\r\nfunction isCompressedSet(s) {\r\n    return typeof s.c === 'number';\r\n}\r\nfunction fromStaticDump(dump, config = {}) {\r\n    var _a;\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    let computeF = () => 0;\r\n    function withOverlap(s) {\r\n        s.overlap = (b) => computeF(s, b);\r\n        return s;\r\n    }\r\n    const sets = dump.sets.map((set) => withOverlap({\r\n        name: isCompressedSet(set) ? set.n : set.name,\r\n        cardinality: isCompressedSet(set) ? set.c : set.cardinality,\r\n        type: 'set',\r\n        elems: [],\r\n    }));\r\n    const fromBit = (v) => {\r\n        return sets.filter((_, i) => {\r\n            const position = Math.pow(2, i);\r\n            return (v & position) === position;\r\n        });\r\n    };\r\n    const combinations = dump.combinations.map((set) => {\r\n        var _a, _b;\r\n        const partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map((i) => sets[i]);\r\n        const lookup = {\r\n            i: 'intersection',\r\n            u: 'union',\r\n            c: 'composite',\r\n            d: 'distinctIntersection',\r\n        };\r\n        const type = lookup[((_a = set.type) !== null && _a !== void 0 ? _a : 'i')[0]];\r\n        return withOverlap({\r\n            name: isCompressed(set) ? (_b = set.n) !== null && _b !== void 0 ? _b : generateName(partOf, type) : set.name,\r\n            cardinality: isCompressed(set) ? set.c : set.cardinality,\r\n            type,\r\n            degree: partOf.length,\r\n            sets: new Set(partOf),\r\n            elems: [],\r\n        });\r\n    });\r\n    const { setIndex, combinationIndex, compute } = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1);\r\n    computeF = compute;\r\n    function fromSetRef(ref) {\r\n        if (ref.type === 'set') {\r\n            return sets[ref.index];\r\n        }\r\n        return combinations[ref.index];\r\n    }\r\n    function generateOverlap(lookup) {\r\n        return (v) => {\r\n            const key = toKey$1(v);\r\n            const index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);\r\n            return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];\r\n        };\r\n    }\r\n    return {\r\n        sets,\r\n        combinations,\r\n        selection: dump.selection\r\n            ? Array.isArray(dump.selection)\r\n                ? generateOverlap(dump.selection)\r\n                : fromSetRef(dump.selection)\r\n            : undefined,\r\n        queries: dump.queries.map((query) => {\r\n            if (query.set) {\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: fromSetRef(query.set),\r\n                };\r\n            }\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                overlap: generateOverlap(query.overlaps),\r\n            };\r\n        }),\r\n    };\r\n}\n\nexport { SET_JOINERS, asCombination, asCombinations, asSet, asSets, bandScale, extractCombinations, extractFromExpression, extractSets, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, generateDistinctOverlapFunction, generateIntersectionOverlapFunction, generateOverlapFunction, generateOverlapLookup, generateOverlapLookupFunction, generateUnionOverlapFunction, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, queryElemOverlap, queryOverlap, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump };\n//# sourceMappingURL=index.js.map\n","// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (typeof define === 'function' && define.amd) {\n  define(function () { return LZString; });\n} else if( typeof module !== 'undefined' && module != null ) {\n  module.exports = LZString\n}\n","/**\n * @upsetjs/react\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2022 Samuel Gratzl <sam@sgratzl.com>\n */\n\nimport React, { useRef, useState, useLayoutEffect, useMemo, useCallback } from 'react';\nimport { toKey, toDump, isElemQuery, isSetQuery, isSetLike as isSetLike$1, toStaticDump, setElemOverlapFactory, setOverlapFactory, generateCombinations, generateOverlapFunction, bandScale as bandScale$1, linearScale, logScale, queryOverlap, queryElemOverlap, generateDistinctOverlapFunction, isSet, isSetCombination, isGenerateSetCombinationOptions, isUpSetQuery } from '@upsetjs/model';\nexport * from '@upsetjs/model';\nimport LZString from 'lz-string';\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction extractStyleId(node) {\r\n    return Array.from(node.classList)\r\n        .find((d) => d.startsWith('root-'))\r\n        .slice('root-'.length);\r\n}\r\nfunction extractTitle(node, styleId) {\r\n    var _a, _b;\r\n    return (_b = (_a = node.querySelector(`titleTextStyle-${styleId}`)) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : 'UpSetJS';\r\n}\r\nfunction extractDescription(node, styleId) {\r\n    var _a, _b;\r\n    return (_b = (_a = node.querySelector(`descTextStyle-${styleId}`)) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : '';\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst EMPTY_OBJECT = {};\r\nconst EMPTY_ARRAY$2 = [];\r\nconst DEFAULT_FONT_SIZES = {\r\n    setLabel: '16px',\r\n    axisTick: '10px',\r\n    chartLabel: '16px',\r\n    barLabel: '10px',\r\n    legend: '10px',\r\n    description: '16px',\r\n    title: '24px',\r\n    valueLabel: '12px',\r\n    exportLabel: '10px',\r\n};\r\nconst DEFAULT_WIDTH_RATIO = [0.18, 0.12, 0.7];\r\nconst DEFAULT_HEIGHT_RATIO = [0.6, 0.4];\r\nconst DEFAULT_COMBINATIONS = {\r\n    type: 'intersection',\r\n    order: ['cardinality:desc', 'name:asc'],\r\n};\r\nconst FONT_SIZES_KEYS = /* #__PURE__ */ Object.keys(DEFAULT_FONT_SIZES);\r\nconst MULTI_STYLE_KEYS = [\r\n    'axisTick',\r\n    'bar',\r\n    'barLabel',\r\n    'chartLabel',\r\n    'dot',\r\n    'legend',\r\n    'title',\r\n    'description',\r\n    'setLabel',\r\n    'set',\r\n    'valueLabel',\r\n];\r\nconst EXPORT_OPTION_KEYS = ['dump', 'png', 'share', 'svg', 'vega'];\r\nconst OVERFLOW_OPACITY_FACTOR = [0.7, 0.4];\r\nconst OVERFLOW_PADDING_FACTOR = [0.15, 0.3];\n\nvar sets$6 = [\n];\nvar intersections$5 = [\n];\nvar bb$5 = {\n\tx: 0,\n\ty: 0,\n\twidth: 10,\n\theight: 10\n};\nvar venn0 = {\n\tsets: sets$6,\n\tintersections: intersections$5,\n\tbb: bb$5\n};\n\nvar sets$5 = [\n\t{\n\t\tcx: 0,\n\t\tcy: 0,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: 3.5,\n\t\t\ty: -4\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t}\n];\nvar intersections$4 = [\n\t{\n\t\tsets: [\n\t\t\t0\n\t\t],\n\t\tx1: 0,\n\t\ty1: 5,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -5,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 5,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t}\n\t}\n];\nvar bb$4 = {\n\tx: -5,\n\ty: -5,\n\twidth: 10,\n\theight: 10\n};\nvar venn1 = {\n\tsets: sets$5,\n\tintersections: intersections$4,\n\tbb: bb$4\n};\n\nvar sets$4 = [\n\t{\n\t\tcx: -4,\n\t\tcy: 0,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: -7.5,\n\t\t\ty: 4\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"top\"\n\t},\n\t{\n\t\tcx: 4,\n\t\tcy: 0,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: 7.5,\n\t\t\ty: -4\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t}\n];\nvar intersections$3 = [\n\t{\n\t\tsets: [\n\t\t\t0\n\t\t],\n\t\tx1: 0,\n\t\ty1: -3,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 3,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -4,\n\t\t\ty: 0\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1\n\t\t],\n\t\tx1: 0,\n\t\ty1: 3,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 3,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 4,\n\t\t\ty: 0\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1\n\t\t],\n\t\tx1: 0,\n\t\ty1: 3,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 3,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t}\n\t}\n];\nvar bb$3 = {\n\tx: -9,\n\ty: -5,\n\twidth: 18,\n\theight: 10\n};\nvar venn2 = {\n\tsets: sets$4,\n\tintersections: intersections$3,\n\tbb: bb$3\n};\n\nvar sets$3 = [\n\t{\n\t\tcx: -3.464,\n\t\tcy: -2,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: -7,\n\t\t\ty: -6\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: 3.464,\n\t\tcy: -2,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: 7,\n\t\t\ty: -6\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: 0,\n\t\tcy: 4,\n\t\tr: 5,\n\t\ttext: {\n\t\t\tx: 4,\n\t\t\ty: 7.5\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"top\"\n\t}\n];\nvar intersections$2 = [\n\t{\n\t\tsets: [\n\t\t\t0\n\t\t],\n\t\tx1: -4.855,\n\t\ty1: 2.803,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: -1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -5.606,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: -4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -4.216,\n\t\t\ty: -2.434\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1\n\t\t],\n\t\tx1: 0,\n\t\ty1: -5.606,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: 4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -5.606,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 4.216,\n\t\t\ty: -2.434\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2\n\t\t],\n\t\tx1: -4.855,\n\t\ty1: 2.803,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 1.606,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: -4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 4.869\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1\n\t\t],\n\t\tx1: 0,\n\t\ty1: -5.606,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: -1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: 1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -5.606,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: -2.404\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2\n\t\t],\n\t\tx1: -4.855,\n\t\ty1: 2.803,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: -1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 1.606,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: -4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.082,\n\t\t\ty: 1.202\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 4.855,\n\t\ty1: 2.803,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: 1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"o\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 1.606,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: 4.855,\n\t\t\t\ty2: 2.803,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.082,\n\t\t\ty: 1.202\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 1.39,\n\t\ty1: -0.803,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 0,\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 1.606,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 1,\n\t\t\t\tx2: -1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tmode: \"i\",\n\t\t\t\tref: 2,\n\t\t\t\tx2: 1.39,\n\t\t\t\ty2: -0.803,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t}\n\t}\n];\nvar bb$2 = {\n\tx: -8.464,\n\ty: -7,\n\twidth: 16.928,\n\theight: 16\n};\nvar venn3 = {\n\tsets: sets$3,\n\tintersections: intersections$2,\n\tbb: bb$2\n};\n\nvar sets$2 = [\n\t{\n\t\tcx: 0.439,\n\t\tcy: -1.061,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 45,\n\t\ttext: {\n\t\t\tx: 4.5,\n\t\t\ty: -4.5\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: 2.561,\n\t\tcy: 1.061,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 45,\n\t\ttext: {\n\t\t\tx: 4,\n\t\t\ty: 3.75\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"top\"\n\t},\n\t{\n\t\tcx: -2.561,\n\t\tcy: 1.061,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: -45,\n\t\ttext: {\n\t\t\tx: -4,\n\t\t\ty: 3.7\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"top\"\n\t},\n\t{\n\t\tcx: -0.439,\n\t\tcy: -1.061,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: -45,\n\t\ttext: {\n\t\t\tx: -4.5,\n\t\t\ty: -4.5\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"bottom\"\n\t}\n];\nvar intersections$1 = [\n\t{\n\t\tsets: [\n\t\t\t0\n\t\t],\n\t\tx1: 0,\n\t\ty1: -3.94,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 4.328,\n\t\t\t\ty2: -2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3.94,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.914,\n\t\t\ty: -3.536\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1\n\t\t],\n\t\tx1: 4.328,\n\t\ty1: -2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 5.006,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 1.328,\n\t\t\t\ty2: 2.828\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 3.108,\n\t\t\t\ty2: -0.328\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 4.328,\n\t\t\t\ty2: -2.828\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 5.036,\n\t\t\ty: -1.414\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2\n\t\t],\n\t\tx1: 0,\n\t\ty1: 5.006,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -4.328,\n\t\t\t\ty2: -2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.108,\n\t\t\t\ty2: -0.328\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.328,\n\t\t\t\ty2: 2.828\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 5.006\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -5.036,\n\t\t\ty: -1.414\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t3\n\t\t],\n\t\tx1: -4.328,\n\t\ty1: -2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3.94,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -4.328,\n\t\t\t\ty2: -2.828,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.914,\n\t\t\ty: -3.536\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1\n\t\t],\n\t\tx1: 4.328,\n\t\ty1: -2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 4.328,\n\t\t\t\ty2: -2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 3.205,\n\t\t\ty: -1.672\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2\n\t\t],\n\t\tx1: -1.328,\n\t\ty1: 2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.328,\n\t\t\t\ty2: 2.828,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.212,\n\t\t\ty: 1.591\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t3\n\t\t],\n\t\tx1: 0,\n\t\ty1: -3.94,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 0.188,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: -3.94,\n\t\t\t\tsweep: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: -1.87\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 1.328,\n\t\ty1: 2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 5.006,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.328,\n\t\t\t\ty2: 2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 2.346,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 1.328,\n\t\t\t\ty2: 2.828\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 3.393\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t3\n\t\t],\n\t\tx1: 3.108,\n\t\ty1: -0.328,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 1.328,\n\t\t\t\ty2: 2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.212,\n\t\t\ty: 1.591\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: -3.108,\n\t\ty1: -0.328,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -4.328,\n\t\t\t\ty2: -2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -3.205,\n\t\t\ty: -1.672\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 0,\n\t\ty1: 2.346,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.328,\n\t\t\t\ty2: 2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 2.346,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -0.766,\n\t\t\ty: 2.31\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t3\n\t\t],\n\t\tx1: 2.179,\n\t\ty1: -1.858,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 0.188,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 1.558,\n\t\t\ty: -0.056\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: -0.969,\n\t\ty1: 1.755,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.108,\n\t\t\t\ty2: -0.328,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2.179,\n\t\t\t\ty2: -1.858,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 0.188,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.969,\n\t\t\t\ty2: 1.755\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -1.558,\n\t\t\ty: -0.056\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: 1.328,\n\t\ty1: 2.828,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 2.346,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 1.328,\n\t\t\t\ty2: 2.828,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0.766,\n\t\t\ty: 2.31\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: 0,\n\t\ty1: 0.188,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 2.346,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.969,\n\t\t\t\ty2: 1.755,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0,\n\t\t\t\ty2: 0.188,\n\t\t\t\tsweep: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 1.43\n\t\t}\n\t}\n];\nvar bb$1 = {\n\tx: -6.5,\n\ty: -5,\n\twidth: 13,\n\theight: 10\n};\nvar venn4 = {\n\tsets: sets$2,\n\tintersections: intersections$1,\n\tbb: bb$1\n};\n\nvar sets$1 = [\n\t{\n\t\tcx: 0.5,\n\t\tcy: -1,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 0,\n\t\ttext: {\n\t\t\tx: 2.25,\n\t\t\ty: -5\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: 1.106,\n\t\tcy: 0.167,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 72,\n\t\ttext: {\n\t\t\tx: 4.5,\n\t\t\ty: 1.5\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"top\"\n\t},\n\t{\n\t\tcx: 0.183,\n\t\tcy: 1.103,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 144,\n\t\ttext: {\n\t\t\tx: 4,\n\t\t\ty: 4\n\t\t},\n\t\talign: \"start\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: -0.992,\n\t\tcy: 0.515,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 216,\n\t\ttext: {\n\t\t\tx: -4.7,\n\t\t\ty: 2\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"bottom\"\n\t},\n\t{\n\t\tcx: -0.797,\n\t\tcy: -0.785,\n\t\trx: 2.5,\n\t\try: 5,\n\t\trotation: 288,\n\t\ttext: {\n\t\t\tx: -4,\n\t\t\ty: -3.6\n\t\t},\n\t\talign: \"end\",\n\t\tverticalAlign: \"bottom\"\n\t}\n];\nvar intersections = [\n\t{\n\t\tsets: [\n\t\t\t0\n\t\t],\n\t\tx1: -1.653,\n\t\ty1: -3.541,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.857,\n\t\t\t\ty2: -2.666,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.5,\n\t\t\t\ty2: -2.648,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.495,\n\t\t\t\ty2: -3.303,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.653,\n\t\t\t\ty2: -3.541\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0.5,\n\t\t\ty: -5\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1\n\t\t],\n\t\tx1: 2.857,\n\t\ty1: -2.666,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.419,\n\t\t\t\ty2: 1.893,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 3.291,\n\t\t\t\ty2: 1.559,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.988,\n\t\t\t\ty2: -1.492,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.857,\n\t\t\t\ty2: -2.666\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 4.91,\n\t\t\ty: -1.07\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2\n\t\t],\n\t\tx1: 3.419,\n\t\ty1: 1.893,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.744,\n\t\t\t\ty2: 3.837,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.466,\n\t\t\t\ty2: 3.612,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.342,\n\t\t\t\ty2: 2.381,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 3.419,\n\t\t\t\ty2: 1.893\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.534,\n\t\t\ty: 4.339\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t3\n\t\t],\n\t\tx1: -0.744,\n\t\ty1: 3.837,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.879,\n\t\t\t\ty2: 0.478,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.579,\n\t\t\t\ty2: 0.673,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.54,\n\t\t\t\ty2: 2.963,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.744,\n\t\t\t\ty2: 3.837\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -3.343,\n\t\t\ty: 3.751\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t4\n\t\t],\n\t\tx1: -3.879,\n\t\ty1: 0.478,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.653,\n\t\t\t\ty2: -3.541,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.746,\n\t\t\t\ty2: -3.196,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.294,\n\t\t\t\ty2: -0.549,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.879,\n\t\t\t\ty2: 0.478\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -4.601,\n\t\t\ty: -2.021\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1\n\t\t],\n\t\tx1: 2.5,\n\t\ty1: -2.648,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.857,\n\t\t\t\ty2: -2.666,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.988,\n\t\t\t\ty2: -1.492,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.572,\n\t\t\t\ty2: -1.839,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.5,\n\t\t\t\ty2: -2.648\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.741,\n\t\t\ty: -2.152\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2\n\t\t],\n\t\tx1: 2.342,\n\t\ty1: 2.381,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.466,\n\t\t\t\ty2: 3.612,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.257,\n\t\t\t\ty2: 2.922,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.342,\n\t\t\t\ty2: 2.381,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0.5,\n\t\t\ty: 3.5\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t3\n\t\t],\n\t\tx1: -0.495,\n\t\ty1: -3.303,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.5,\n\t\t\t\ty2: -2.648,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 1.51,\n\t\t\t\ty2: -2.515,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.495,\n\t\t\t\ty2: -3.303,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 1.653,\n\t\t\ty: -3.125\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t4\n\t\t],\n\t\tx1: -1.653,\n\t\ty1: -3.541,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.495,\n\t\t\t\ty2: -3.303,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.954,\n\t\t\t\ty2: -3.015,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.746,\n\t\t\t\ty2: -3.196,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.653,\n\t\t\t\ty2: -3.541\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -1.199,\n\t\t\ty: -3.272\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 3.291,\n\t\ty1: 1.559,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.419,\n\t\t\t\ty2: 1.893,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.342,\n\t\t\t\ty2: 2.381,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.544,\n\t\t\t\ty2: 1.878,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 3.291,\n\t\t\t\ty2: 1.559\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.894,\n\t\t\ty: 1.942\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t3\n\t\t],\n\t\tx1: -1.54,\n\t\ty1: 2.963,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.579,\n\t\t\t\ty2: 0.673,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2.7,\n\t\t\t\ty2: 1.147,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.54,\n\t\t\t\ty2: 2.963,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -3.174,\n\t\t\ty: 1.557\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t4\n\t\t],\n\t\tx1: 2.988,\n\t\ty1: -1.492,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.291,\n\t\t\t\ty2: 1.559,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.858,\n\t\t\t\ty2: 0.659,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.988,\n\t\t\t\ty2: -1.492,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 3.483,\n\t\t\ty: 0.606\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: -0.466,\n\t\ty1: 3.612,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.744,\n\t\t\t\ty2: 3.837,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.54,\n\t\t\t\ty2: 2.963,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1,\n\t\t\t\ty2: 3,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.466,\n\t\t\t\ty2: 3.612\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -0.953,\n\t\t\ty: 3.352\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2,\n\t\t\t4\n\t\t],\n\t\tx1: -3.294,\n\t\ty1: -0.549,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.746,\n\t\t\t\ty2: -3.196,\n\t\t\t\tsweep: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.925,\n\t\t\t\ty2: -2.213\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.294,\n\t\t\t\ty2: -0.549\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.462,\n\t\t\ty: -2.538\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -3.579,\n\t\ty1: 0.673,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.879,\n\t\t\t\ty2: 0.478,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.294,\n\t\t\t\ty2: -0.549,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.162,\n\t\t\t\ty2: -0.024,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.579,\n\t\t\t\ty2: 0.673\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -3.483,\n\t\t\ty: 0.13\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2\n\t\t],\n\t\tx1: 2.544,\n\t\ty1: 1.878,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.342,\n\t\t\t\ty2: 2.381,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.257,\n\t\t\t\ty2: 2.922,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.983,\n\t\t\t\ty2: 2.049,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.544,\n\t\t\t\ty2: 1.878\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 1.457,\n\t\t\ty: 2.331\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t3\n\t\t],\n\t\tx1: 1.51,\n\t\ty1: -2.515,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.5,\n\t\t\t\ty2: -2.648,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.572,\n\t\t\t\ty2: -1.839,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 1.51,\n\t\t\t\ty2: -2.515,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.194,\n\t\t\ty: -2.334\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t4\n\t\t],\n\t\tx1: 2.572,\n\t\ty1: -1.839,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.988,\n\t\t\t\ty2: -1.492,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.858,\n\t\t\t\ty2: 0.659,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.253,\n\t\t\t\ty2: -0.302,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.572,\n\t\t\t\ty2: -1.839\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.667,\n\t\t\ty: -0.665\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: 0.257,\n\t\ty1: 2.922,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.466,\n\t\t\t\ty2: 3.612,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1,\n\t\t\t\ty2: 3,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.257,\n\t\t\t\ty2: 2.922,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -0.403,\n\t\t\ty: 3.178\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4\n\t\t],\n\t\tx1: -1.746,\n\t\ty1: -3.196,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.954,\n\t\t\t\ty2: -3.015,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.925,\n\t\t\t\ty2: -2.213,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.746,\n\t\t\t\ty2: -3.196,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -1.542,\n\t\t\ty: -2.808\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -0.495,\n\t\ty1: -3.303,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 1.51,\n\t\t\t\ty2: -2.515,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.409,\n\t\t\t\ty2: -2.236,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -0.954,\n\t\t\t\ty2: -3.015,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.495,\n\t\t\t\ty2: -3.303\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0.192,\n\t\t\ty: -2.742\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: -1.54,\n\t\ty1: 2.963,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2.7,\n\t\t\t\ty2: 1.147,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.645,\n\t\t\t\ty2: 1.568,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1,\n\t\t\t\ty2: 3,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.54,\n\t\t\t\ty2: 2.963\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -1.767,\n\t\t\ty: 2.106\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2,\n\t\t\t4\n\t\t],\n\t\tx1: 2.858,\n\t\ty1: 0.659,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 3.291,\n\t\t\t\ty2: 1.559,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.544,\n\t\t\t\ty2: 1.878,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.858,\n\t\t\t\ty2: 0.659,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.898,\n\t\t\ty: 1.365\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -2.7,\n\t\ty1: 1.147,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.579,\n\t\t\t\ty2: 0.673,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.162,\n\t\t\t\ty2: -0.024,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2.7,\n\t\t\t\ty2: 1.147,\n\t\t\t\tlarge: false\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -3.147,\n\t\t\ty: 0.599\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t2,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -3.294,\n\t\ty1: -0.549,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.925,\n\t\t\t\ty2: -2.213,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2,\n\t\t\t\ty2: -1.08,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -3.162,\n\t\t\t\ty2: -0.024,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.294,\n\t\t\t\ty2: -0.549\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.548,\n\t\t\ty: -1.029\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2,\n\t\t\t3\n\t\t],\n\t\tx1: 0.983,\n\t\ty1: 2.049,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.257,\n\t\t\t\ty2: 2.922,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1,\n\t\t\t\ty2: 3,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.645,\n\t\t\t\ty2: 1.568,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.983,\n\t\t\t\ty2: 2.049\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -0.407,\n\t\t\ty: 2.31\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2,\n\t\t\t4\n\t\t],\n\t\tx1: 2.253,\n\t\ty1: -0.302,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.858,\n\t\t\t\ty2: 0.659,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.544,\n\t\t\t\ty2: 1.878,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.983,\n\t\t\t\ty2: 2.049,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 2.253,\n\t\t\t\ty2: -0.302\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 2.071,\n\t\t\ty: 1.101\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: 1.51,\n\t\ty1: -2.515,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.572,\n\t\t\t\ty2: -1.839,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.253,\n\t\t\t\ty2: -0.302,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: 0.409,\n\t\t\t\ty2: -2.236,\n\t\t\t\tsweep: false,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 1.51,\n\t\t\t\ty2: -2.515,\n\t\t\t\tsweep: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 1.687,\n\t\t\ty: -1.63\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t2,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -2,\n\t\ty1: -1.08,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.925,\n\t\t\t\ty2: -2.213,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -0.954,\n\t\t\t\ty2: -3.015,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.409,\n\t\t\t\ty2: -2.236,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -2,\n\t\t\t\ty2: -1.08\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -1.028,\n\t\t\ty: -2.108\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t1,\n\t\t\t2,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: -1.645,\n\t\ty1: 1.568,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2.7,\n\t\t\t\ty2: 1.147,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -3.162,\n\t\t\t\ty2: -0.024,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2,\n\t\t\t\ty2: -1.08,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"o\",\n\t\t\t\tx2: -1.645,\n\t\t\t\ty2: 1.568\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: -2.323,\n\t\t\ty: 0.327\n\t\t}\n\t},\n\t{\n\t\tsets: [\n\t\t\t0,\n\t\t\t1,\n\t\t\t2,\n\t\t\t3,\n\t\t\t4\n\t\t],\n\t\tx1: 0.409,\n\t\ty1: -2.236,\n\t\tarcs: [\n\t\t\t{\n\t\t\t\tref: 2,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 2.253,\n\t\t\t\ty2: -0.302,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 3,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.983,\n\t\t\t\ty2: 2.049,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 4,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -1.645,\n\t\t\t\ty2: 1.568,\n\t\t\t\tsweep: true,\n\t\t\t\tlarge: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 0,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: -2,\n\t\t\t\ty2: -1.08,\n\t\t\t\tsweep: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tref: 1,\n\t\t\t\tmode: \"i\",\n\t\t\t\tx2: 0.409,\n\t\t\t\ty2: -2.236,\n\t\t\t\tsweep: true\n\t\t\t}\n\t\t],\n\t\ttext: {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t}\n\t}\n];\nvar bb = {\n\tx: -5.5,\n\ty: -6,\n\twidth: 11.6,\n\theight: 11.8\n};\nvar venn5 = {\n\tsets: sets$1,\n\tintersections: intersections,\n\tbb: bb\n};\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction isEllipse(d) {\r\n    return typeof d.rx === 'number';\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst vennDiagramLayout = {\r\n    maxSets: 5,\r\n    compute(sets, _combinations, width, height) {\r\n        return layoutImpl(sets.length, width, height);\r\n    },\r\n};\r\nfunction layoutImpl(sets, width, height) {\r\n    const lookup = [venn0, venn1, venn2, venn3, venn4, venn5];\r\n    const r = lookup[Math.min(lookup.length - 1, sets)];\r\n    const f = Math.min(width / r.bb.width, height / r.bb.height);\r\n    const x = f * -r.bb.x + (width - f * r.bb.width) / 2;\r\n    const y = f * -r.bb.y + (height - f * r.bb.height) / 2;\r\n    const mx = (v) => x + f * v;\r\n    const my = (v) => y + f * v;\r\n    return {\r\n        sets: r.sets.map((c) => Object.assign({}, c, {\r\n            cx: mx(c.cx),\r\n            cy: my(c.cy),\r\n            text: {\r\n                x: mx(c.text.x),\r\n                y: my(c.text.y),\r\n            },\r\n        }, isEllipse(c)\r\n            ? {\r\n                rx: c.rx * f,\r\n                ry: c.ry * f,\r\n            }\r\n            : {\r\n                r: c.r * f,\r\n            })),\r\n        intersections: r.intersections.map((c) => ({\r\n            text: {\r\n                x: mx(c.text.x),\r\n                y: my(c.text.y),\r\n            },\r\n            x1: mx(c.x1),\r\n            y1: my(c.y1),\r\n            sets: c.sets,\r\n            arcs: c.arcs.map((a) => Object.assign({}, a, {\r\n                x2: mx(a.x2),\r\n                y2: my(a.y2),\r\n            })),\r\n        })),\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst lightTheme = {\r\n    selectionColor: '#ffa500',\r\n    color: '#000000',\r\n    hasSelectionColor: '',\r\n    opacity: 1,\r\n    hasSelectionOpacity: -1,\r\n    textColor: '#000000',\r\n    hoverHintColor: '#cccccc',\r\n    notMemberColor: '#d3d3d3',\r\n    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',\r\n    valueTextColor: '#000000',\r\n    strokeColor: '#000000',\r\n    backgroundColor: '#ffffff',\r\n    filled: false,\r\n};\r\nconst darkTheme = {\r\n    selectionColor: '#ffa500',\r\n    color: '#cccccc',\r\n    hasSelectionColor: '',\r\n    opacity: 1,\r\n    hasSelectionOpacity: -1,\r\n    textColor: '#ffffff',\r\n    hoverHintColor: '#d9d9d9',\r\n    notMemberColor: '#666666',\r\n    alternatingBackgroundColor: 'rgba(255, 255, 255, 0.2)',\r\n    valueTextColor: '#ffffff',\r\n    strokeColor: '#ffffff',\r\n    backgroundColor: '#303030',\r\n    filled: false,\r\n};\r\nconst vegaTheme = {\r\n    selectionColor: '#4c78a8',\r\n    color: '#4c78a8',\r\n    hasSelectionColor: '#c9d6e5',\r\n    opacity: 1,\r\n    hasSelectionOpacity: -1,\r\n    textColor: '#000000',\r\n    hoverHintColor: '#cccccc',\r\n    notMemberColor: '#d3d3d3',\r\n    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',\r\n    valueTextColor: '#000000',\r\n    strokeColor: '#000000',\r\n    backgroundColor: '#ffffff',\r\n    filled: true,\r\n};\r\nfunction getDefaultTheme(theme) {\r\n    return theme === 'vega' ? vegaTheme : theme === 'dark' ? darkTheme : lightTheme;\r\n}\r\nfunction areCombinations$1(combinations) {\r\n    return Array.isArray(combinations);\r\n}\r\nfunction styleFactory(rules) {\r\n    return React.createElement(\"style\", null, rules);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction fillGeneric(base, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nprops, others = {}) {\r\n    const theme = getDefaultTheme(props.theme);\r\n    return Object.assign(base, {\r\n        queryLegend: props.queries != null && props.queries.length > 0,\r\n        theme: 'light',\r\n        padding: 20,\r\n        selection: null,\r\n        title: '',\r\n        description: '',\r\n        fontFamily: 'sans-serif',\r\n        queries: EMPTY_ARRAY$2,\r\n        exportButtons: true,\r\n        className: '',\r\n        fontSizes: DEFAULT_FONT_SIZES,\r\n        classNames: EMPTY_OBJECT,\r\n        style: EMPTY_OBJECT,\r\n        styles: EMPTY_OBJECT,\r\n        toKey,\r\n        tooltips: true,\r\n        styleFactory,\r\n    }, theme, props, others, props.fontSizes\r\n        ? {\r\n            fontSizes: Object.assign({}, DEFAULT_FONT_SIZES, props.fontSizes),\r\n        }\r\n        : EMPTY_OBJECT);\r\n}\r\n/**\r\n * helper methods to fill up partial UpSet.js properties with their default values\r\n */\r\nfunction fillDefaultsG(props) {\r\n    return fillGeneric({\r\n        barPadding: 0.3,\r\n        dotPadding: 0.7,\r\n        combinations: DEFAULT_COMBINATIONS,\r\n        combinationName: props.combinations != null && !areCombinations$1(props.combinations) && props.combinations.type === 'union'\r\n            ? 'Union Size'\r\n            : 'Intersection Size',\r\n        barLabelOffset: 2,\r\n        setNameAxisOffset: 'auto',\r\n        combinationNameAxisOffset: 'auto',\r\n        setName: 'Set Size',\r\n        widthRatios: DEFAULT_WIDTH_RATIO,\r\n        heightRatios: DEFAULT_HEIGHT_RATIO,\r\n        setLabelAlignment: 'center',\r\n        numericScale: 'linear',\r\n        bandScale: 'band',\r\n        childrenFactories: EMPTY_OBJECT,\r\n        setAddons: EMPTY_ARRAY$2,\r\n        combinationAddons: EMPTY_ARRAY$2,\r\n        setAddonPadding: 1,\r\n        combinationAddonPadding: 1,\r\n        emptySelection: true,\r\n    }, props);\r\n}\r\nfunction valueFormat(v) {\r\n    return v.toLocaleString();\r\n}\r\nfunction fillDefaults(props) {\r\n    return fillDefaultsG(props);\r\n}\r\n/**\r\n * helper methods to fill up partial UpSet.js properties with their default values\r\n */\r\nfunction fillVennDiagramDefaultsG(props) {\r\n    return fillGeneric({\r\n        valueFormat,\r\n        layout: vennDiagramLayout,\r\n        setLabelOffsets: EMPTY_ARRAY$2,\r\n    }, props, {\r\n        exportButtons: props.exportButtons === false\r\n            ? false\r\n            : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, { vega: false }),\r\n    });\r\n}\r\nfunction fillVennDiagramDefaults(props) {\r\n    return fillVennDiagramDefaultsG(props);\r\n}\r\n/**\r\n * helper methods to fill up partial UpSet.js properties with their default values\r\n */\r\nfunction fillKarnaughMapDefaultsG(props) {\r\n    return fillGeneric({\r\n        numericScale: 'linear',\r\n        barPadding: 0.3,\r\n        barLabelOffset: 2,\r\n        combinationName: 'Intersection Size',\r\n        combinationNameAxisOffset: 'auto',\r\n    }, props, {\r\n        exportButtons: props.exportButtons === false\r\n            ? false\r\n            : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, { vega: false }),\r\n    });\r\n}\r\nfunction fillKarnaughMapDefaults(props) {\r\n    return fillKarnaughMapDefaultsG(props);\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction createSVG(node, toRemove) {\r\n    const clone = node.cloneNode(true);\r\n    clone.style.backgroundColor = getDefaultTheme(node.dataset.theme).backgroundColor;\r\n    if (toRemove) {\r\n        Array.from(clone.querySelectorAll(toRemove)).forEach((d) => d.remove());\r\n    }\r\n    return new XMLSerializer().serializeToString(clone);\r\n}\r\n/**\r\n * helper method to export an download an SVG image\r\n * @param node the SVG element to download\r\n * @param options additional options\r\n */\r\nfunction exportSVG(node, { type = 'png', title, toRemove }) {\r\n    const b = new Blob([createSVG(node, toRemove)], {\r\n        type: 'image/svg+xml;charset=utf-8',\r\n    });\r\n    const styleId = extractStyleId(node);\r\n    const chartTitle = title !== null && title !== void 0 ? title : extractTitle(node, styleId);\r\n    const url = URL.createObjectURL(b);\r\n    if (type === 'svg') {\r\n        downloadUrl(url, `${chartTitle}.${type}`, node.ownerDocument);\r\n        URL.revokeObjectURL(url);\r\n        return Promise.resolve();\r\n    }\r\n    return toPNG(url, node).then((purl) => {\r\n        downloadUrl(purl, `${chartTitle}.${type}`, node.ownerDocument);\r\n        URL.revokeObjectURL(url);\r\n    });\r\n}\r\nfunction toPNG(url, node) {\r\n    const canvas = node.ownerDocument.createElement('canvas');\r\n    const bb = node.getBoundingClientRect();\r\n    canvas.width = bb.width;\r\n    canvas.height = bb.height;\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image(canvas.width, canvas.height);\r\n    return new Promise((resolve) => {\r\n        img.onload = () => {\r\n            ctx.drawImage(img, 0, 0);\r\n            const png = canvas.toDataURL('image/png');\r\n            resolve(png);\r\n        };\r\n        img.src = url;\r\n    });\r\n}\r\n/**\r\n * helper method to download a given url in the browser\r\n * @param url the url to download\r\n * @param title the desired file name\r\n * @param doc the root document\r\n */\r\nfunction downloadUrl(url, title, doc) {\r\n    const a = doc.createElement('a');\r\n    a.href = url;\r\n    a.style.position = 'absolute';\r\n    a.style.left = '-10000px';\r\n    a.style.top = '-10000px';\r\n    a.download = title;\r\n    doc.body.appendChild(a);\r\n    a.click();\r\n    a.remove();\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction createVegaSpec(svg, title) {\r\n    var _a, _b, _c, _d, _e;\r\n    const resolveStyle = (_c = (svg.getComputedStyle || ((_b = (_a = svg.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getComputedStyle))) !== null && _c !== void 0 ? _c : window.getComputedStyle;\r\n    const styleId = extractStyleId(svg);\r\n    const chartTitle = title !== null && title !== void 0 ? title : extractTitle(svg, styleId);\r\n    const sets = Array.from(svg.querySelectorAll('[data-upset=sets] [data-cardinality]'))\r\n        .map((set) => {\r\n        return {\r\n            name: set.querySelector(`text.setTextStyle-${styleId}`).textContent,\r\n            cardinality: Number.parseInt(set.dataset.cardinality, 10),\r\n        };\r\n    })\r\n        .reverse();\r\n    const barLabelOffset = -Number.parseFloat(svg.querySelector(`.sBarTextStyle-${styleId}`).getAttribute('dx'));\r\n    const color = resolveStyle(svg.querySelector(`.fillPrimary-${styleId}`)).fill;\r\n    const fillNotMember = resolveStyle(svg.querySelector(`.fillNotMember-${styleId}`)).fill;\r\n    const textColor = resolveStyle(svg.querySelector('text')).fill;\r\n    const csName = svg.querySelector(`.cChartTextStyle-${styleId}`).textContent;\r\n    const setName = svg.querySelector(`.sChartTextStyle-${styleId}`).textContent;\r\n    const combinations = Array.from(svg.querySelectorAll('[data-upset=cs] [data-cardinality]')).map((set) => {\r\n        return {\r\n            name: set.querySelector(`text.hoverBarTextStyle-${styleId}`).textContent,\r\n            cardinality: Number.parseInt(set.dataset.cardinality, 10),\r\n            sets: Array.from(set.querySelectorAll(`.fillPrimary-${styleId} > title`)).map((n) => n.textContent),\r\n        };\r\n    });\r\n    const translateX = (v) => Number.parseFloat(v.getAttribute('transform').match(/([\\d.]+),/)[1]);\r\n    const translateY = (v) => Number.parseFloat(v.getAttribute('transform').match(/,([\\d.]+)/)[1]);\r\n    const base = svg.querySelector('[data-upset=base]');\r\n    const padding = translateX(base);\r\n    // combination axis block\r\n    const setWidth = translateX(svg.querySelector('[data-upset=csaxis]'));\r\n    // axisline\r\n    const csWidth = Number.parseFloat(base.querySelector('g').firstElementChild.children[1].getAttribute('x2'));\r\n    // set axis block\r\n    const csHeight = translateY(svg.querySelector('[data-upset=setaxis]'));\r\n    // set label clip path\r\n    const labelWidth = Number.parseFloat(svg.querySelector('defs rect').getAttribute('width'));\r\n    const setHeight = Number.parseFloat(svg.querySelector('defs rect').getAttribute('height'));\r\n    const radius = Number.parseFloat(svg.querySelector(`[data-cardinality] circle.fillPrimary-${styleId}`).getAttribute('r'));\r\n    const hasPrimarySelection = svg.querySelector('[data-upset=sets-s] [data-cardinality]') != null;\r\n    const hasQuery = svg.querySelector('[data-upset=sets-q] [data-cardinality]') != null;\r\n    const hasSelection = hasPrimarySelection || hasQuery;\r\n    let selectionColor = 'orange';\r\n    if (hasSelection) {\r\n        // inject the selection data\r\n        Array.from(svg.querySelectorAll(`[data-upset=sets-${hasPrimarySelection ? 's]' : 'q]:first-of-type'} [data-cardinality]`)).forEach((elem) => {\r\n            // since artificially reversed\r\n            const i = sets.length - Number.parseInt(elem.dataset.i, 10) - 1;\r\n            sets[i].selection = Number.parseInt(elem.dataset.cardinality, 10);\r\n        });\r\n        Array.from(svg.querySelectorAll(`[data-upset=cs-${hasPrimarySelection ? 's]' : 'q]:first-of-type'} [data-cardinality]`)).forEach((elem) => {\r\n            const i = Number.parseInt(elem.dataset.i, 10);\r\n            combinations[i].selection = Number.parseInt(elem.dataset.cardinality, 10);\r\n        });\r\n        selectionColor = resolveStyle(svg.querySelector(`[data-upset=sets-${hasPrimarySelection ? 's' : 'q'}] [data-cardinality]`)).fill;\r\n    }\r\n    const highlightedCombination = Number.parseInt((_e = (_d = svg.querySelector('[data-upset=cs-ss]')) === null || _d === void 0 ? void 0 : _d.dataset.i) !== null && _e !== void 0 ? _e : '-1', 10);\r\n    const filter = highlightedCombination >= 0\r\n        ? {\r\n            field: 'partOf',\r\n            oneOf: [1, 2],\r\n        }\r\n        : {\r\n            field: 'partOf',\r\n            equal: 1,\r\n        };\r\n    // part of: 0 ... negative list, 1 ... positive set list, 2, ... positive and selected\r\n    return {\r\n        $schema: 'https://vega.github.io/schema/vega-lite/v4.json',\r\n        title: chartTitle,\r\n        description: extractDescription(svg, styleId),\r\n        datasets: {\r\n            sets,\r\n            combinations: combinations\r\n                .map((c, i) => Object.assign({}, c, {\r\n                partOf: highlightedCombination === i ? 2 : 1,\r\n                nsets: [''],\r\n            }))\r\n                .concat(combinations.map((c) => ({\r\n                name: c.name,\r\n                cardinality: c.cardinality,\r\n                // no selection!\r\n                partOf: 0,\r\n                sets: [''],\r\n                nsets: sets.filter((s) => !c.sets.includes(s.name)).map((s) => s.name),\r\n            }))),\r\n        },\r\n        vconcat: [\r\n            {\r\n                hconcat: [\r\n                    {\r\n                        mark: 'bar',\r\n                        width: setWidth + labelWidth - 40,\r\n                        height: csHeight,\r\n                    },\r\n                    {\r\n                        width: csWidth,\r\n                        height: csHeight,\r\n                        data: {\r\n                            name: 'combinations',\r\n                        },\r\n                        transform: [\r\n                            {\r\n                                filter,\r\n                            },\r\n                        ],\r\n                        layer: [\r\n                            {\r\n                                mark: {\r\n                                    type: 'bar',\r\n                                    tooltip: true,\r\n                                },\r\n                            },\r\n                            {\r\n                                mark: {\r\n                                    type: 'text',\r\n                                    align: 'center',\r\n                                    baseline: 'bottom',\r\n                                    dy: -barLabelOffset,\r\n                                },\r\n                                encoding: {\r\n                                    text: { field: 'cardinality', type: 'quantitative' },\r\n                                },\r\n                            },\r\n                            hasSelection && {\r\n                                mark: {\r\n                                    type: 'bar',\r\n                                    fill: selectionColor,\r\n                                    tooltip: true,\r\n                                },\r\n                                encoding: {\r\n                                    y: {\r\n                                        field: 'selection',\r\n                                        type: 'quantitative',\r\n                                    },\r\n                                },\r\n                            },\r\n                        ].filter(Boolean),\r\n                        encoding: {\r\n                            x: { field: 'name', type: 'ordinal', axis: null, sort: null },\r\n                            y: {\r\n                                field: 'cardinality',\r\n                                type: 'quantitative',\r\n                                axis: {\r\n                                    grid: false,\r\n                                },\r\n                                title: csName,\r\n                            },\r\n                        },\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                hconcat: [\r\n                    {\r\n                        width: setWidth,\r\n                        height: setHeight,\r\n                        data: {\r\n                            name: 'sets',\r\n                        },\r\n                        layer: [\r\n                            {\r\n                                mark: {\r\n                                    type: 'bar',\r\n                                    tooltip: true,\r\n                                },\r\n                            },\r\n                            {\r\n                                mark: {\r\n                                    type: 'text',\r\n                                    align: 'right',\r\n                                    baseline: 'middle',\r\n                                    dx: -barLabelOffset,\r\n                                },\r\n                                encoding: {\r\n                                    text: { field: 'cardinality', type: 'quantitative' },\r\n                                },\r\n                            },\r\n                            hasSelection && {\r\n                                mark: {\r\n                                    type: 'bar',\r\n                                    fill: selectionColor,\r\n                                    tooltip: true,\r\n                                },\r\n                                encoding: {\r\n                                    x: {\r\n                                        field: 'selection',\r\n                                        type: 'quantitative',\r\n                                    },\r\n                                },\r\n                            },\r\n                        ].filter(Boolean),\r\n                        encoding: {\r\n                            y: { field: 'name', type: 'ordinal', axis: null, sort: null },\r\n                            x: {\r\n                                field: 'cardinality',\r\n                                type: 'quantitative',\r\n                                title: setName,\r\n                                sort: 'descending',\r\n                                axis: {\r\n                                    grid: false,\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                    {\r\n                        data: {\r\n                            name: 'sets',\r\n                        },\r\n                        width: labelWidth,\r\n                        height: setHeight,\r\n                        mark: {\r\n                            type: 'text',\r\n                            align: 'center',\r\n                            baseline: 'middle',\r\n                            fontSize: Number.parseInt(resolveStyle(svg.querySelector(`.setTextStyle-${styleId}`)).fontSize, 10),\r\n                        },\r\n                        encoding: {\r\n                            y: { field: 'name', type: 'ordinal', axis: null, sort: null },\r\n                            text: { field: 'name', type: 'ordinal' },\r\n                        },\r\n                    },\r\n                    {\r\n                        width: csWidth,\r\n                        height: setHeight,\r\n                        data: {\r\n                            name: 'combinations',\r\n                        },\r\n                        transform: [\r\n                            {\r\n                                flatten: ['sets'],\r\n                                as: ['has_set'],\r\n                            },\r\n                            {\r\n                                flatten: ['nsets'],\r\n                                as: ['has_not_set'],\r\n                            },\r\n                            {\r\n                                calculate: 'datum.has_set+datum.has_not_set',\r\n                                as: 'set',\r\n                            },\r\n                        ],\r\n                        layer: [\r\n                            {\r\n                                mark: {\r\n                                    type: 'circle',\r\n                                    size: radius * radius * Math.PI,\r\n                                    tooltip: true,\r\n                                },\r\n                                encoding: {\r\n                                    color: {\r\n                                        field: 'partOf',\r\n                                        type: 'nominal',\r\n                                        legend: null,\r\n                                        scale: {\r\n                                            range: [fillNotMember, color].concat(highlightedCombination >= 0 ? [selectionColor] : []),\r\n                                        },\r\n                                    },\r\n                                    y: {\r\n                                        field: 'set',\r\n                                        type: 'ordinal',\r\n                                        axis: null,\r\n                                        sort: null,\r\n                                        scale: {\r\n                                            domain: sets.map((s) => s.name),\r\n                                        },\r\n                                    },\r\n                                },\r\n                            },\r\n                            {\r\n                                mark: 'rule',\r\n                                transform: [\r\n                                    {\r\n                                        filter,\r\n                                    },\r\n                                    {\r\n                                        calculate: 'datum.sets[datum.sets.length -1]',\r\n                                        as: 'set_end',\r\n                                    },\r\n                                ],\r\n                                encoding: Object.assign({ y: { field: 'sets[0]', type: 'ordinal', axis: null, sort: null }, y2: { field: 'set_end' } }, (highlightedCombination < 0\r\n                                    ? {}\r\n                                    : {\r\n                                        color: {\r\n                                            field: 'partOf',\r\n                                            type: 'nominal',\r\n                                            legend: null,\r\n                                            scale: {\r\n                                                range: [color, selectionColor],\r\n                                            },\r\n                                        },\r\n                                    })),\r\n                            },\r\n                        ],\r\n                        encoding: {\r\n                            x: { field: 'name', type: 'ordinal', axis: null, sort: null },\r\n                        },\r\n                    },\r\n                ],\r\n            },\r\n        ],\r\n        config: {\r\n            padding,\r\n            background: getDefaultTheme(svg.dataset.theme).backgroundColor,\r\n            concat: {\r\n                spacing: 0,\r\n            },\r\n            view: {\r\n                stroke: null,\r\n            },\r\n            // scale: {\r\n            //   bandPaddingInner: props.barPadding,\r\n            //   bandPaddingOuter: props.barPadding,\r\n            //   pointPadding: props.barPadding,\r\n            // },\r\n            bar: {\r\n                fill: color,\r\n            },\r\n            circle: {\r\n                opacity: 1,\r\n            },\r\n            rule: {\r\n                stroke: color,\r\n                strokeWidth: Number.parseInt(resolveStyle(svg.querySelector(`[data-upset=cs] [data-cardinality] line`)).strokeWidth, 10),\r\n            },\r\n            axis: {\r\n                labelColor: textColor,\r\n                labelFontSize: Number.parseInt(resolveStyle(svg.querySelector(`.axisTextStyle-${styleId}`)).fontSize, 10),\r\n                titleColor: textColor,\r\n                titleFontSize: Number.parseInt(resolveStyle(svg.querySelector(`.cChartTextStyle-${styleId}`)).fontSize, 10),\r\n            },\r\n            title: {\r\n                color: textColor,\r\n            },\r\n            text: {\r\n                fill: textColor,\r\n                fontSize: Number.parseInt(resolveStyle(svg.querySelector(`.sBarTextStyle-${styleId}`)).fontSize, 10),\r\n            },\r\n        },\r\n    };\r\n}\r\nfunction exportVegaLite(svg, { title } = {}) {\r\n    const spec = createVegaSpec(svg, title);\r\n    const url = URL.createObjectURL(new Blob([JSON.stringify(spec, null, 2)], {\r\n        type: 'application/json',\r\n    }));\r\n    downloadUrl(url, `${spec.title}.json`, svg.ownerDocument);\r\n    URL.revokeObjectURL(url);\r\n}\n\nconst THEME_KEYS = [\r\n    'selectionColor',\r\n    'color',\r\n    'textColor',\r\n    'hoverHintColor',\r\n    'notMemberColor',\r\n    'alternatingBackgroundColor',\r\n    'hasSelectionColor',\r\n    'hasSelectionOpacity',\r\n    'opacity',\r\n    'strokeColor',\r\n    'valueTextColor',\r\n];\r\nconst LAYOUT_KEYS = [\r\n    'padding',\r\n    'barPadding',\r\n    'dotPadding',\r\n    'widthRatios',\r\n    'heightRatios',\r\n];\r\nconst STYLE_KEYS = [\r\n    'fontSizes',\r\n    'combinationName',\r\n    'setName',\r\n    'barLabelOffset',\r\n    'setNameAxisOffset',\r\n    'combinationNameAxisOffset',\r\n    'theme',\r\n    'fontFamily',\r\n    'emptySelection',\r\n    'exportButtons',\r\n    'queryLegend',\r\n];\r\nconst DUMP_KEYS = ['bandScale', 'numericScale'].concat(THEME_KEYS, LAYOUT_KEYS, STYLE_KEYS);\r\nfunction toDumpProps(props) {\r\n    var _a;\r\n    const full = fillDefaults({\r\n        width: 0,\r\n        height: 0,\r\n        sets: (_a = props.sets) !== null && _a !== void 0 ? _a : [],\r\n        combinations: props.combinations,\r\n        theme: props.theme,\r\n    });\r\n    const r = {};\r\n    DUMP_KEYS.forEach((key) => {\r\n        const value = props[key];\r\n        const defaultValue = full[key];\r\n        if (key === 'theme' && value !== 'light') {\r\n            // keep dark theme flag\r\n            r[key] = value;\r\n            return;\r\n        }\r\n        if (value == null || value === defaultValue) {\r\n            return;\r\n        }\r\n        if (key === 'fontSizes') {\r\n            // nested check\r\n            let empty = true;\r\n            const sub = {};\r\n            FONT_SIZES_KEYS.forEach((fKey) => {\r\n                const fValue = value[fKey];\r\n                const fDefaultValue = defaultValue[fKey];\r\n                if (fValue !== fDefaultValue) {\r\n                    sub[fKey] = fValue;\r\n                    empty = false;\r\n                }\r\n            });\r\n            if (!empty) {\r\n                r[key] = sub;\r\n            }\r\n        }\r\n        else {\r\n            r[key] = value;\r\n        }\r\n    });\r\n    return r;\r\n}\r\nfunction toUpSetJSDump(dump, elements, props, author, mode) {\r\n    return Object.assign({\r\n        $schema: 'https://upset.js.org/schema.1.0.0.json',\r\n        name: typeof props.title === 'string' ? props.title : 'UpSetJS',\r\n        description: typeof props.description === 'string' ? props.description : '',\r\n        mode,\r\n        author,\r\n        elements,\r\n        attrs: [],\r\n        props: toDumpProps(props),\r\n    }, dump);\r\n}\r\nfunction toUpSetJSStaticDump(dump, props, author, mode) {\r\n    return Object.assign({\r\n        $schema: 'https://upset.js.org/schema-static.1.0.0.json',\r\n        name: typeof props.title === 'string' ? props.title : 'UpSetJS',\r\n        description: typeof props.description === 'string' ? props.description : '',\r\n        mode,\r\n        author,\r\n        props: toDumpProps(props),\r\n    }, dump);\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction exportDumpData(props, data, compress = false, mode) {\r\n    var _a, _b;\r\n    const elems = [];\r\n    const lookup = new Map();\r\n    const toElemIndex = (elem) => {\r\n        if (lookup.has(elem)) {\r\n            return lookup.get(elem);\r\n        }\r\n        lookup.set(elem, elems.length);\r\n        elems.push(elem);\r\n        return elems.length - 1;\r\n    };\r\n    const dump = toDump({\r\n        sets: props.sets,\r\n        queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter((d) => isElemQuery(d) || isSetQuery(d))) !== null && _b !== void 0 ? _b : [],\r\n        toElemIndex,\r\n        selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,\r\n        combinations: data.cs.v,\r\n        combinationOptions: Array.isArray(props.combinations)\r\n            ? {}\r\n            : props.combinations,\r\n    }, {\r\n        compress: compress ? 'yes' : 'no',\r\n    });\r\n    return toUpSetJSDump(dump, elems, props, undefined, mode);\r\n}\r\nfunction exportStaticDumpData(props, data, compress = false, mode) {\r\n    var _a, _b;\r\n    const dump = toStaticDump({\r\n        sets: props.sets,\r\n        queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter((d) => isElemQuery(d) || isSetQuery(d))) !== null && _b !== void 0 ? _b : [],\r\n        selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,\r\n        combinations: data.cs.v,\r\n    }, {\r\n        compress: compress ? 'yes' : 'no',\r\n    });\r\n    return toUpSetJSStaticDump(dump, props, undefined, mode);\r\n}\r\nfunction exportDump(svg, props, data, mode) {\r\n    const dump = exportDumpData(props, data, false, mode);\r\n    const url = URL.createObjectURL(new Blob([JSON.stringify(dump, null, 2)], {\r\n        type: 'application/json',\r\n    }));\r\n    downloadUrl(url, `${dump.name}.json`, svg.ownerDocument);\r\n    URL.revokeObjectURL(url);\r\n}\r\nconst MAX_URL_LENGTH = 2048 * 2;\r\nfunction exportSharedLink(props, data, mode) {\r\n    const r = exportDumpData(props, data, true, mode);\r\n    delete r.$schema;\r\n    const arg = LZString.compressToEncodedURIComponent(JSON.stringify(r));\r\n    const url = new URL('https://upset.js.org/app/embed.html');\r\n    url.searchParams.set('p', arg);\r\n    if (url.toString().length < MAX_URL_LENGTH) {\r\n        window.open(url.toString(), '_blank');\r\n        return true;\r\n    }\r\n    // try other compression\r\n    const r2 = exportStaticDumpData(props, data, true, mode);\r\n    delete r2.$schema;\r\n    const arg2 = LZString.compressToEncodedURIComponent(JSON.stringify(r2));\r\n    url.searchParams.set('p', arg2);\r\n    if (url.toString().length < MAX_URL_LENGTH) {\r\n        window.open(url.toString(), '_blank');\r\n        return true;\r\n    }\r\n    // send via frame message\r\n    url.searchParams.delete('p');\r\n    const w = window.open(url.toString(), '_blank');\r\n    w === null || w === void 0 ? void 0 : w.addEventListener('load', () => {\r\n        w === null || w === void 0 ? void 0 : w.postMessage(r, url.origin);\r\n    });\r\n    return false;\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction clsx(...classNames) {\r\n    return classNames.filter(Boolean).join(' ');\r\n}\r\nfunction generateId(_args) {\r\n    return `upset-${Math.random().toString(36).slice(4)}`;\r\n}\r\nfunction isSetLike(s) {\r\n    return s != null && !Array.isArray(s);\r\n}\r\nfunction elemOverlapOf(query, toElemKey) {\r\n    const f = setOverlapFactory(query, toElemKey);\r\n    return (s) => {\r\n        return f(s.elems).intersection;\r\n    };\r\n}\r\nfunction noGuessPossible() {\r\n    return -1;\r\n}\r\nfunction generateSelectionOverlap(selection, overlapGuesser, toElemKey) {\r\n    if (!selection) {\r\n        return noOverlap;\r\n    }\r\n    if (typeof selection === 'function') {\r\n        return selection;\r\n    }\r\n    if (Array.isArray(selection)) {\r\n        return elemOverlapOf(selection, toElemKey);\r\n    }\r\n    const ss = selection;\r\n    if (ss.overlap) {\r\n        return ss.overlap.bind(ss);\r\n    }\r\n    let f = null;\r\n    return (s) => {\r\n        if (s.overlap) {\r\n            return s.overlap(ss);\r\n        }\r\n        const guess = overlapGuesser(s, ss);\r\n        if (guess >= 0) {\r\n            return guess;\r\n        }\r\n        if (!f) {\r\n            f = elemOverlapOf(ss.elems, toElemKey);\r\n        }\r\n        return f(s);\r\n    };\r\n}\r\nfunction generateSelectionName(selection) {\r\n    var _a;\r\n    return Array.isArray(selection)\r\n        ? `Array(${selection.length})`\r\n        : typeof selection === 'function'\r\n            ? '?'\r\n            : (_a = selection) === null || _a === void 0 ? void 0 : _a.name;\r\n}\r\nfunction elemElemOverlapOf(query, toElemKey) {\r\n    const f = setElemOverlapFactory(query, toElemKey);\r\n    return (s) => {\r\n        return f(s.elems).intersection;\r\n    };\r\n}\r\nfunction noOverlap() {\r\n    return 0;\r\n}\r\nfunction parseFontSize(v) {\r\n    if (v == null) {\r\n        return 10;\r\n    }\r\n    if (v.endsWith('pt')) {\r\n        return Math.floor((4 / 3) * Number.parseInt(v, 10));\r\n    }\r\n    return Number.parseInt(v, 10);\r\n}\r\nfunction toAnchor(alignment) {\r\n    var _a;\r\n    const alignments = {\r\n        left: 'start',\r\n        center: 'middle',\r\n        right: 'end',\r\n    };\r\n    return (_a = alignments[alignment]) !== null && _a !== void 0 ? _a : 'middle';\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction resolveNumericScale(factory) {\r\n    if (factory === 'linear') {\r\n        return linearScale;\r\n    }\r\n    if (factory === 'log') {\r\n        return logScale;\r\n    }\r\n    return factory;\r\n}\r\nfunction resolveBandScale(factory) {\r\n    return factory === 'band' ? bandScale$1 : factory;\r\n}\r\nfunction areCombinations(combinations) {\r\n    return Array.isArray(combinations);\r\n}\r\nfunction deriveDataDependent(sets, combinations, sizes, numericScale, bandScale, barLabelFontSize, dotPadding, barPadding, tickFontSize, combinationAddons, toKey, toElemKey, id, setMaxScale, combinationMaxScale) {\r\n    var _a;\r\n    const numericScaleFactory = resolveNumericScale(numericScale);\r\n    const bandScaleFactory = resolveBandScale(bandScale);\r\n    const cs = areCombinations(combinations)\r\n        ? combinations\r\n        : generateCombinations(sets, Object.assign({ toElemKey }, DEFAULT_COMBINATIONS, combinations));\r\n    const csKeys = cs.map(toKey);\r\n    const combinationX = bandScaleFactory(csKeys, sizes.cs.w, sizes.padding);\r\n    const dataCSCardinality = cs.reduce((acc, d) => Math.max(acc, d.cardinality), 0);\r\n    const maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : dataCSCardinality;\r\n    const combinationYEnd = maxCSCardinality > dataCSCardinality ? 0 : barLabelFontSize;\r\n    const combinationY = numericScaleFactory(maxCSCardinality, [sizes.cs.h, combinationYEnd], {\r\n        orientation: 'vertical',\r\n        fontSizeHint: tickFontSize,\r\n    });\r\n    const labelSize = (text) => Math.floor((barLabelFontSize / 1.4) * 0.7 * text.length);\r\n    const guessLabelWidth = (v) => labelSize(combinationY.tickFormat()(v));\r\n    const dataSetCardinality = sets.reduce((acc, d) => Math.max(acc, d.cardinality), 0);\r\n    const maxSetCardinality = setMaxScale !== null && setMaxScale !== void 0 ? setMaxScale : dataSetCardinality;\r\n    const largestSetLabelWidth = guessLabelWidth(maxSetCardinality);\r\n    let largestCSLabelWidth = guessLabelWidth(maxCSCardinality);\r\n    for (const addon of combinationAddons) {\r\n        if (!addon.scale) {\r\n            continue;\r\n        }\r\n        const ticks = addon.scale.ticks(3);\r\n        const f = addon.scale.tickFormat();\r\n        for (const tick of ticks) {\r\n            const l = typeof tick === 'number' ? f(tick) : (_a = tick.label) !== null && _a !== void 0 ? _a : f(tick.value);\r\n            const size = labelSize(l);\r\n            if (size > largestCSLabelWidth) {\r\n                largestCSLabelWidth = size;\r\n            }\r\n        }\r\n    }\r\n    const setShift = maxSetCardinality > dataSetCardinality ? 0 : largestSetLabelWidth;\r\n    const setX = numericScaleFactory(maxSetCardinality, [sizes.sets.w, setShift], {\r\n        orientation: 'horizontal',\r\n        fontSizeHint: tickFontSize,\r\n    });\r\n    const setKeys = sets.map(toKey);\r\n    const setY = bandScaleFactory(setKeys.slice().reverse(), // reverse order\r\n    sizes.sets.h, sizes.padding);\r\n    const r = (Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2) * dotPadding;\r\n    const triangleSize = Math.max(2, (Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2) * barPadding);\r\n    return {\r\n        id: id ? id : generateId(),\r\n        r,\r\n        triangleSize,\r\n        sets: {\r\n            v: sets,\r\n            keys: setKeys,\r\n            rv: sets.slice().reverse(),\r\n            x: setX,\r\n            xAxisWidth: sizes.sets.w - setShift,\r\n            y: (s) => setY(toKey(s)),\r\n            max: maxSetCardinality,\r\n            bandWidth: setY.bandwidth(),\r\n            cy: setY.bandwidth() / 2 + sizes.cs.h,\r\n            format: setX.tickFormat(),\r\n            labelOffset: barLabelFontSize + 9 + 2,\r\n        },\r\n        cs: {\r\n            v: cs,\r\n            keys: cs.map(toKey),\r\n            x: (s) => combinationX(toKey(s)),\r\n            max: maxCSCardinality,\r\n            y: combinationY,\r\n            yAxisWidth: sizes.cs.h - combinationYEnd,\r\n            cx: combinationX.bandwidth() / 2,\r\n            bandWidth: combinationX.bandwidth(),\r\n            format: combinationY.tickFormat(),\r\n            has: (v, s) => {\r\n                const sk = toKey(s);\r\n                return Array.from(v.sets).some((ss) => toKey(ss) === sk);\r\n            },\r\n            labelOffset: largestCSLabelWidth + 9 + 6,\r\n        },\r\n        toKey,\r\n        toElemKey,\r\n        overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey),\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveSizeDependent(width, height, margin, barPadding, widthRatios, heightRatios, setAddons, combinationAddons, id, setAddonPadding, combinationAddonPadding) {\r\n    const setAddonsBefore = setAddons.reduce((acc, a) => acc + (a.position === 'before' ? a.size + setAddonPadding : 0), 0);\r\n    const setAddonsAfter = setAddons.reduce((acc, a) => acc + (a.position !== 'before' ? a.size + setAddonPadding : 0), 0);\r\n    const combinationAddonsBefore = combinationAddons.reduce((acc, a) => acc + (a.position === 'before' ? a.size + setAddonPadding : 0), 0);\r\n    const combinationAddonsAfter = combinationAddons.reduce((acc, a) => acc + (a.position !== 'before' ? a.size + setAddonPadding : 0), 0);\r\n    const h = height - 2 * margin - 20 - combinationAddonsAfter - combinationAddonsBefore;\r\n    const w = width - 2 * margin - setAddonsBefore - setAddonsAfter;\r\n    const setWidth = widthRatios[0] > 1 ? widthRatios[0] : w * widthRatios[0];\r\n    const labelsWidth = widthRatios[1] > 1 ? widthRatios[1] : w * widthRatios[1];\r\n    const combinationHeight = heightRatios[0] > 1 ? heightRatios[0] : h * heightRatios[0];\r\n    return {\r\n        id: id ? id : generateId(),\r\n        cs: {\r\n            before: combinationAddonsBefore,\r\n            after: combinationAddonsAfter,\r\n            x: setAddonsBefore + setWidth + labelsWidth,\r\n            y: combinationAddonsBefore,\r\n            w: w - setWidth - labelsWidth,\r\n            h: combinationHeight,\r\n            addons: combinationAddons,\r\n            addonPadding: combinationAddonPadding,\r\n        },\r\n        labels: {\r\n            x: setAddonsBefore + setWidth,\r\n            y: combinationAddonsBefore + combinationHeight,\r\n            w: labelsWidth,\r\n            h: h - combinationHeight,\r\n        },\r\n        sets: {\r\n            before: setAddonsBefore,\r\n            after: setAddonsAfter,\r\n            x: setAddonsBefore,\r\n            y: combinationAddonsBefore + combinationHeight,\r\n            w: setWidth,\r\n            h: h - combinationHeight,\r\n            addons: setAddons,\r\n            addonPadding: setAddonPadding,\r\n        },\r\n        padding: barPadding,\r\n        legend: {\r\n            x: width / 2,\r\n        },\r\n        margin: margin,\r\n        w: width,\r\n        h: height,\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveStyleDependent$1(theme, styles, classNames, combinationName, combinationNameAxisOffset, setName, setNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips, setLabelAlignment) {\r\n    return {\r\n        theme,\r\n        styles,\r\n        classNames: classNames,\r\n        cs: {\r\n            name: combinationName,\r\n            offset: combinationNameAxisOffset,\r\n        },\r\n        sets: {\r\n            name: setName,\r\n            offset: setNameAxisOffset,\r\n        },\r\n        emptySelection,\r\n        id: styleId,\r\n        barLabelOffset,\r\n        selectionColor,\r\n        title,\r\n        description,\r\n        tooltips,\r\n        setLabelAlignment,\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction ExportButtons({ transform, styleId, exportButtons, exportChart, }) {\r\n    if (!exportButtons) {\r\n        return null;\r\n    }\r\n    const svgWidth = 26;\r\n    const pngWidth = 26;\r\n    const vegaWidth = 34;\r\n    const dumpWidth = 34;\r\n    const shareWidth = 42;\r\n    const space = 2;\r\n    let acc = 0;\r\n    const buttons = [];\r\n    if (exportButtons === true || exportButtons.svg !== false) {\r\n        acc += svgWidth;\r\n        buttons.push(React.createElement(\"g\", { key: \"svg\", className: `exportButton-${styleId}`, onClick: exportChart, \"data-type\": \"svg\", transform: `translate(-${acc}, 0)` },\r\n            React.createElement(\"title\", null, \"Download SVG Image\"),\r\n            React.createElement(\"rect\", { y: -9, width: svgWidth, height: 11, rx: 2, ry: 2 }),\r\n            React.createElement(\"text\", { className: `exportTextStyle-${styleId}`, x: svgWidth / 2 }, \"SVG\")));\r\n        acc += space;\r\n    }\r\n    if (exportButtons === true || exportButtons.png !== false) {\r\n        acc += pngWidth;\r\n        buttons.push(React.createElement(\"g\", { key: \"png\", className: `exportButton-${styleId}`, onClick: exportChart, \"data-type\": \"png\", transform: `translate(-${acc}, 0)` },\r\n            React.createElement(\"title\", null, \"Download PNG Image\"),\r\n            React.createElement(\"rect\", { y: -9, width: pngWidth, height: 11, rx: 2, ry: 2 }),\r\n            React.createElement(\"text\", { className: `exportTextStyle-${styleId}`, x: pngWidth / 2 }, \"PNG\")));\r\n        acc += space;\r\n    }\r\n    if (exportButtons === true || exportButtons.vega !== false) {\r\n        acc += vegaWidth;\r\n        buttons.push(React.createElement(\"g\", { key: \"vega\", className: `exportButton-${styleId}`, onClick: exportChart, \"data-type\": \"vega\", transform: `translate(-${acc}, 0)` },\r\n            React.createElement(\"title\", null, \"Download VEGA-Lite Specification\"),\r\n            React.createElement(\"rect\", { y: -9, width: vegaWidth, height: 11, rx: 2, ry: 2 }),\r\n            React.createElement(\"text\", { className: `exportTextStyle-${styleId}`, x: vegaWidth / 2 }, \"VEGA\")));\r\n        acc += space;\r\n    }\r\n    if (exportButtons === true || exportButtons.dump !== false) {\r\n        acc += dumpWidth;\r\n        buttons.push(React.createElement(\"g\", { key: \"dump\", className: `exportButton-${styleId}`, onClick: exportChart, \"data-type\": \"dump\", transform: `translate(-${acc}, 0)` },\r\n            React.createElement(\"title\", null, \"Download UpSet.js JSON Dump\"),\r\n            React.createElement(\"rect\", { y: -9, width: dumpWidth, height: 11, rx: 2, ry: 2 }),\r\n            React.createElement(\"text\", { className: `exportTextStyle-${styleId}`, x: dumpWidth / 2 }, \"DUMP\")));\r\n        acc += space;\r\n    }\r\n    if (exportButtons === true || exportButtons.share !== false) {\r\n        acc += shareWidth;\r\n        buttons.push(React.createElement(\"g\", { key: \"share\", className: `exportButton-${styleId}`, onClick: exportChart, \"data-type\": \"share\", transform: `translate(-${acc}, 0)` },\r\n            React.createElement(\"title\", null, \"Open a shareable URL\"),\r\n            React.createElement(\"rect\", { y: -9, width: shareWidth, height: 11, rx: 2, ry: 2 }),\r\n            React.createElement(\"text\", { className: `exportTextStyle-${styleId}`, x: shareWidth / 2 }, \"SHARE\")));\r\n        acc += space;\r\n    }\r\n    return (React.createElement(\"g\", { className: `exportButtons-${styleId}`, transform: transform }, buttons));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst QueryLegend = /*!#__PURE__*/ React.memo(function QueryLegend({ queries, x, style, data, }) {\r\n    return (React.createElement(\"text\", { transform: `translate(${x},4)`, style: style.styles.legend, className: clsx(`legendTextStyle-${style.id}`, style.classNames.legend) }, queries.map((q, i) => {\r\n        let count = null;\r\n        if (isSetQuery(q)) {\r\n            count = q.set.cardinality;\r\n        }\r\n        else if (isElemQuery(q)) {\r\n            count = q.elems instanceof Set ? q.elems.size : q.elems.length;\r\n        }\r\n        return (React.createElement(React.Fragment, { key: q.name },\r\n            React.createElement(\"tspan\", { className: `fillQ${i}-${data.id}` }, '  ⬤ '),\r\n            React.createElement(\"tspan\", null,\r\n                q.name,\r\n                count != null ? `: ${data.sets.format(count)}` : '')));\r\n    })));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst HorizontalTick = /*!#__PURE__*/ React.memo(function HorizontalTick({ pos, spacing, tickSizeInner, orient, name, style, }) {\r\n    const k = orient === 'top' || orient === 'left' ? -1 : 1;\r\n    return (React.createElement(\"g\", { transform: `translate(0, ${pos + 0.5})` },\r\n        name && (React.createElement(\"text\", { x: k * spacing, dy: '0.32em', className: clsx(`axisTextStyle-${style.id}`, orient === 'right' ? `startText-${style.id}` : `endText-${style.id}`, style.classNames.axisTick), style: style.styles.axisTick }, name)),\r\n        React.createElement(\"line\", { x2: k * tickSizeInner, className: `axisLine-${style.id}` })));\r\n});\r\nconst VerticalTick = /*!#__PURE__*/ React.memo(function VerticalTick({ pos, name, spacing, orient, tickSizeInner, style, }) {\r\n    const k = orient === 'top' || orient === 'left' ? -1 : 1;\r\n    return (React.createElement(\"g\", { transform: `translate(${pos + 0.5}, 0)` },\r\n        name && (React.createElement(\"text\", { y: k * spacing, dy: orient === 'top' ? '0em' : '0.71em', className: clsx(`axisTextStyle-${style.id}`, style.classNames.axisTick), style: style.styles.axisTick }, name)),\r\n        React.createElement(\"line\", { y2: k * tickSizeInner, className: `axisLine-${style.id}` })));\r\n});\r\nfunction Axis({ scale, orient, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, size, start, style, transform, }) {\r\n    const spacing = Math.max(tickSizeInner, 0) + tickPadding;\r\n    const range0 = start;\r\n    const range1 = size;\r\n    const k = orient === 'top' || orient === 'left' ? -1 : 1;\r\n    const Tick = orient === 'left' || orient === 'right' ? HorizontalTick : VerticalTick;\r\n    const values = scale\r\n        .ticks()\r\n        .map((d) => (typeof d === 'number' ? { value: d, label: d.toLocaleString() } : d));\r\n    return (React.createElement(\"g\", { transform: transform },\r\n        values.map((d) => (React.createElement(Tick, { key: d.value, pos: scale(d.value), name: d.label, spacing: spacing, tickSizeInner: tickSizeInner, orient: orient, style: style }))),\r\n        React.createElement(\"path\", { className: `axisLine-${style.id}`, d: orient === 'left' || orient === 'right'\r\n                ? tickSizeOuter\r\n                    ? `M${k * tickSizeOuter},${range0}H0.5V${range1}H${k * tickSizeOuter}`\r\n                    : `M0.5,${range0}V${range1}`\r\n                : tickSizeOuter\r\n                    ? `M${range0},${k * tickSizeOuter}V0.5H${range1}V${k * tickSizeOuter}`\r\n                    : `M${range0},0.5H${range1}` })));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst MultilineText = /*!#__PURE__*/ React.memo(function MultilineText({ width, text, dy, x, style, className, }) {\r\n    const ref = useRef(null);\r\n    const [lines, setLines] = useState(typeof text === 'string' ? [text] : []);\r\n    // update state upon text update\r\n    useLayoutEffect(() => {\r\n        if (typeof text === 'string') {\r\n            setLines([text]);\r\n        }\r\n        else {\r\n            setLines([]);\r\n        }\r\n    }, [text]);\r\n    useLayoutEffect(() => {\r\n        if (!ref.current ||\r\n            ref.current.childElementCount > 0 ||\r\n            typeof text !== 'string' ||\r\n            typeof ref.current.getComputedTextLength !== 'function') {\r\n            // already multi lines\r\n            return;\r\n        }\r\n        const len = ref.current.getComputedTextLength();\r\n        const lines = [];\r\n        let lineWidth = width;\r\n        let start = 0;\r\n        // compute line splits\r\n        const p = ref.current.getStartPositionOfChar(0);\r\n        while (len > lineWidth) {\r\n            p.x = lineWidth;\r\n            const num = ref.current.getCharNumAtPosition(p);\r\n            const space = text.lastIndexOf(' ', num);\r\n            if (space < start) {\r\n                break;\r\n            }\r\n            lines.push(text.slice(start, space + 1));\r\n            const used = ref.current.getEndPositionOfChar(space + 1).x;\r\n            start = space + 1;\r\n            // new line with in the used part + a new line\r\n            lineWidth = used + width;\r\n        }\r\n        lines.push(text.slice(start));\r\n        setLines(lines);\r\n    }, [ref, text, width]);\r\n    if (!text) {\r\n        return null;\r\n    }\r\n    return (React.createElement(\"tspan\", { ref: ref, dy: dy, style: style, x: x, className: className }, lines.length > 1\r\n        ? lines.map((l, i) => (React.createElement(\"tspan\", { key: l, x: 0, dy: i > 0 ? '1.2em' : dy }, l)))\r\n        : text));\r\n});\r\nvar UpSetTitle = /*!#__PURE__*/ React.memo(function UpSetTitle({ width, descriptionWidth = width, style, }) {\r\n    if (!style.title && !style.description) {\r\n        return null;\r\n    }\r\n    return (React.createElement(\"text\", null,\r\n        React.createElement(MultilineText, { text: style.title, width: width, dy: \"10px\", className: clsx(`titleTextStyle-${style.id}`, style.classNames.title), style: style.styles.title }),\r\n        React.createElement(MultilineText, { x: 0, width: descriptionWidth, dy: style.title ? '2em' : '10px', text: style.description, className: clsx(`descTextStyle-${style.id}`, style.classNames.description), style: style.styles.description })));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction noop() {\r\n    return undefined;\r\n}\r\nfunction wrap(f) {\r\n    if (!f) {\r\n        return noop;\r\n    }\r\n    return (set, addons) => {\r\n        return function (evt) {\r\n            return f.call(this, set, evt.nativeEvent, addons.map((a) => (a.createOnHandlerData ? a.createOnHandlerData(set) : null)));\r\n        };\r\n    };\r\n}\r\nfunction addonPositionGenerator(total, padding) {\r\n    let beforeAcc = 0;\r\n    let afterAcc = 0;\r\n    return (addon) => {\r\n        let x = 0;\r\n        if (addon.position === 'before') {\r\n            beforeAcc += addon.size + padding;\r\n            x = -beforeAcc;\r\n        }\r\n        else {\r\n            x = total + afterAcc + padding;\r\n            afterAcc += addon.size + padding;\r\n        }\r\n        return x;\r\n    };\r\n}\r\nfunction mergeColor(style, color, prop = 'fill') {\r\n    if (!color) {\r\n        return style;\r\n    }\r\n    if (!style) {\r\n        return !color ? undefined : { [prop]: color };\r\n    }\r\n    return Object.assign({ [prop]: color }, style);\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst UpSetAxis = /*!#__PURE__*/ React.memo(function UpSetAxis({ size, style, data }) {\r\n    const setPosGen = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);\r\n    const combinationPosGen = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);\r\n    const csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;\r\n    const setNameOffset = style.sets.offset === 'auto' ? data.sets.labelOffset : style.sets.offset;\r\n    return (React.createElement(\"g\", null,\r\n        React.createElement(UpSetTitle, { style: style, width: size.cs.x - csNameOffset - 20 }),\r\n        size.cs.h > 0 && (React.createElement(\"g\", { transform: `translate(${size.cs.x},${size.cs.y})`, \"data-upset\": \"csaxis\" },\r\n            React.createElement(Axis, { scale: data.cs.y, orient: \"left\", size: size.cs.h, start: size.cs.h - data.cs.yAxisWidth, style: style }),\r\n            React.createElement(\"line\", { x1: 0, x2: size.cs.w, y1: size.cs.h + 1, y2: size.cs.h + 1, className: `axisLine-${style.id}` }),\r\n            React.createElement(\"text\", { className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${size.cs.h / 2})rotate(-90)` }, style.cs.name),\r\n            size.cs.addons.map((addon) => {\r\n                const pos = combinationPosGen(addon);\r\n                const title = (React.createElement(\"text\", { key: addon.name, className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${pos + addon.size / 2})rotate(-90)` }, addon.name));\r\n                if (!addon.scale) {\r\n                    return title;\r\n                }\r\n                return (React.createElement(React.Fragment, { key: addon.name },\r\n                    React.createElement(Axis, { scale: addon.scale, orient: \"left\", size: addon.size, start: 0, style: style, transform: `translate(0,${pos})` }),\r\n                    title));\r\n            }))),\r\n        size.sets.w > 0 && (React.createElement(\"g\", { transform: `translate(${size.sets.x},${size.sets.y})`, \"data-upset\": \"setaxis\" },\r\n            React.createElement(Axis, { scale: data.sets.x, orient: \"bottom\", size: size.sets.w, start: size.sets.w - data.sets.xAxisWidth, transform: `translate(0, ${size.sets.h})`, style: style }),\r\n            React.createElement(\"text\", { className: clsx(`sChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${size.sets.w / 2}, ${size.sets.h + setNameOffset})` }, style.sets.name),\r\n            size.sets.addons.map((addon) => {\r\n                const pos = setPosGen(addon);\r\n                const title = (React.createElement(\"text\", { key: addon.name, className: clsx(`sChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${pos + addon.size / 2}, ${size.sets.h + setNameOffset})` }, addon.name));\r\n                if (!addon.scale) {\r\n                    return title;\r\n                }\r\n                return (React.createElement(React.Fragment, { key: addon.name },\r\n                    React.createElement(Axis, { scale: addon.scale, orient: \"bottom\", size: addon.size, start: 0, transform: `translate(${pos}, ${size.sets.h})`, style: style }),\r\n                    title));\r\n            })))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst UpSetDot = /*!#__PURE__*/ React.memo(function UpSetDot({ cx, r, cy, name, className, style, fill, }) {\r\n    return (React.createElement(\"circle\", { r: r, cx: cx, cy: cy, className: className, style: mergeColor(style, fill) }, name && React.createElement(\"title\", null, name)));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction computeOverflowValues(value, max, scale) {\r\n    const scaled = [scale(value)];\r\n    for (let i = 0; i < OVERFLOW_PADDING_FACTOR.length && value > max; i++) {\r\n        value -= max;\r\n        scaled.push(scale(value));\r\n    }\r\n    return scaled;\r\n}\r\nconst CombinationChart = /*!#__PURE__*/ React.memo(function CombinationChart({ d, h, className, data, size, style, children, }) {\r\n    const yValues = computeOverflowValues(d.cardinality, data.cs.max, data.cs.y);\r\n    const genPosition = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);\r\n    return (React.createElement(\"g\", { transform: `translate(${data.cs.x(d)}, 0)`, onMouseEnter: h.onMouseEnter(d, size.cs.addons), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, size.cs.addons), onContextMenu: h.onContextMenu(d, size.cs.addons), onMouseMove: h.onMouseMove(d, size.cs.addons), className: className, \"data-cardinality\": d.cardinality },\r\n        style.tooltips && (React.createElement(\"title\", null,\r\n            d.name,\r\n            \": \",\r\n            data.cs.format(d.cardinality))),\r\n        React.createElement(\"rect\", { y: -size.cs.before, width: data.cs.bandWidth, height: size.sets.h + size.cs.h + size.cs.before + size.cs.after, className: `hoverBar-${style.id}` }),\r\n        size.cs.h > 0 && (React.createElement(React.Fragment, null,\r\n            yValues.map((y, i) => {\r\n                const offset = i > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;\r\n                return (React.createElement(\"rect\", { key: i, x: offset, y: y, height: size.cs.h - y, width: data.cs.bandWidth - offset * 2, className: clsx(`fillPrimary-${style.id}`, i < yValues.length - 1 && `fillOverflow${yValues.length - 1 - i}-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }));\r\n            }),\r\n            React.createElement(\"text\", { y: yValues[0] - style.barLabelOffset, x: data.cs.bandWidth / 2, style: style.styles.barLabel, className: clsx(`cBarTextStyle-${style.id}`, style.classNames.barLabel) }, data.cs.format(d.cardinality)))),\r\n        React.createElement(\"text\", { y: -style.barLabelOffset - size.cs.before, x: data.cs.bandWidth / 2, style: style.styles.barLabel, className: clsx(`hoverBarTextStyle-${style.id}`, style.classNames.barLabel) }, d.name),\r\n        data.sets.v.map((s, i) => {\r\n            if (data.cs.has(d, s)) {\r\n                // only not\r\n                return null;\r\n            }\r\n            return (React.createElement(UpSetDot, { key: data.sets.keys[i], r: data.r, cx: data.cs.cx, cy: data.sets.y(s) + data.sets.cy, name: style.tooltips ? d.name : '', style: style.styles.dot, fill: undefined, className: clsx(`fillNotMember-${style.id}`, style.classNames.dot) }));\r\n        }),\r\n        d.sets.size > 1 && (React.createElement(\"line\", { x1: data.cs.cx, y1: data.sets.y(data.sets.v.find((p) => data.cs.has(d, p))) + data.sets.cy - (data.r - 1), x2: data.cs.cx, y2: data.sets.y(data.sets.rv.find((p) => data.cs.has(d, p))) + data.sets.cy + (data.r - 1), style: d.color ? { stroke: d.color } : undefined, className: `upsetLine-${data.id}` })),\r\n        data.sets.v.map((s, i) => {\r\n            var _a;\r\n            if (!data.cs.has(d, s)) {\r\n                // only has\r\n                return null;\r\n            }\r\n            return (React.createElement(UpSetDot, { key: data.sets.keys[i], r: data.r, cx: data.cs.cx, cy: data.sets.y(s) + data.sets.cy, name: style.tooltips ? s.name : '', style: style.styles.dot, fill: (_a = s.color) !== null && _a !== void 0 ? _a : d.color, className: clsx(`fillPrimary-${style.id}`, style.classNames.dot) }));\r\n        }),\r\n        size.cs.addons.map((addon) => (React.createElement(\"g\", { key: addon.name, transform: `translate(0,${genPosition(addon)})` }, addon.render({ set: d, width: data.cs.bandWidth, height: addon.size, theme: style.theme })))),\r\n        children));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst SetChart = /*!#__PURE__*/ React.memo(function SetChart({ d, i, h, className, size, data, style, children, }) {\r\n    const xValues = computeOverflowValues(d.cardinality, data.sets.max, data.sets.x);\r\n    const genPosition = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);\r\n    const anchorOffset = style.setLabelAlignment === 'center'\r\n        ? size.labels.w / 2\r\n        : style.setLabelAlignment === 'left'\r\n            ? 2\r\n            : size.labels.w - 2;\r\n    return (React.createElement(\"g\", { transform: `translate(0, ${data.sets.y(d)})`, onMouseEnter: h.onMouseEnter(d, size.sets.addons), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, size.sets.addons), onContextMenu: h.onContextMenu(d, size.sets.addons), onMouseMove: h.onMouseMove(d, size.sets.addons), className: className, \"data-cardinality\": d.cardinality },\r\n        style.tooltips && (React.createElement(\"title\", null,\r\n            d.name,\r\n            \": \",\r\n            data.sets.format(d.cardinality))),\r\n        React.createElement(\"rect\", { x: -size.sets.before, width: size.sets.w + size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `hoverBar-${style.id}` }),\r\n        i % 2 === 1 && (React.createElement(\"rect\", { x: size.sets.w, width: size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `fillAlternating-${style.id}` })),\r\n        size.sets.w > 0 && (React.createElement(React.Fragment, null,\r\n            xValues.map((x, i) => {\r\n                const offset = i > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;\r\n                return (React.createElement(\"rect\", { key: i, x: x, y: offset, width: size.sets.w - x, height: data.sets.bandWidth - offset * 2, className: clsx(`fillPrimary-${style.id}`, i < xValues.length - 1 && `fillOverflow${xValues.length - 1 - i}-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }));\r\n            }),\r\n            React.createElement(\"text\", { x: xValues[0], dx: -style.barLabelOffset, y: data.sets.bandWidth / 2, style: style.styles.barLabel, className: clsx(`sBarTextStyle-${style.id}`, style.classNames.barLabel) }, data.sets.format(d.cardinality)))),\r\n        React.createElement(\"text\", { x: size.sets.w + anchorOffset, y: data.sets.bandWidth / 2, className: clsx(`setTextStyle-${style.id}`, style.classNames.setLabel), style: style.styles.setLabel, clipPath: `url(#clip-${size.id})` }, d.name),\r\n        size.sets.addons.map((addon) => (React.createElement(\"g\", { key: addon.name, transform: `translate(${genPosition(addon)},0)` }, addon.render({ set: d, width: addon.size, height: data.sets.bandWidth, theme: style.theme })))),\r\n        children));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst UpSetChart = /*!#__PURE__*/ React.memo(function UpSetChart({ data, size, style, h, setChildrenFactory, combinationChildrenFactory, }) {\r\n    return (React.createElement(\"g\", { className: h.hasClick ? `clickAble-${style.id}` : undefined },\r\n        React.createElement(\"g\", { transform: `translate(${size.sets.x},${size.sets.y})`, \"data-upset\": \"sets\" }, data.sets.v.map((d, i) => (React.createElement(SetChart, { key: data.sets.keys[i], d: d, i: i, h: h, className: h.hasClick || h.hasHover ? `interactive-${style.id}` : undefined, data: data, style: style, size: size }, setChildrenFactory && setChildrenFactory(d))))),\r\n        React.createElement(\"g\", { transform: `translate(${size.cs.x},${size.cs.y})`, \"data-upset\": \"cs\" }, data.cs.v.map((d, i) => (React.createElement(CombinationChart, { key: data.cs.keys[i], d: d, h: h, className: h.hasClick || h.hasHover ? `interactive-${style.id}` : undefined, data: data, style: style, size: size }, combinationChildrenFactory && combinationChildrenFactory(d)))))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction CombinationSelectionChart({ data, size, style, elemOverlap, secondary, tooltip, suffix, transform, empty, combinationAddons, }) {\r\n    const width = data.cs.bandWidth;\r\n    const totalHeight = size.cs.h + size.sets.h;\r\n    const height = size.cs.h;\r\n    const className = clsx(`fill${suffix}`, !tooltip && `pnone-${style.id}`, style.classNames.bar);\r\n    return (React.createElement(\"g\", { transform: transform, \"data-upset\": secondary ? 'cs-q' : 'cs-s' }, data.cs.v.map((d, i) => {\r\n        const x = data.cs.x(d);\r\n        const key = data.cs.keys[i];\r\n        if (empty && !secondary) {\r\n            return (React.createElement(\"rect\", { key: key, x: x, y: height, height: 0, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, tooltip && React.createElement(\"title\", null)));\r\n        }\r\n        const o = elemOverlap(d);\r\n        if (o === 0) {\r\n            return null;\r\n        }\r\n        const yValues = computeOverflowValues(o, data.cs.max, data.cs.y);\r\n        const title = tooltip && React.createElement(\"title\", null, `${d.name} ∩ ${tooltip}: ${o}`);\r\n        const content = secondary ? (React.createElement(\"path\", { key: key, transform: `translate(${x}, ${yValues[0]})`, d: `M0,-1 l${width},0 l0,2 l${-width},0 L-${data.triangleSize},-${data.triangleSize} L-${data.triangleSize},${data.triangleSize} Z`, className: className, \"data-i\": i, \"data-cardinality\": o, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (yValues.map((y, j) => {\r\n            const offset = j > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;\r\n            return (React.createElement(\"rect\", { key: j, x: x + offset, y: y, height: height - y, width: width - offset * 2, \"data-i\": j > 0 ? null : i, \"data-cardinality\": j > 0 ? null : o, className: clsx(className, j < yValues.length - 1 && `fillOverflow${yValues.length - 1 - j}-${style.id}`), style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));\r\n        }));\r\n        const genPosition = addonPositionGenerator(totalHeight, size.cs.addonPadding);\r\n        const addons = combinationAddons\r\n            .map((addon) => {\r\n            const v = genPosition(addon);\r\n            const content = addon.render({ set: d, width, height: addon.size, theme: style.theme });\r\n            if (!content) {\r\n                return null;\r\n            }\r\n            return (React.createElement(\"g\", { key: addon.name, transform: `translate(${x},${v})` }, content));\r\n        })\r\n            .filter(Boolean);\r\n        if (addons.length === 0) {\r\n            return content;\r\n        }\r\n        return (React.createElement(\"g\", { key: key },\r\n            content,\r\n            addons));\r\n    })));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction SetSelectionChart({ data, size, style, elemOverlap, suffix, secondary, empty, tooltip, setAddons, transform, }) {\r\n    const width = size.sets.w;\r\n    const totalWidth = size.sets.w + size.labels.w + size.cs.w;\r\n    const height = data.sets.bandWidth;\r\n    const className = clsx(`fill${suffix}`, !tooltip && ` pnone-${style.id}`, style.classNames.bar);\r\n    return (React.createElement(\"g\", { transform: transform, \"data-upset\": secondary ? 'sets-q' : 'sets-s' }, data.sets.v.map((d, i) => {\r\n        const y = data.sets.y(d);\r\n        const key = data.sets.keys[i];\r\n        if (empty && !secondary) {\r\n            return (React.createElement(\"rect\", { key: key, x: width, y: y, width: 0, height: height, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, style.tooltips && tooltip && React.createElement(\"title\", null)));\r\n        }\r\n        const o = elemOverlap(d);\r\n        if (o === 0) {\r\n            return null;\r\n        }\r\n        const xValues = computeOverflowValues(o, data.sets.max, data.sets.x);\r\n        const title = style.tooltips && tooltip && React.createElement(\"title\", null, `${d.name} ∩ ${tooltip}: ${o}`);\r\n        const content = secondary ? (React.createElement(\"path\", { key: key, transform: `translate(${xValues[0]}, ${y + height})`, d: `M1,0 l0,${-height} l-2,0 l0,${height} L-${data.triangleSize},${data.triangleSize} L${data.triangleSize},${data.triangleSize} Z`, \"data-i\": i, \"data-cardinality\": o, className: className, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (xValues.map((x, j) => {\r\n            const offset = j > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;\r\n            return (React.createElement(\"rect\", { key: j, \"data-i\": j > 0 ? null : i, \"data-cardinality\": j > 0 ? null : o, x: x, y: y + offset, width: width - x, height: height - offset * 2, className: clsx(className, j < xValues.length - 1 && `fillOverflow${xValues.length - 1 - j}-${style.id}`), style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));\r\n        }));\r\n        const genPosition = addonPositionGenerator(totalWidth, size.sets.addonPadding);\r\n        const addons = setAddons\r\n            .map((addon) => {\r\n            const v = genPosition(addon);\r\n            const content = addon.render({ set: d, width: addon.size, height, theme: style.theme });\r\n            if (!content) {\r\n                return null;\r\n            }\r\n            return (React.createElement(\"g\", { key: addon.name, transform: `translate(${v},${y})` }, content));\r\n        })\r\n            .filter(Boolean);\r\n        if (addons.length === 0) {\r\n            return content;\r\n        }\r\n        return (React.createElement(\"g\", { key: key },\r\n            content,\r\n            addons));\r\n    })));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst EMPTY_ARRAY$1 = [];\r\nconst UpSetQueries = /*!#__PURE__*/ React.memo(function UpSetQueries({ size, data, style, hasHover, secondary, queries, }) {\r\n    const someAddon = size.sets.addons.some((s) => s.renderQuery != null) || size.cs.addons.some((s) => s.renderQuery != null);\r\n    const qs = useMemo(() => queries.map((q) => (Object.assign(Object.assign({}, q), { overlap: queryOverlap(q, 'intersection', data.toElemKey), elemOverlap: someAddon ? queryElemOverlap(q, 'intersection', data.toElemKey) : null }))), [queries, someAddon, data.toElemKey]);\r\n    function wrapAddon(addon, query, index, overlapper, secondary) {\r\n        return Object.assign(Object.assign({}, addon), { render: (props) => {\r\n                const overlap = overlapper(props.set);\r\n                return addon.renderQuery ? addon.renderQuery(Object.assign({ query, overlap, index, secondary }, props)) : null;\r\n            } });\r\n    }\r\n    return (React.createElement(\"g\", { className: hasHover && !secondary ? `pnone-${style.id}` : undefined },\r\n        React.createElement(\"g\", { transform: `translate(${size.sets.x},${size.sets.y})` }, qs.map((q, i) => (React.createElement(SetSelectionChart, { key: q.name, data: data, size: size, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name, setAddons: size.sets.addons.length === 0\r\n                ? EMPTY_ARRAY$1\r\n                : size.sets.addons.map((a, i) => wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0)) })))),\r\n        React.createElement(\"g\", { transform: `translate(${size.cs.x},${size.cs.y})` }, qs.map((q, i) => (React.createElement(CombinationSelectionChart, { key: q.name, data: data, size: size, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name, combinationAddons: size.cs.addons.length === 0\r\n                ? EMPTY_ARRAY$1\r\n                : size.cs.addons.map((a, i) => wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0)) }))))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction LabelsSelection({ data, size, style, selection, }) {\r\n    if (!selection || selection.type !== 'set' || !data.sets.keys.includes(data.toKey(selection))) {\r\n        return null;\r\n    }\r\n    const d = selection;\r\n    return (React.createElement(\"rect\", { y: data.sets.y(d), width: size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `selectionHint-${style.id}` }));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction UpSetSelectionChart({ data, size, style, selection, }) {\r\n    const cy = data.sets.bandWidth / 2;\r\n    const cx = data.cs.cx;\r\n    const r = data.r;\r\n    const height = size.sets.h + size.sets.after;\r\n    const width = data.cs.bandWidth;\r\n    if (!selection || selection.type === 'set' || !data.cs) {\r\n        return null;\r\n    }\r\n    const d = selection;\r\n    const index = data.cs.keys.indexOf(data.toKey(d));\r\n    if (index < 0) {\r\n        return null;\r\n    }\r\n    return (React.createElement(\"g\", { transform: `translate(${size.labels.w + data.cs.x(d)}, 0)`, \"data-upset\": \"cs-ss\", \"data-i\": index },\r\n        React.createElement(\"rect\", { width: width, height: height, className: `selectionHint-${style.id}` }),\r\n        d.sets.size > 1 && (React.createElement(\"line\", { x1: cx, y1: data.sets.y(data.sets.v.find((p) => data.cs.has(d, p))) + cy - (data.r - 1), x2: cx, y2: data.sets.y(data.sets.rv.find((p) => data.cs.has(d, p))) + cy + (data.r - 1), className: `upsetSelectionLine-${data.id}`, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined, 'stroke') })),\r\n        data.sets.v\r\n            .filter((s) => data.cs.has(d, s))\r\n            .map((s) => (React.createElement(UpSetDot, { key: data.toKey(s), r: r * 1.1, cx: cx, cy: data.sets.y(s) + cy, name: style.tooltips ? s.name : '', className: clsx(`fillSelection-${style.id}`, `pnone-${style.id}`, style.classNames.dot), style: mergeColor(style.styles.dot, !style.selectionColor ? s.color : undefined) })))));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst EMPTY_ARRAY = [];\r\nfunction UpSetSelection({ size, data, style, selection, hasHover, }) {\r\n    const empty = style.emptySelection;\r\n    const selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);\r\n    const selectionName = generateSelectionName(selection);\r\n    const someAddon = size.sets.addons.some((s) => s.renderSelection != null) || size.cs.addons.some((s) => s.renderSelection != null);\r\n    const selectionElemOverlap = selection && typeof selection !== 'function' && someAddon\r\n        ? elemElemOverlapOf(Array.isArray(selection) ? selection : selection.elems, data.toElemKey)\r\n        : null;\r\n    function wrapAddon(addon) {\r\n        return Object.assign(Object.assign({}, addon), { render: (props) => {\r\n                const overlap = selectionElemOverlap ? selectionElemOverlap(props.set) : null;\r\n                return addon.renderSelection\r\n                    ? addon.renderSelection(Object.assign({ selection, selectionColor: style.selectionColor || props.set.color || 'orange', overlap }, props))\r\n                    : null;\r\n            } });\r\n    }\r\n    return (React.createElement(\"g\", { className: hasHover ? `pnone-${style.id}` : undefined },\r\n        (selection || empty) && (React.createElement(CombinationSelectionChart, { data: data, size: size, style: style, transform: `translate(${size.cs.x},${size.cs.y})`, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName, combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY : size.cs.addons.map(wrapAddon) })),\r\n        (selection || empty) && (React.createElement(SetSelectionChart, { data: data, size: size, style: style, transform: `translate(${size.sets.x},${size.sets.y})`, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName, setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY : size.sets.addons.map(wrapAddon) })),\r\n        React.createElement(\"g\", { transform: `translate(${size.labels.x},${size.labels.y})` },\r\n            isSetLike(selection) && React.createElement(LabelsSelection, { data: data, size: size, style: style, selection: selection }),\r\n            isSetLike(selection) && React.createElement(UpSetSelectionChart, { data: data, size: size, style: style, selection: selection }))));\r\n}\n\nfunction propRule(value, prop = 'font-size') {\r\n    return value ? `${prop}: ${value};` : '';\r\n}\r\nfunction baseRules(styleId, theme, fontFamily, fontSizes) {\r\n    const hasS = [];\r\n    if (theme.hasSelectionColor) {\r\n        hasS.push(`fill: ${theme.hasSelectionColor};`);\r\n    }\r\n    const hasSelectionOpacity = theme.hasSelectionOpacity != null && theme.hasSelectionOpacity >= 0;\r\n    if (hasSelectionOpacity) {\r\n        hasS.push(`fill-opacity: ${theme.hasSelectionOpacity};`);\r\n    }\r\n    return {\r\n        p: propRule,\r\n        root: `\n  .root-${styleId} {\n    ${propRule(fontFamily, 'font-family')}\n  }\n  `,\r\n        text: `\n  .titleTextStyle-${styleId} {\n    fill: ${theme.textColor};\n    ${propRule(fontSizes.title)}\n  }\n  .descTextStyle-${styleId} {\n    fill: ${theme.textColor};\n    ${propRule(fontSizes.description)}\n  }\n\n  .legendTextStyle-${styleId} {\n    fill: ${theme.textColor};\n    ${propRule(fontSizes.legend)}\n    text-anchor: middle;\n    dominant-baseline: hanging;\n    pointer-events: none;\n  }\n  `,\r\n        hasSFill: hasS.join(' '),\r\n        hasSStroke: hasS.join(' ').replace('fill:', 'stroke:').replace('fill-', 'stroke-'),\r\n        fill: `\n  .fillPrimary-${styleId} { fill: ${theme.color}; fill-opacity: ${theme.opacity}; }\n  .fillOverflow1-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[0]}; }\n  .fillOverflow2-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[1]}; }\n  ${hasS.length > 0 ? `.root-${styleId}[data-selection] .fillPrimary-${styleId} { ${hasS.join(' ')} }` : ''}\n  ${hasSelectionOpacity\r\n            ? `\n      .root-${styleId}[data-selection] .fillOverflow1-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[0]}; }\n      .root-${styleId}[data-selection] .fillOverflow2-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[1]}; }`\r\n            : ''}\n  ${theme.selectionColor ? `.fillSelection-${styleId} { fill: ${theme.selectionColor}; }` : ''}\n  .fillTransparent-${styleId} { fill: transparent; }\n\n  .selectionHint-${styleId} {\n    fill: transparent;\n    pointer-events: none;\n    ${propRule(theme.selectionColor, 'stroke')}\n  }\n  .clickAble-${styleId} {\n    cursor: pointer;\n  }\n\n  .startText-${styleId} {\n    text-anchor: start;\n  }\n  .endText-${styleId} {\n    text-anchor: end;\n  }\n  .pnone-${styleId} {\n    pointer-events: none;\n  }`,\r\n        export: `\n  .exportTextStyle-${styleId} {\n    fill: ${theme.textColor};\n    ${propRule(fontSizes.exportLabel)}\n  }\n  .exportButtons-${styleId} {\n    text-anchor: middle;\n  }\n  .exportButton-${styleId} {\n    cursor: pointer;\n    opacity: 0.5;\n  }\n  .exportButton-${styleId}:hover {\n    opacity: 1;\n  }\n  .exportButton-${styleId} > rect {\n    fill: none;\n    stroke: ${theme.textColor};\n  }\n  `,\r\n    };\r\n}\n\nfunction useHandler(p) {\r\n    const onClick = p.onClick;\r\n    return useMemo(() => ({\r\n        hasClick: onClick != null,\r\n        hasHover: p.onHover != null,\r\n        onClick: wrap(onClick),\r\n        onMouseEnter: wrap(p.onHover),\r\n        onContextMenu: wrap(p.onContextMenu),\r\n        onMouseLeave: p.onHover ? (evt) => p.onHover(null, evt.nativeEvent, []) : undefined,\r\n        onMouseMove: wrap(p.onMouseMove),\r\n        reset: (evt) => (onClick ? onClick(null, evt.nativeEvent, []) : null),\r\n    }), [onClick, p.onHover, p.onContextMenu, p.onMouseMove]);\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\n/**\r\n * UpSetJS main pure functional stateless React component, the generic argument T refers to the type of the elements\r\n *\r\n * with React.forwardRef support to specify a reference to the SVG element\r\n */\r\nconst UpSetJS = /*!#__PURE__*/ React.forwardRef(function UpSetJS(props, ref) {\r\n    var _a;\r\n    const p = fillDefaults(props);\r\n    const { selection = null, queries = [], fontSizes } = p;\r\n    // generate a \"random\" but attribute stable id to avoid styling conflicts\r\n    const styleId = useMemo(() => p.id\r\n        ? p.id\r\n        : generateId([\r\n            p.fontFamily,\r\n            fontSizes.axisTick,\r\n            fontSizes.barLabel,\r\n            fontSizes.chartLabel,\r\n            fontSizes.legend,\r\n            fontSizes.setLabel,\r\n            fontSizes.title,\r\n            fontSizes.exportLabel,\r\n            fontSizes.description,\r\n            p.textColor,\r\n            p.hoverHintColor,\r\n            p.color,\r\n            p.hasSelectionColor,\r\n            p.selectionColor,\r\n            p.notMemberColor,\r\n            p.alternatingBackgroundColor,\r\n            p.opacity,\r\n            p.hasSelectionOpacity,\r\n        ]), [\r\n        p.id,\r\n        p.fontFamily,\r\n        fontSizes.axisTick,\r\n        fontSizes.barLabel,\r\n        fontSizes.chartLabel,\r\n        fontSizes.legend,\r\n        fontSizes.setLabel,\r\n        fontSizes.title,\r\n        fontSizes.exportLabel,\r\n        fontSizes.description,\r\n        p.textColor,\r\n        p.hoverHintColor,\r\n        p.color,\r\n        p.hasSelectionColor,\r\n        p.selectionColor,\r\n        p.notMemberColor,\r\n        p.alternatingBackgroundColor,\r\n        p.opacity,\r\n        p.hasSelectionOpacity,\r\n    ]);\r\n    const styleInfo = useMemo(() => deriveStyleDependent$1(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips, p.setLabelAlignment), [\r\n        p.theme,\r\n        p.styles,\r\n        p.classNames,\r\n        p.barLabelOffset,\r\n        p.combinationName,\r\n        p.combinationNameAxisOffset,\r\n        p.setName,\r\n        p.setNameAxisOffset,\r\n        styleId,\r\n        p.selectionColor,\r\n        p.emptySelection,\r\n        p.title,\r\n        p.description,\r\n        p.tooltips,\r\n        p.setLabelAlignment,\r\n    ]);\r\n    const sizeInfo = useMemo(() => deriveSizeDependent(p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding), [\r\n        p.width,\r\n        p.height,\r\n        p.padding,\r\n        p.barPadding,\r\n        p.widthRatios,\r\n        p.heightRatios,\r\n        p.setAddons,\r\n        p.combinationAddons,\r\n        p.id,\r\n        p.setAddonPadding,\r\n        p.combinationAddonPadding,\r\n    ]);\r\n    const dataInfo = useMemo(() => deriveDataDependent(p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.dotPadding, p.barPadding, parseFontSize(fontSizes.axisTick), p.combinationAddons, p.toKey, p.toElemKey, p.id, p.setMaxScale, p.combinationMaxScale), [\r\n        p.sets,\r\n        p.combinations,\r\n        sizeInfo,\r\n        p.numericScale,\r\n        p.bandScale,\r\n        p.barLabelOffset,\r\n        fontSizes.barLabel,\r\n        p.dotPadding,\r\n        p.barPadding,\r\n        fontSizes.axisTick,\r\n        p.combinationAddons,\r\n        p.toKey,\r\n        p.toElemKey,\r\n        p.id,\r\n        p.setMaxScale,\r\n        p.combinationMaxScale,\r\n    ]);\r\n    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);\r\n    const h = useHandler(p);\r\n    const rules = `\n  ${rulesHelper.root}\n  ${rulesHelper.text}\n\n  .axisTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.axisTick)}\n    text-anchor: middle;\n  }\n  .barTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.barLabel)}\n  }\n  .cBarTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.barLabel)}\n    text-anchor: middle;\n  }\n  .sBarTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.barLabel)}\n    text-anchor: end;\n    dominant-baseline: central;\n  }\n  .hoverBarTextStyle-${styleId} {\n    ${rulesHelper.p(fontSizes.barLabel)}\n    fill: ${p.hoverHintColor};\n    display: none;\n    text-anchor: middle;\n  }\n  .setTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.setLabel)}\n    text-anchor: ${toAnchor(p.setLabelAlignment)};\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.chartLabel)}\n    text-anchor: middle;\n  }\n  .sChartTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.chartLabel)}\n    text-anchor: middle;\n    dominant-baseline: hanging;\n  }\n\n  ${rulesHelper.fill}\n  .fillNotMember-${styleId} { fill: ${p.notMemberColor}; }\n  .fillAlternating-${styleId} { fill: ${p.alternatingBackgroundColor || 'transparent'}; }\n\n  .axisLine-${styleId} {\n    fill: none;\n    stroke: ${p.textColor};\n  }\n  .hoverBar-${styleId} {\n    fill: transparent;\n  }\n\n  .interactive-${styleId}:hover > .hoverBar-${styleId} {\n    stroke: ${p.hoverHintColor};\n  }\n  .interactive-${styleId}:hover > .hoverBarTextStyle-${styleId} {\n    display: unset;\n  }\n\n  ${rulesHelper.export}\n\n  .upsetLine-${dataInfo.id} {\n    stroke-width: ${dataInfo.r * 0.6};\n    stroke: ${p.color};\n    stroke-opacity: ${p.opacity};\n  }\n  ${rulesHelper.hasSStroke\r\n        ? `.root-${styleId}[data-selection] .upsetLine-${dataInfo.id} { ${rulesHelper.hasSStroke} }`\r\n        : ''}\n\n  .upsetSelectionLine-${dataInfo.id} {\n    stroke-width: ${dataInfo.r * 0.6 * 1.1};\n    ${rulesHelper.p(p.selectionColor, 'stroke')}\n    pointer-events: none;\n  }\n\n  ${queries\r\n        .map((q, i) => `.fillQ${i}-${dataInfo.id} {\n    fill: ${q.color};\n  }`)\r\n        .join('\\n')}\n  `;\r\n    const exportChart = useCallback((evt) => {\r\n        const svg = evt.currentTarget.closest('svg');\r\n        const type = (evt.currentTarget.dataset.type || 'png');\r\n        switch (type) {\r\n            case 'vega':\r\n                exportVegaLite(svg);\r\n                break;\r\n            case 'dump':\r\n                exportDump(svg, props, dataInfo);\r\n                break;\r\n            case 'share':\r\n                exportSharedLink(props, dataInfo);\r\n                break;\r\n            case 'svg':\r\n            case 'png':\r\n                exportSVG(svg, {\r\n                    type,\r\n                    toRemove: `.${evt.currentTarget.getAttribute('class')}`,\r\n                });\r\n        }\r\n    }, [dataInfo, props]);\r\n    const selectionName = generateSelectionName(selection);\r\n    return (React.createElement(\"svg\", { id: p.id, className: clsx(`root-${styleId}`, p.className), style: p.style, width: p.width, height: p.height, ref: ref, viewBox: `0 0 ${p.width} ${p.height}`, \"data-theme\": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light', \"data-selection\": selectionName ? selectionName : undefined },\r\n        p.styleFactory(rules),\r\n        React.createElement(\"defs\", null,\r\n            React.createElement(\"clipPath\", { id: `clip-${sizeInfo.id}` },\r\n                React.createElement(\"rect\", { x: sizeInfo.sets.w, y: 0, width: sizeInfo.labels.w, height: sizeInfo.sets.h }))),\r\n        p.queryLegend && React.createElement(QueryLegend, { queries: queries, x: sizeInfo.legend.x, style: styleInfo, data: dataInfo }),\r\n        React.createElement(ExportButtons, { transform: `translate(${sizeInfo.w - 2},${sizeInfo.h - 3})`, styleId: styleId, exportButtons: p.exportButtons, exportChart: exportChart }),\r\n        React.createElement(\"g\", { transform: `translate(${p.padding},${p.padding})`, \"data-upset\": \"base\" },\r\n            p.onClick && (React.createElement(\"rect\", { width: sizeInfo.cs.x, height: sizeInfo.sets.y, onClick: h.reset, className: `fillTransparent-${styleId}` })),\r\n            React.createElement(UpSetAxis, { size: sizeInfo, style: styleInfo, data: dataInfo }),\r\n            React.createElement(UpSetChart, { size: sizeInfo, style: styleInfo, data: dataInfo, h: h, setChildrenFactory: p.setChildrenFactory, combinationChildrenFactory: p.combinationChildrenFactory }),\r\n            React.createElement(UpSetSelection, { size: sizeInfo, style: styleInfo, data: dataInfo, hasHover: h.hasHover, selection: selection }),\r\n            React.createElement(UpSetQueries, { size: sizeInfo, style: styleInfo, data: dataInfo, hasHover: h.hasHover, queries: queries, secondary: p.onHover != null || selection != null })),\r\n        props.children));\r\n});\n\nfunction SVGWrapper({ rules, style, size, p, data, tRef, children, exportChart, selectionName, h, }) {\r\n    var _a, _b;\r\n    return (React.createElement(\"svg\", { id: p.id, className: clsx(`root-${style.id}`, p.className), style: p.style, width: p.width, height: p.height, ref: tRef, viewBox: `0 0 ${p.width} ${p.height}`, \"data-theme\": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light', \"data-selection\": selectionName ? selectionName : undefined },\r\n        p.styleFactory(rules),\r\n        p.onClick && React.createElement(\"rect\", { width: size.w, height: size.h, onClick: h.reset, className: `fillTransparent-${style.id}` }),\r\n        p.queryLegend && React.createElement(QueryLegend, { queries: (_b = p.queries) !== null && _b !== void 0 ? _b : [], x: size.legend.x, style: style, data: data }),\r\n        React.createElement(ExportButtons, { transform: `translate(${size.w - 2},${size.h - 3})`, styleId: style.id, exportButtons: p.exportButtons, exportChart: exportChart }),\r\n        React.createElement(\"g\", { transform: `translate(${p.padding},${p.padding})`, \"data-upset\": \"base\" }, children),\r\n        p.children));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction generateArcSlicePath(s, refs, p = 0) {\r\n    if (s.path) {\r\n        return s.path;\r\n    }\r\n    return `M ${s.x1 - p},${s.y1 - p} ${s.arcs\r\n        .map((arc) => {\r\n        const ref = refs[arc.ref].l;\r\n        const rx = isEllipse(ref) ? ref.rx : ref.r;\r\n        const ry = isEllipse(ref) ? ref.ry : ref.r;\r\n        const rot = isEllipse(ref) ? ref.rotation : 0;\r\n        return `A ${rx - p} ${ry - p} ${rot} ${arc.large ? 1 : 0} ${arc.sweep ? 1 : 0} ${arc.x2 - p} ${arc.y2 - p}`;\r\n    })\r\n        .join(' ')}`;\r\n}\n\nfunction SelectionPattern(p) {\r\n    var _a;\r\n    if (p.v >= 1 || p.v <= 0) {\r\n        return null;\r\n    }\r\n    const ratio = Math.round(p.v * 10.0) / 100;\r\n    return (React.createElement(\"defs\", null,\r\n        React.createElement(\"pattern\", { id: p.id, width: \"1\", height: \"0.1\", patternContentUnits: \"objectBoundingBox\", patternTransform: `rotate(${(_a = p.rotate) !== null && _a !== void 0 ? _a : 0})` },\r\n            p.bgFilled && (React.createElement(\"rect\", { x: \"0\", y: \"0\", width: \"1\", height: \"0.1\", style: { fill: p.bgFill }, className: `fillPrimary-${p.styleId}` })),\r\n            React.createElement(\"rect\", { x: \"0\", y: \"0\", width: \"1\", height: ratio, className: `fill${p.suffix}`, style: p.fill ? { fill: p.fill } : undefined }))));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction sliceRotate(slice, center) {\r\n    if (slice.text.x === center.cx) {\r\n        return 0;\r\n    }\r\n    if (slice.text.x > center.cx) {\r\n        return slice.text.y <= center.cy ? 60 : -60;\r\n    }\r\n    return slice.text.y <= center.cy ? -60 : 60;\r\n}\r\nfunction generateTitle(d, s, sName, secondary, qs, queries, data, cx) {\r\n    const dc = data.format(d.cardinality);\r\n    const baseName = !sName ? d.name : `${d.name} ∩ ${sName}`;\r\n    const baseCardinality = !sName ? dc : `${data.format(s)}/${dc}`;\r\n    if (qs.length === 0) {\r\n        return {\r\n            tooltip: `${baseName}: ${baseCardinality}`,\r\n            title: d.type === 'set' ? (React.createElement(React.Fragment, null,\r\n                React.createElement(\"tspan\", { dy: \"-0.6em\" }, d.name),\r\n                React.createElement(\"tspan\", { x: cx, dy: \"1.2em\" }, baseCardinality))) : (baseCardinality),\r\n        };\r\n    }\r\n    if (qs.length === 1 && !secondary && !sName) {\r\n        return {\r\n            tooltip: `${d.name} ∩ ${queries[0].name}: ${data.format(qs[0])}/${dc}`,\r\n            title: d.type === 'set' ? (React.createElement(React.Fragment, null,\r\n                React.createElement(\"tspan\", { dy: \"-0.6em\" }, d.name),\r\n                React.createElement(\"tspan\", { x: cx, dy: \"1.2em\" }, `${data.format(qs[0])}/${dc}`))) : (`${data.format(qs[0])}/${dc}`),\r\n        };\r\n    }\r\n    const queryLine = (React.createElement(\"tspan\", { x: cx, dy: \"1.2em\" }, queries.map((q, i) => (React.createElement(React.Fragment, { key: q.name },\r\n        React.createElement(\"tspan\", { className: `fillQ${i}-${data.id}` }, '⬤'),\r\n        React.createElement(\"tspan\", null, ` ${data.format(qs[i])}/${dc}${i < queries.length - 1 ? ' ' : ''}`))))));\r\n    return {\r\n        tooltip: `${baseName}: ${baseCardinality}\\n${queries\r\n            .map((q, i) => `${d.name} ∩ ${q.name}: ${data.format(qs[i])}/${dc}`)\r\n            .join('\\n')}`,\r\n        title: d.type === 'set' ? (React.createElement(React.Fragment, null,\r\n            React.createElement(\"tspan\", { dy: \"-1.2em\" }, d.name),\r\n            React.createElement(\"tspan\", { x: cx, dy: \"1.2em\" }, baseCardinality),\r\n            queryLine)) : (React.createElement(React.Fragment, null,\r\n            React.createElement(\"tspan\", { dy: \"-0.6em\" }, baseCardinality),\r\n            queryLine)),\r\n    };\r\n}\r\nfunction VennArcSliceSelection({ slice, d, i, data, style, elemOverlap, selected, selectionName, h, queries, size, fill, qs, }) {\r\n    const p = generateArcSlicePath(slice, data.sets.d);\r\n    const rotate = sliceRotate(slice, size.area);\r\n    const o = elemOverlap ? elemOverlap(d) : 0;\r\n    const fillFullSelection = (o === d.cardinality && d.cardinality > 0) || selected;\r\n    const className = clsx(`arc-${style.id}`, o === 0 && !selected && `${fill ? 'fillPrimary' : 'arcP'}-${style.id}`, fillFullSelection && `fillSelection-${style.id}`, style.classNames.set);\r\n    const id = `upset-${style.id}-${i}`;\r\n    const secondary = elemOverlap != null || h.onMouseLeave != null;\r\n    const qsOverlaps = qs.map((q) => q(d));\r\n    const { title, tooltip } = generateTitle(d, o, selectionName, secondary, qsOverlaps, queries, data, slice.text.x);\r\n    return (React.createElement(\"g\", null,\r\n        React.createElement(SelectionPattern, { id: id, v: o === 0 ? 0 : o / d.cardinality, suffix: `Selection-${style.id}`, rotate: rotate, bgFill: d.color, bgFilled: d.color != null || fill, fill: !style.selectionColor ? d.color : undefined, styleId: style.id }),\r\n        React.createElement(\"path\", { onMouseEnter: h.onMouseEnter(d, []), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, []), onContextMenu: h.onContextMenu(d, []), onMouseMove: h.onMouseMove(d, []), d: p, className: className, style: mergeColor(style.styles.set, o > 0 && o < d.cardinality ? `url(#${id})` : !fillFullSelection || !style.selectionColor ? d.color : undefined) }, style.tooltips && React.createElement(\"title\", null, tooltip)),\r\n        React.createElement(\"text\", { x: slice.text.x, y: slice.text.y, className: clsx(`${d.type === 'set' ? 'set' : 'value'}TextStyle-${style.id}`, `pnone-${style.id}`, d.type === 'set' ? style.classNames.setLabel : style.classNames.valueLabel\r\n            // circle.align === 'left' && `startText-${style.id}`,\r\n            // circle.align === 'right' && `endText-${style.id}`\r\n            ) }, title)));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveVennDataDependent(sets, combinations, size, layout, format, toKey, toElemKey, id, setLabelOffsets) {\r\n    const ss = sets.length > layout.maxSets ? sets.slice(0, layout.maxSets) : sets;\r\n    const { cs, setKeys, csKeys } = calculateCombinations(ss, toKey, combinations);\r\n    const l = layout.compute(ss, cs, size.area.w, size.area.h);\r\n    return {\r\n        id: id ? id : generateId(),\r\n        sets: {\r\n            d: l.sets.map((l, i) => ({\r\n                v: ss[i],\r\n                l,\r\n                key: setKeys[i],\r\n                offset: setLabelOffsets != null && i < setLabelOffsets.length ? setLabelOffsets[i] : { x: 0, y: 0 },\r\n            })),\r\n            v: ss,\r\n            format,\r\n        },\r\n        format,\r\n        cs: {\r\n            d: l.intersections.map((l, i) => ({ v: cs[i], l, key: csKeys[i] })),\r\n            v: cs,\r\n            has: (v, s) => {\r\n                const sk = toKey(s);\r\n                return Array.from(v.sets).some((ss) => toKey(ss) === sk);\r\n            },\r\n        },\r\n        toKey,\r\n        toElemKey,\r\n        overlapGuesser: generateDistinctOverlapFunction(cs, noGuessPossible, toKey),\r\n    };\r\n}\r\nfunction calculateCombinations(ss, toKey, combinations, options = { min: 1 }) {\r\n    const setKeys = ss.map(toKey);\r\n    let cs = [];\r\n    if (areCombinations(combinations)) {\r\n        const given = new Map(combinations.map((c) => [Array.from(c.sets).map(toKey).sort().join('#'), c]));\r\n        const helperSets = ss.map((s) => ({\r\n            type: 'set',\r\n            cardinality: 0,\r\n            elems: [],\r\n            name: s.name,\r\n            s,\r\n        }));\r\n        // generate dummy ones and map to given data\r\n        cs = generateCombinations(helperSets, Object.assign({\r\n            type: 'distinctIntersection',\r\n            empty: true,\r\n            order: ['degree:asc', 'group:asc'],\r\n        }, options)).map((c) => {\r\n            const key = Array.from(c.sets)\r\n                .map((s) => toKey(s.s))\r\n                .sort()\r\n                .join('#');\r\n            if (given.has(key)) {\r\n                return given.get(key);\r\n            }\r\n            // generate a dummy one\r\n            return {\r\n                name: c.name,\r\n                cardinality: 0,\r\n                degree: c.degree,\r\n                elems: [],\r\n                sets: new Set(Array.from(c.sets).map((s) => s.s)),\r\n                type: 'distinctIntersection',\r\n            };\r\n        });\r\n    }\r\n    else {\r\n        cs = generateCombinations(ss, Object.assign({\r\n            type: 'distinctIntersection',\r\n            empty: true,\r\n            order: ['degree:asc', 'group:asc'],\r\n        }, options, combinations !== null && combinations !== void 0 ? combinations : {}));\r\n    }\r\n    const csKeys = cs.map(toKey);\r\n    return { cs, setKeys, csKeys };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveVennSizeDependent(width, height, margin, id) {\r\n    const h = height - 2 * margin;\r\n    const w = width - 2 * margin;\r\n    const r = Math.min(w, h) / 2;\r\n    return {\r\n        id: id ? id : generateId(),\r\n        legend: {\r\n            x: width / 2,\r\n        },\r\n        area: {\r\n            w,\r\n            h,\r\n            cx: w / 2,\r\n            cy: h / 2,\r\n            r,\r\n        },\r\n        margin: margin,\r\n        w: width,\r\n        h: height,\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveVennStyleDependent(theme, styles, classNames, styleId, selectionColor, title, description, tooltips) {\r\n    return {\r\n        theme,\r\n        styles,\r\n        classNames: classNames,\r\n        id: styleId,\r\n        selectionColor,\r\n        title,\r\n        description,\r\n        tooltips,\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction useCreateCommon(p) {\r\n    const { queries = [], fontSizes } = p;\r\n    // generate a \"random\" but attribute stable id to avoid styling conflicts\r\n    const styleId = useMemo(() => p.id\r\n        ? p.id\r\n        : generateId([\r\n            p.fontFamily,\r\n            fontSizes.valueLabel,\r\n            fontSizes.legend,\r\n            fontSizes.setLabel,\r\n            fontSizes.title,\r\n            fontSizes.exportLabel,\r\n            fontSizes.description,\r\n            p.textColor,\r\n            p.color,\r\n            p.hasSelectionColor,\r\n            p.strokeColor,\r\n            p.valueTextColor,\r\n            p.selectionColor,\r\n            p.opacity,\r\n            p.hasSelectionOpacity,\r\n        ]), [\r\n        p.id,\r\n        p.fontFamily,\r\n        fontSizes.valueLabel,\r\n        fontSizes.legend,\r\n        fontSizes.setLabel,\r\n        fontSizes.title,\r\n        fontSizes.exportLabel,\r\n        fontSizes.description,\r\n        p.textColor,\r\n        p.color,\r\n        p.hasSelectionColor,\r\n        p.strokeColor,\r\n        p.valueTextColor,\r\n        p.selectionColor,\r\n        p.opacity,\r\n        p.hasSelectionOpacity,\r\n    ]);\r\n    const styleInfo = useMemo(() => deriveVennStyleDependent(p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips), [p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips]);\r\n    const sizeInfo = useMemo(() => deriveVennSizeDependent(p.width, p.height, p.padding, p.id), [p.width, p.height, p.padding, p.id]);\r\n    const h = useHandler(p);\r\n    const qs = React.useMemo(() => queries.map((q) => queryOverlap(q, 'intersection', p.toElemKey)), [queries, p.toElemKey]);\r\n    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);\r\n    return {\r\n        styleId,\r\n        size: sizeInfo,\r\n        style: styleInfo,\r\n        h,\r\n        qs,\r\n        rulesHelper,\r\n    };\r\n}\r\nfunction useExportChart(dataInfo, props, mode) {\r\n    return useCallback((evt) => {\r\n        const svg = evt.currentTarget.closest('svg');\r\n        const type = (evt.currentTarget.dataset.type || 'png');\r\n        switch (type) {\r\n            case 'dump':\r\n                exportDump(svg, props, dataInfo, mode);\r\n                break;\r\n            case 'share':\r\n                exportSharedLink(props, dataInfo, mode);\r\n                break;\r\n            case 'svg':\r\n            case 'png':\r\n                exportSVG(svg, {\r\n                    type,\r\n                    toRemove: `.${evt.currentTarget.getAttribute('class')}`,\r\n                });\r\n        }\r\n    }, [dataInfo, props, mode]);\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst VennDiagram = /*!#__PURE__*/ React.forwardRef(function VennDiagram(props, ref) {\r\n    const p = fillVennDiagramDefaults(props);\r\n    const { selection = null, queries = [], fontSizes } = p;\r\n    const v = useCreateCommon(p);\r\n    const { size, style, rulesHelper } = v;\r\n    const dataInfo = useMemo(() => deriveVennDataDependent(p.sets, p.combinations, size, p.layout, p.valueFormat, p.toKey, p.toElemKey, p.id, p.setLabelOffsets), [p.sets, p.combinations, size, p.valueFormat, p.toKey, p.toElemKey, p.id, p.layout, p.setLabelOffsets]);\r\n    const selectionKey = selection != null && isSetLike$1(selection) ? p.toKey(selection) : null;\r\n    const selectionOverlap = selection == null ? null : generateSelectionOverlap(selection, dataInfo.overlapGuesser, dataInfo.toElemKey);\r\n    const selectionName = generateSelectionName(selection);\r\n    const rules = `\n  ${rulesHelper.root}\n  ${rulesHelper.text}\n\n  .valueTextStyle-${style.id} {\n    fill: ${p.valueTextColor};\n    ${rulesHelper.p(fontSizes.valueLabel)}\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .setTextStyle-${style.id} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.setLabel)}\n    text-anchor: middle;\n  }\n\n  .topText-${style.id} {\n    dominant-baseline: hanging;\n  }\n\n  .stroke-circle-${style.id} {\n    fill: none;\n    stroke: ${p.strokeColor};\n  }\n\n  .arc-${style.id} {\n    fill-rule: evenodd;\n  }\n  .arcP-${style.id} {\n    fill: transparent;\n    fill-opacity: ${p.opacity};\n  }\n  ${rulesHelper.fill}\n  ${rulesHelper.export}\n\n  ${rulesHelper.hasSFill ? `.root-${style.id}[data-selection] .arcP-${style.id} { ${rulesHelper.hasSFill} }` : ''}\n\n  ${queries\r\n        .map((q, i) => `.fillQ${i}-${dataInfo.id} {\n    fill: ${q.color};\n  }`)\r\n        .join('\\n')}\n  `;\r\n    const exportChart = useExportChart(dataInfo, p, 'venn');\r\n    const maxWidth = dataInfo.sets.d.reduce((acc, d) => Math.min(acc, d.l.cx - (isEllipse(d.l) ? d.l.rx : d.l.r)), size.area.w);\r\n    return (React.createElement(SVGWrapper, { rules: rules, style: style, selectionName: selectionName, size: size, p: p, data: dataInfo, tRef: ref, h: v.h, exportChart: exportChart },\r\n        React.createElement(UpSetTitle, { style: style, width: maxWidth }),\r\n        React.createElement(\"g\", { className: clsx(p.onClick && `clickAble-${style.id}`) }, dataInfo.sets.d.map((d, i) => (React.createElement(\"text\", { key: d.key, x: d.l.text.x + d.offset.x, y: d.l.text.y + d.offset.y, onClick: v.h.onClick(dataInfo.sets.v[i], []), onMouseEnter: v.h.onMouseEnter(dataInfo.sets.v[i], []), onMouseLeave: v.h.onMouseLeave, onContextMenu: v.h.onContextMenu(dataInfo.sets.v[i], []), onMouseMove: v.h.onMouseMove(dataInfo.sets.v[i], []), className: clsx(`setTextStyle-${style.id}`, `${d.l.align}Text-${style.id}`, `${d.l.verticalAlign}Text-${style.id}`, style.classNames.setLabel) },\r\n            style.tooltips && (React.createElement(\"title\", null,\r\n                dataInfo.sets.v[i].name,\r\n                \": \",\r\n                dataInfo.format(dataInfo.sets.v[i].cardinality))),\r\n            dataInfo.sets.v[i].name)))),\r\n        React.createElement(\"g\", { className: clsx(p.onClick && `clickAble-${style.id}`) }, dataInfo.cs.d.map((l, i) => (React.createElement(VennArcSliceSelection, { key: l.key, d: l.v, i: i, slice: l.l, size: size, style: style, data: dataInfo, fill: p.filled, h: v.h, selectionName: selectionName, selected: selectionKey === l.key || (isSet(selection) && dataInfo.cs.has(l.v, selection)), elemOverlap: selectionOverlap, queries: queries, qs: v.qs })))),\r\n        React.createElement(\"g\", null, dataInfo.sets.d.map((l) => isEllipse(l.l) ? (React.createElement(\"ellipse\", { key: l.key, rx: l.l.rx, ry: l.l.ry, transform: `translate(${l.l.cx},${l.l.cy})rotate(${l.l.rotation})`, className: clsx(`stroke-circle-${style.id}`, style.classNames.set), style: style.styles.set })) : (React.createElement(\"circle\", { key: l.key, cx: l.l.cx, cy: l.l.cy, r: l.l.r, className: clsx(`stroke-circle-${style.id}`, style.classNames.set), style: style.styles.set }))))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst KMapCell = /*!#__PURE__*/ React.memo(function KMapCell({ d, i, h, className, data, style }) {\r\n    const l = data.cs.l[i];\r\n    const y = data.cs.scale(d.cardinality);\r\n    const x = (data.cell - data.cs.bandWidth) / 2;\r\n    return (React.createElement(\"g\", { transform: `translate(${l.x}, ${l.y})`, onMouseEnter: h.onMouseEnter(d, []), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, []), onContextMenu: h.onContextMenu(d, []), onMouseMove: h.onMouseMove(d, []), className: className, \"data-cardinality\": d.cardinality },\r\n        style.tooltips && (React.createElement(\"title\", null,\r\n            d.name,\r\n            \": \",\r\n            data.sets.format(d.cardinality))),\r\n        React.createElement(\"rect\", { width: data.cell, height: data.cell, className: `fillTransparent-${style.id}` }),\r\n        React.createElement(\"rect\", { x: x, y: y, height: data.cell - y, width: data.cs.bandWidth, className: clsx(`fillPrimary-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }),\r\n        React.createElement(\"text\", { y: y - style.barLabelOffset, x: data.cell / 2, style: style.styles.barLabel, className: clsx(`barTextStyle-${style.id}`, style.classNames.barLabel) }, data.sets.format(d.cardinality))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction generateGridPath(cell, vCells, hCells, level) {\r\n    const h = cell * vCells;\r\n    const w = cell * hCells;\r\n    return [level.x.map((x) => `M ${x * cell},0 l0,${h}`), level.y.map((y) => `M 0,${y * cell} l${w},0`)]\r\n        .flat()\r\n        .join(' ');\r\n}\r\nconst KMapChart = /*!#__PURE__*/ React.memo(function KMapChart({ data, style, size, h }) {\r\n    const csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;\r\n    return (React.createElement(\"g\", null,\r\n        React.createElement(\"g\", { transform: `translate(${size.w - csNameOffset - 2}, ${size.h - data.cell - 50})` },\r\n            React.createElement(Axis, { scale: data.cs.scale, orient: \"left\", size: data.cell, start: data.cs.barLabelFontSize, style: style }),\r\n            React.createElement(\"text\", { className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${data.cell})rotate(-90)` }, style.cs.name)),\r\n        React.createElement(\"g\", null,\r\n            data.sets.l.map((l, i) => {\r\n                const s = data.sets.v[i];\r\n                const name = s.name;\r\n                return (React.createElement(\"g\", { key: name, onClick: h.onClick(s, []), onMouseEnter: h.onMouseEnter(s, []), onMouseLeave: h.onMouseLeave, onContextMenu: h.onContextMenu(s, []), onMouseMove: h.onMouseMove(s, []), className: clsx(h.hasClick && `clickAble-${style.id}`) }, l.text.map((p, i) => (React.createElement(\"text\", { key: i, transform: `translate(${p.x},${p.y})${!l.hor ? 'rotate(-90)' : ''}`, className: clsx(`setTextStyle-${style.id}`) }, name)))));\r\n            }),\r\n            data.sets.l.map((l, i) => {\r\n                const name = data.sets.v[i].name;\r\n                return (React.createElement(React.Fragment, { key: name }, l.notText.map((p, i) => (React.createElement(\"text\", { key: i, transform: `translate(${p.x},${p.y})${!l.hor ? 'rotate(-90)' : ''}`, className: clsx(`setTextStyle-${style.id}`, `not-${style.id}`) }, name)))));\r\n            })),\r\n        React.createElement(\"g\", { className: clsx(h.hasClick && `clickAble-${style.id}`) }, data.cs.v.map((c, i) => {\r\n            return React.createElement(KMapCell, { key: data.cs.keys[i], d: c, i: i, h: h, style: style, data: data });\r\n        })),\r\n        React.createElement(\"g\", { transform: `translate(${data.grid.x}, ${data.grid.y})` }, data.grid.levels.map((l, i) => (React.createElement(\"path\", { key: i, d: generateGridPath(data.cell, data.grid.vCells, data.grid.hCells, l), className: `gridStyle-${style.id} gridStyle-${style.id}-${i}` }))))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction KMapQueries$1({ data, style, elemOverlap, secondary, tooltip, suffix, empty, }) {\r\n    const width = data.cs.bandWidth;\r\n    const offset = (data.cell - width) / 2;\r\n    const className = clsx(`fill${suffix}`, !tooltip && `pnone-${style.id}`, style.classNames.bar);\r\n    return (React.createElement(\"g\", { \"data-upset\": secondary ? 'cs-q' : 'cs-s' }, data.cs.v.map((d, i) => {\r\n        const l = data.cs.l[i];\r\n        const key = data.cs.keys[i];\r\n        if (empty && !secondary) {\r\n            return (React.createElement(\"rect\", { key: key, x: l.x + offset, y: l.y + data.cell, height: 0, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, tooltip && React.createElement(\"title\", null)));\r\n        }\r\n        const o = elemOverlap(d);\r\n        if (o === 0) {\r\n            return null;\r\n        }\r\n        const y = data.cs.scale(o);\r\n        const title = tooltip && React.createElement(\"title\", null, `${d.name} ∩ ${tooltip}: ${o}`);\r\n        return secondary ? (React.createElement(\"path\", { key: key, transform: `translate(${l.x + offset}, ${l.y + y})`, d: `M0,-1 l${width},0 l0,2 l${-width},0 L-${data.triangleSize},-${data.triangleSize} L-${data.triangleSize},${data.triangleSize} Z`, className: className, \"data-i\": i, \"data-cardinality\": o, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (React.createElement(\"rect\", { key: key, x: l.x + offset, y: l.y + y, height: data.cell - y, \"data-i\": i, \"data-cardinality\": o, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));\r\n    })));\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst KMapQueries = /*!#__PURE__*/ React.memo(function KMapQueries({ data, style, hasHover, secondary, queries, }) {\r\n    const qs = useMemo(() => queries.map((q) => (Object.assign(Object.assign({}, q), { overlap: queryOverlap(q, 'intersection', data.toElemKey) }))), [queries, data.toElemKey]);\r\n    return (React.createElement(\"g\", { className: hasHover && !secondary ? `pnone-${style.id}` : undefined }, qs.map((q, i) => (React.createElement(KMapQueries$1, { key: q.name, data: data, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name })))));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction KMapSelection({ data, style, selection, hasHover, }) {\r\n    const empty = style.emptySelection;\r\n    const selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);\r\n    const selectionName = generateSelectionName(selection);\r\n    return (React.createElement(\"g\", { className: hasHover ? `pnone-${style.id}` : undefined }, (selection || empty) && (React.createElement(KMapQueries$1, { data: data, style: style, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName }))));\r\n}\n\nfunction ranged(count, cb) {\r\n    return Array(count)\r\n        .fill(0)\r\n        .map((_, i) => cb(i));\r\n}\r\nfunction generateLevels(numSets) {\r\n    // all lines and the value is the thickness\r\n    const lines = Array(Math.pow(2, numSets)).fill(0);\r\n    ranged(numSets, (i) => {\r\n        const shift = Math.pow(2, i);\r\n        for (let i = 0; i < lines.length; i += shift) {\r\n            lines[i]++;\r\n        }\r\n    });\r\n    const levels = ranged(Math.max(numSets, 1), () => []);\r\n    lines.forEach((l, i) => {\r\n        const level = Math.max(0, l - 1);\r\n        // l -1 cause l is at least 1\r\n        levels[level].push(i);\r\n    });\r\n    // push the last index to the last level\r\n    levels[levels.length - 1].push(lines.length);\r\n    return levels;\r\n}\r\nfunction generate(sets, cs, has, options) {\r\n    const { xBefore, yBefore, cell, hCells, vCells, horizontalSets, verticalSets } = bounds(sets.length, options);\r\n    const s = setLabels(sets.length, options);\r\n    const shifts = generateShiftLookup(sets, hCells, vCells, has);\r\n    const c = cs.map((c) => {\r\n        const [i, j] = shifts.reduceRight((acc, s) => s(c, acc), [0, 0]);\r\n        return {\r\n            x: xBefore + i * cell,\r\n            y: yBefore + j * cell,\r\n        };\r\n    });\r\n    const hLevels = generateLevels(horizontalSets);\r\n    const vLevels = generateLevels(verticalSets);\r\n    return {\r\n        s,\r\n        c,\r\n        cell,\r\n        grid: {\r\n            x: xBefore,\r\n            y: yBefore,\r\n            hCells,\r\n            vCells,\r\n            levels: hLevels.map((l, i) => ({\r\n                x: l,\r\n                y: i < vLevels.length ? vLevels[i] : [],\r\n            })),\r\n        },\r\n    };\r\n}\r\nfunction generateShiftLookup(sets, hCells, vCells, has) {\r\n    return sets.map((s, k) => {\r\n        const index = Math.floor(k / 2);\r\n        const hor = k % 2 === 0;\r\n        const numLabels = Math.pow(2, index);\r\n        const span = (hor ? hCells : vCells) / numLabels / 2;\r\n        return (cs, [i, j]) => {\r\n            if (has(cs, s)) {\r\n                return [i, j];\r\n            }\r\n            if (span > 1) {\r\n                // flip previous and shift\r\n                if (hor) {\r\n                    return [span - 1 - i + span, j];\r\n                }\r\n                return [i, span - 1 - j + span];\r\n            }\r\n            // shift only\r\n            if (hor) {\r\n                return [i + span, j];\r\n            }\r\n            return [i, j + span];\r\n        };\r\n    });\r\n}\r\nfunction setLabels(sets, options) {\r\n    const { xOffset, yOffset, cell, xBefore, yBefore, hCells, vCells } = bounds(sets, options);\r\n    const xAfterEnd = options.width - xOffset;\r\n    const yAfterEnd = options.height - yOffset;\r\n    return ranged(sets, (k) => {\r\n        const index = Math.floor(k / 2);\r\n        const hor = k % 2 === 0;\r\n        const numLabels = Math.pow(2, index);\r\n        const span = (hor ? hCells : vCells) / numLabels / 2;\r\n        const xPos = hor ? xBefore : yBefore;\r\n        const labels = [\r\n            {\r\n                v: true,\r\n                x: xPos + span * cell * 0.5,\r\n            },\r\n            {\r\n                v: false,\r\n                x: xPos + span * cell * 1.5,\r\n            },\r\n        ];\r\n        for (let i = 1; i <= index; i++) {\r\n            // duplicate and mirror\r\n            const offset = span * Math.pow(2, i) * cell;\r\n            const l = labels.length - 1;\r\n            labels.push(...labels.map((li, i) => ({\r\n                v: labels[l - i].v,\r\n                x: li.x + offset,\r\n            })));\r\n        }\r\n        const inAfterGroup = index % 2 === 1;\r\n        const withinGroupIndex = Math.floor(index / 2);\r\n        let yPos = 0;\r\n        if (inAfterGroup) {\r\n            const end = hor ? yAfterEnd : xAfterEnd;\r\n            yPos = end - options.labelHeight * (0.5 + withinGroupIndex);\r\n        }\r\n        else {\r\n            const start = hor ? yOffset : xOffset;\r\n            yPos = start + options.labelHeight * (0.5 + withinGroupIndex);\r\n        }\r\n        if (hor) {\r\n            return {\r\n                hor: true,\r\n                span,\r\n                text: labels.filter((d) => d.v).map((l) => ({ x: l.x, y: yPos })),\r\n                notText: labels.filter((d) => !d.v).map((l) => ({ x: l.x, y: yPos })),\r\n            };\r\n        }\r\n        return {\r\n            hor: false,\r\n            span,\r\n            text: labels.filter((d) => d.v).map((l) => ({ x: yPos, y: l.x })),\r\n            notText: labels.filter((d) => !d.v).map((l) => ({ x: yPos, y: l.x })),\r\n        };\r\n    });\r\n}\r\nfunction bounds(sets, options) {\r\n    const horizontalSets = Math.ceil(sets / 2);\r\n    const verticalSets = Math.floor(sets / 2);\r\n    const hCells = Math.pow(2, horizontalSets);\r\n    const vCells = Math.pow(2, verticalSets);\r\n    const cell = Math.floor(Math.min((options.width - options.labelHeight * verticalSets) / hCells, (options.height - options.labelHeight * horizontalSets) / vCells));\r\n    const xOffset = (options.width - hCells * cell - options.labelHeight * verticalSets) / 2;\r\n    const yOffset = (options.height - vCells * cell - options.labelHeight * horizontalSets) / 2;\r\n    const xBefore = xOffset + Math.ceil(verticalSets / 2) * options.labelHeight;\r\n    const yBefore = yOffset + Math.ceil(horizontalSets / 2) * options.labelHeight;\r\n    return { xOffset, horizontalSets, yOffset, verticalSets, cell, xBefore, yBefore, hCells, vCells };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveKarnaughDataDependent(sets, combinations, size, numericScale, barLabelFontSize, barPadding, setLabelFontSize, tickFontSize, toKey, toElemKey, id, combinationMaxScale) {\r\n    const numericScaleFactory = resolveNumericScale(numericScale);\r\n    const setKeys = sets.map(toKey);\r\n    const cs = areCombinations(combinations)\r\n        ? combinations\r\n        : generateCombinations(sets, Object.assign({\r\n            type: 'distinctIntersection',\r\n        }, combinations !== null && combinations !== void 0 ? combinations : {}));\r\n    const csKeys = cs.map(toKey);\r\n    const has = (v, s) => {\r\n        const sk = toKey(s);\r\n        return Array.from(v.sets).some((ss) => toKey(ss) === sk);\r\n    };\r\n    const labelHeight = Math.ceil(setLabelFontSize * 1.2);\r\n    const l = generate(sets, cs, has, {\r\n        width: size.area.w,\r\n        height: size.area.h,\r\n        labelHeight,\r\n    });\r\n    const maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : cs.reduce((acc, d) => Math.max(acc, d.cardinality), 0);\r\n    const scale = numericScaleFactory(maxCSCardinality, [l.cell, barLabelFontSize], {\r\n        orientation: 'vertical',\r\n        fontSizeHint: tickFontSize,\r\n    });\r\n    const bandWidth = Math.round(l.cell * (1 - barPadding));\r\n    const triangleSize = Math.min(Math.max(2, (bandWidth / 2) * barPadding), 5);\r\n    const guessLabelWidth = (v) => Math.floor((barLabelFontSize / 1.4) * 0.7 * scale.tickFormat()(v).length);\r\n    const largestCSLabelWidth = guessLabelWidth(maxCSCardinality);\r\n    return {\r\n        id: id ? id : generateId(),\r\n        grid: l.grid,\r\n        sets: {\r\n            keys: setKeys,\r\n            l: l.s,\r\n            v: sets,\r\n            labelHeight,\r\n            format: scale.tickFormat(),\r\n        },\r\n        triangleSize,\r\n        cell: l.cell,\r\n        cs: {\r\n            keys: csKeys,\r\n            l: l.c,\r\n            v: cs,\r\n            barLabelFontSize,\r\n            has,\r\n            scale,\r\n            bandWidth,\r\n            labelOffset: largestCSLabelWidth + 9 + 6,\r\n        },\r\n        toKey,\r\n        toElemKey,\r\n        overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey),\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction deriveStyleDependent(theme, styles, classNames, combinationName, combinationNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips) {\r\n    return {\r\n        theme,\r\n        styles,\r\n        classNames: classNames,\r\n        emptySelection,\r\n        id: styleId,\r\n        barLabelOffset,\r\n        selectionColor,\r\n        title,\r\n        description,\r\n        tooltips,\r\n        cs: {\r\n            name: combinationName,\r\n            offset: combinationNameAxisOffset,\r\n        },\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst KarnaughMap = /*!#__PURE__*/ React.forwardRef(function KarnaughMap(props, ref) {\r\n    const p = fillKarnaughMapDefaults(props);\r\n    const { queries = [], fontSizes, selection = null } = p;\r\n    // generate a \"random\" but attribute stable id to avoid styling conflicts\r\n    const styleId = useMemo(() => p.id\r\n        ? p.id\r\n        : generateId([\r\n            p.fontFamily,\r\n            fontSizes.axisTick,\r\n            fontSizes.barLabel,\r\n            fontSizes.legend,\r\n            fontSizes.setLabel,\r\n            fontSizes.title,\r\n            fontSizes.exportLabel,\r\n            fontSizes.description,\r\n            p.textColor,\r\n            p.color,\r\n            p.hasSelectionColor,\r\n            p.strokeColor,\r\n            p.selectionColor,\r\n            p.opacity,\r\n            p.hasSelectionOpacity,\r\n        ]), [\r\n        p.id,\r\n        p.fontFamily,\r\n        fontSizes.axisTick,\r\n        fontSizes.barLabel,\r\n        fontSizes.legend,\r\n        fontSizes.setLabel,\r\n        fontSizes.title,\r\n        fontSizes.exportLabel,\r\n        fontSizes.description,\r\n        p.textColor,\r\n        p.color,\r\n        p.hasSelectionColor,\r\n        p.strokeColor,\r\n        p.selectionColor,\r\n        p.opacity,\r\n        p.hasSelectionOpacity,\r\n    ]);\r\n    const style = useMemo(() => deriveStyleDependent(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips), [\r\n        p.theme,\r\n        p.styles,\r\n        p.classNames,\r\n        p.combinationName,\r\n        p.combinationNameAxisOffset,\r\n        styleId,\r\n        p.barLabelOffset,\r\n        p.selectionColor,\r\n        p.emptySelection,\r\n        p.title,\r\n        p.description,\r\n        p.tooltips,\r\n    ]);\r\n    const size = useMemo(() => deriveVennSizeDependent(p.width, p.height, p.padding, p.id), [p.width, p.height, p.padding, p.id]);\r\n    const data = useMemo(() => deriveKarnaughDataDependent(p.sets, p.combinations, size, p.numericScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.barPadding, parseFontSize(fontSizes.setLabel), parseFontSize(fontSizes.axisTick), p.toKey, p.toElemKey, p.id, p.combinationMaxScale), [\r\n        p.sets,\r\n        p.combinations,\r\n        size,\r\n        p.numericScale,\r\n        p.barLabelOffset,\r\n        fontSizes.barLabel,\r\n        p.barPadding,\r\n        fontSizes.axisTick,\r\n        fontSizes.setLabel,\r\n        p.toKey,\r\n        p.toElemKey,\r\n        p.id,\r\n        p.combinationMaxScale,\r\n    ]);\r\n    const h = useHandler(p);\r\n    const selectionName = generateSelectionName(selection);\r\n    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);\r\n    const rules = `\n  ${rulesHelper.root}\n  ${rulesHelper.text}\n\n  .axisTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.axisTick)}\n    text-anchor: end;\n  }\n  .barTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.barLabel)}\n    text-anchor: middle;\n  }\n  .setTextStyle-${style.id} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.setLabel)}\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-${styleId} {\n    fill: ${p.textColor};\n    ${rulesHelper.p(fontSizes.chartLabel)}\n  }\n\n  .not-${style.id} {\n    text-decoration: overline;\n  }\n\n  .axisLine-${styleId} {\n    fill: none;\n    stroke: ${p.textColor};\n  }\n\n  .gridStyle-${style.id} {\n    fill: none;\n    stroke: ${p.strokeColor};\n    stroke-linecap: round;\n  }\n  .gridStyle-${style.id}-1 {\n    stroke-width: 2;\n  }\n  .gridStyle-${style.id}-2 {\n    stroke-width: 3;\n  }\n\n  ${rulesHelper.fill}\n  ${rulesHelper.export}\n\n  ${queries\r\n        .map((q, i) => `.fillQ${i}-${data.id} {\n    fill: ${q.color};\n  }`)\r\n        .join('\\n')}\n  `;\r\n    const exportChart = useExportChart(data, p, 'kmap');\r\n    const maxWidth = data.sets.l.reduce((acc, d) => Math.min(acc, d.text[0].x - data.sets.labelHeight), size.area.w);\r\n    return (React.createElement(SVGWrapper, { rules: rules, style: style, size: size, p: p, data: data, tRef: ref, selectionName: selectionName, h: h, exportChart: exportChart },\r\n        React.createElement(UpSetTitle, { style: style, width: maxWidth }),\r\n        React.createElement(KMapChart, { style: style, data: data, h: h, size: size }),\r\n        React.createElement(KMapSelection, { style: style, data: data, hasHover: h.hasHover, selection: selection }),\r\n        React.createElement(KMapQueries, { style: style, data: data, hasHover: h.hasHover, queries: queries, secondary: h.hasHover || selection != null })));\r\n});\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst defaults = {\r\n    background: '#F4F4F4',\r\n    color: '#A6A8AB',\r\n    secondaryColor: '#E1E2E3',\r\n};\r\nfunction prepare(props) {\r\n    var _a, _b, _c, _d;\r\n    const color = (_a = props.color) !== null && _a !== void 0 ? _a : defaults.color;\r\n    const secondary = (_b = props.secondaryColor) !== null && _b !== void 0 ? _b : defaults.secondaryColor;\r\n    const rest = Object.assign({}, props);\r\n    const background = (_c = props.background) !== null && _c !== void 0 ? _c : defaults.background;\r\n    delete rest.color;\r\n    delete rest.secondaryColor;\r\n    delete rest.background;\r\n    if (background) {\r\n        rest.style = Object.assign({ background }, (_d = rest.style) !== null && _d !== void 0 ? _d : {});\r\n    }\r\n    return { color, secondary, rest };\r\n}\r\n/**\r\n * UpSetJS Skeleton a simple UpSetJS skeleton\r\n *\r\n * with React.forwardRef support to specify a reference to the SVG element\r\n */\r\nconst UpSetJSSkeleton = /*!#__PURE__*/ React.memo(\r\n/*!#__PURE__*/ React.forwardRef(function UpSetJSSkeleton(props, ref) {\r\n    const { color, secondary, rest } = prepare(props);\r\n    const wi = 20;\r\n    const padding = 10;\r\n    const sWidth = 75;\r\n    const sY = 110;\r\n    const cHeight = 100;\r\n    const csX = 85;\r\n    const cOffsets = [10, 20, 35, 60, 65, 80, 90];\r\n    const sOffsets = [50, 30, 15];\r\n    return (React.createElement(\"svg\", Object.assign({ viewBox: \"0 0 300 200\", ref: ref }, rest),\r\n        cOffsets.map((offset, i) => (React.createElement(\"rect\", { key: i, x: csX + i * (wi + padding), y: offset, width: wi, height: cHeight - offset, fill: color }))),\r\n        sOffsets.map((offset, i) => (React.createElement(\"rect\", { key: i, x: offset, y: sY + i * (wi + padding), width: sWidth - offset, height: wi, fill: color }))),\r\n        cOffsets.map((_, i) => sOffsets.map((_, j) => {\r\n            const filled = j === 2 - i || (i === 3 && j > 0) || (i === 4 && j !== 1) || (i === 5 && j < 2) || i === 6;\r\n            return (React.createElement(\"circle\", { key: `${i}x${j}`, cx: csX + i * (wi + padding) + wi / 2, cy: sY + j * (wi + padding) + wi / 2, r: wi / 2, fill: filled ? color : secondary }));\r\n        })),\r\n        React.createElement(\"rect\", { x: \"182\", y: \"150\", width: \"6\", height: \"30\", fill: color }),\r\n        React.createElement(\"rect\", { x: \"212\", y: \"120\", width: \"6\", height: \"60\", fill: color }),\r\n        React.createElement(\"rect\", { x: \"242\", y: \"120\", width: \"6\", height: \"30\", fill: color }),\r\n        React.createElement(\"rect\", { x: \"272\", y: \"120\", width: \"6\", height: \"60\", fill: color })));\r\n}));\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\n/**\r\n * VennDiagram Skeleton a simple VennDiagram skeleton\r\n *\r\n * with React.forwardRef support to specify a reference to the SVG element\r\n */\r\nconst VennDiagramSkeleton = /*!#__PURE__*/ React.memo(\r\n/*!#__PURE__*/ React.forwardRef(function VennDiagramSkeleton(props, ref) {\r\n    const { color, secondary, rest } = prepare(props);\r\n    const padding = 10;\r\n    const l = layoutImpl(3, 300 - padding * 2, 3200 - padding * 2);\r\n    return (React.createElement(\"svg\", Object.assign({ viewBox: \"0 0 300 200\", ref: ref }, rest),\r\n        l.sets.map((set, i) => (React.createElement(\"circle\", { key: i, cx: set.cx, cy: set.cy + padding, r: set.r, fill: secondary }))),\r\n        l.sets.map((set, i) => (React.createElement(\"circle\", { key: i, cx: set.cx, cy: set.cy + padding, r: set.r, stroke: color, fill: \"none\" })))));\r\n}));\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\n/**\r\n * KV Diagram Skeleton a simple KarnaughMap skeleton\r\n *\r\n * with React.forwardRef support to specify a reference to the SVG element\r\n */\r\nconst KarnaughMapSkeleton = /*!#__PURE__*/ React.memo(\r\n/*!#__PURE__*/ React.forwardRef(function KarnaughMapSkeleton(props, ref) {\r\n    const { rest, color, secondary } = prepare(props);\r\n    // const padding = 10;\r\n    const { xBefore, yBefore, cell, hCells, vCells } = bounds(2, {\r\n        width: 270,\r\n        height: 170,\r\n        labelHeight: 20,\r\n    });\r\n    const gw = hCells * cell;\r\n    const gh = vCells * cell;\r\n    const v1 = 0.9;\r\n    const v2 = 0.5;\r\n    const v3 = 0.26;\r\n    const v4 = 0.75;\r\n    return (React.createElement(\"svg\", Object.assign({ viewBox: \"0 0 300 200\", ref: ref, fontFamily: \"sans-serif\" }, rest),\r\n        React.createElement(\"g\", { transform: `translate(${xBefore + 10},${yBefore + 10})` },\r\n            React.createElement(\"text\", { x: cell * 0.5, y: -3, fill: color, textAnchor: \"middle\" }, \"A\"),\r\n            React.createElement(\"text\", { x: cell * 1.5, y: -3, fill: color, textAnchor: \"middle\", style: { textDecoration: 'overline' } }, \"A\"),\r\n            React.createElement(\"text\", { x: -3, y: cell * 0.5, fill: color, textAnchor: \"end\", dominantBaseline: \"central\" }, \"B\"),\r\n            React.createElement(\"text\", { x: -3, y: cell * 1.5, fill: color, textAnchor: \"end\", dominantBaseline: \"central\", style: { textDecoration: 'overline' } }, \"B\"),\r\n            React.createElement(\"rect\", { x: cell * 0.1, y: cell * (1 - v1), height: cell * v1, width: cell * 0.8, fill: secondary }),\r\n            React.createElement(\"rect\", { x: cell * 1.1, y: cell * (1 - v2), height: cell * v2, width: cell * 0.8, fill: secondary }),\r\n            React.createElement(\"rect\", { x: cell * 0.1, y: cell * (1 - v3 + 1), height: cell * v3, width: cell * 0.8, fill: secondary }),\r\n            React.createElement(\"rect\", { x: cell * 1.1, y: cell * (1 - v4 + 1), height: cell * v4, width: cell * 0.8, fill: secondary }),\r\n            React.createElement(\"path\", { d: `M0,0 l${gw},0 l0,${gh} l${-gw},0 l0,${-gh} M${gw / 2},0 l0,${gh} M0,${gh / 2} l${gw},0`, fill: \"none\", stroke: color }))));\r\n}));\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nconst DEG2RAD = (1 / 180) * Math.PI;\r\nfunction pointAtCircle(cx, cy, radius, angle) {\r\n    return {\r\n        x: cx + Math.cos(angle * DEG2RAD) * radius,\r\n        y: cy + Math.sin(angle * DEG2RAD) * radius,\r\n    };\r\n}\n\n/**\r\n * @upsetjs/react\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction center(circles) {\r\n    const sumX = circles.reduce((acc, a) => acc + a.x, 0);\r\n    const sumY = circles.reduce((acc, a) => acc + a.y, 0);\r\n    return {\r\n        x: sumX / circles.length,\r\n        y: sumY / circles.length,\r\n    };\r\n}\r\nfunction angleAtCircle(p, c) {\r\n    const x = p.x - c.x;\r\n    const y = p.y - c.y;\r\n    return Math.atan2(y, x) / DEG2RAD;\r\n}\r\nfunction createVennJSAdapter(layout, options) {\r\n    return {\r\n        maxSets: Infinity,\r\n        compute(sets, combinations, width, height) {\r\n            const overlaps = combinations.map((c) => ({ sets: Array.from(c.sets).map((s) => s.name), size: c.cardinality }));\r\n            const r = layout(overlaps, Object.assign({}, {\r\n                width,\r\n                height,\r\n                distinct: true,\r\n            }, options !== null && options !== void 0 ? options : {}));\r\n            const singleSets = r.filter((d) => d.data.sets.length === 1);\r\n            const setNames = new Map(sets.map((d, i) => [d.name, i]));\r\n            const setCircles = singleSets.map((d) => d.circles[0]);\r\n            const eulerCenter = center(setCircles);\r\n            const asArc = (a) => ({\r\n                x2: a.p1.x,\r\n                y2: a.p1.y,\r\n                cx: a.circle.x,\r\n                cy: a.circle.y,\r\n                sweep: true,\r\n                large: a.width > a.circle.radius,\r\n                ref: setCircles.findIndex((d) => Math.abs(d.x - a.circle.x) < 0.05 && Math.abs(d.y - a.circle.y) < 0.05),\r\n                mode: 'i',\r\n            });\r\n            return {\r\n                sets: singleSets.map((d) => {\r\n                    const c = d.circles[0];\r\n                    const angle = angleAtCircle(c, eulerCenter);\r\n                    return {\r\n                        cx: c.x,\r\n                        cy: c.y,\r\n                        r: c.radius,\r\n                        align: angle > 90 ? 'end' : 'start',\r\n                        verticalAlign: 'bottom',\r\n                        text: pointAtCircle(c.x, c.y, c.radius * 1.1, angle),\r\n                    };\r\n                }),\r\n                intersections: r.map((d) => {\r\n                    const arcs = d.arcs;\r\n                    const text = {\r\n                        x: d.text.x,\r\n                        y: d.text.y,\r\n                    };\r\n                    if (arcs.length === 0) {\r\n                        return {\r\n                            sets: d.data.sets.map((s) => setNames.get(s)),\r\n                            text,\r\n                            x1: 0,\r\n                            y1: 0,\r\n                            arcs: [],\r\n                        };\r\n                    }\r\n                    if (arcs.length === 1) {\r\n                        const c = d.arcs[0].circle;\r\n                        return {\r\n                            sets: d.data.sets.map((s) => setNames.get(s)),\r\n                            text,\r\n                            x1: d.arcs[0].p2.x,\r\n                            y1: c.y - c.radius,\r\n                            arcs: [asArc(d.arcs[0]), Object.assign(asArc(d.arcs[0]), { y2: c.y - c.radius })],\r\n                            path: d.distinctPath || d.path,\r\n                        };\r\n                    }\r\n                    return {\r\n                        sets: d.data.sets.map((s) => setNames.get(s)),\r\n                        text,\r\n                        x1: d.arcs[0].p2.x,\r\n                        y1: d.arcs[0].p2.y,\r\n                        arcs: d.arcs.map((e) => asArc(e)),\r\n                        path: d.distinctPath || d.path,\r\n                    };\r\n                }),\r\n            };\r\n        },\r\n    };\r\n}\n\n/**\r\n * @upsetjs/bundle\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction widthRatios(value) {\r\n    return value == null || (Array.isArray(value) && value.length >= 2 && value.every((v) => typeof v === 'number'));\r\n}\r\nfunction heightRatios(value) {\r\n    return value == null || (Array.isArray(value) && value.length >= 1 && value.every((v) => typeof v === 'number'));\r\n}\r\nfunction setLabelAlignment(value) {\r\n    return value == null || value === 'left' || value === 'center' || value === 'right';\r\n}\r\nfunction sets(value) {\r\n    return Array.isArray(value) && value.every(isSet);\r\n}\r\nfunction combinations(value) {\r\n    return (value == null || (Array.isArray(value) && value.every(isSetCombination)) || isGenerateSetCombinationOptions(value));\r\n}\r\nfunction selection(value) {\r\n    return value == null || Array.isArray(value) || isSetLike$1(value);\r\n}\r\nfunction onHover(value) {\r\n    return value == null || typeof value === 'function';\r\n}\r\nfunction onClick(value) {\r\n    return value == null || typeof value === 'function';\r\n}\r\nfunction onContextMenu(value) {\r\n    return value == null || typeof value === 'function';\r\n}\r\nfunction onMouseMove(value) {\r\n    return value == null || typeof value === 'function';\r\n}\r\nfunction queries(value) {\r\n    return !value || (Array.isArray(value) && value.every(isUpSetQuery));\r\n}\r\nfunction stringOrFalse(value) {\r\n    return value == null || typeof value === 'string' || value === false;\r\n}\r\nfunction setLabelOffsets(value) {\r\n    return (value == null ||\r\n        (Array.isArray(value) && value.every((v) => (null  ))));\r\n}\r\nfunction theme(value) {\r\n    return value == null || value === 'light' || value === 'dark' || value === 'vega';\r\n}\r\nfunction classNames(value) {\r\n    return (value == null ||\r\n        Object.keys(value).every((k) => MULTI_STYLE_KEYS.includes(k) && typeof value[k] === 'string'));\r\n}\r\nfunction fontSizes(value) {\r\n    return (value == null ||\r\n        Object.keys(value).every((k) => FONT_SIZES_KEYS.includes(k) && typeof value[k] === 'string'));\r\n}\r\nfunction numericScale(value) {\r\n    return value == null || value === 'linear' || value === 'log' || typeof value === 'function';\r\n}\r\nfunction bandScale(value) {\r\n    return value == null || value === 'band' || typeof value === 'function';\r\n}\r\nfunction axisOffset(value) {\r\n    return value == null || value === 'auto' || typeof value === 'number';\r\n}\r\nfunction style(value) {\r\n    return value == null || typeof value === 'object';\r\n}\r\nfunction styles(value) {\r\n    return (value == null ||\r\n        Object.keys(value).every((k) => MULTI_STYLE_KEYS.includes(k)));\r\n}\r\nfunction exportButtons(value) {\r\n    return (value == null ||\r\n        typeof value === 'boolean' ||\r\n        Object.keys(value).every((k) => EXPORT_OPTION_KEYS.includes(k) && typeof value[k] === 'boolean'));\r\n}\n\nvar validators = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    widthRatios: widthRatios,\n    heightRatios: heightRatios,\n    setLabelAlignment: setLabelAlignment,\n    sets: sets,\n    combinations: combinations,\n    selection: selection,\n    onHover: onHover,\n    onClick: onClick,\n    onContextMenu: onContextMenu,\n    onMouseMove: onMouseMove,\n    queries: queries,\n    stringOrFalse: stringOrFalse,\n    setLabelOffsets: setLabelOffsets,\n    theme: theme,\n    classNames: classNames,\n    fontSizes: fontSizes,\n    numericScale: numericScale,\n    bandScale: bandScale,\n    axisOffset: axisOffset,\n    style: style,\n    styles: styles,\n    exportButtons: exportButtons\n});\n\nexport { KarnaughMap, KarnaughMapSkeleton, UpSetJS, UpSetJSSkeleton, VennDiagram, VennDiagramSkeleton, createVennJSAdapter, UpSetJS as default, downloadUrl, exportSVG, exportVegaLite, fillDefaults, fillDefaultsG, fillKarnaughMapDefaults, fillKarnaughMapDefaultsG, fillVennDiagramDefaults, fillVennDiagramDefaultsG, getDefaultTheme, isEllipse, validators as propValidators, toUpSetJSDump, toUpSetJSStaticDump };\n//# sourceMappingURL=index.js.map\n","/**\n * @sgratzl/boxplots\n * https://github.com/sgratzl/boxplots\n *\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\n */\n\nconst HELPER = Math.sqrt(2 * Math.PI);\nfunction gaussian(u) {\n    return Math.exp(-0.5 * u * u) / HELPER;\n}\nfunction toSampleVariance(variance, len) {\n    return (variance * len) / (len - 1);\n}\nfunction nrd(iqr, variance, len) {\n    let s = Math.sqrt(toSampleVariance(variance, len));\n    if (typeof iqr === 'number') {\n        s = Math.min(s, iqr / 1.34);\n    }\n    return 1.06 * s * Math.pow(len, -0.2);\n}\nfunction kde(stats) {\n    const len = stats.items.length;\n    const bandwidth = nrd(stats.iqr, stats.variance, len);\n    return (x) => {\n        let i = 0;\n        let sum = 0;\n        for (i = 0; i < len; i++) {\n            const v = stats.items[i];\n            sum += gaussian((x - v) / bandwidth);\n        }\n        return sum / bandwidth / len;\n    };\n}\n\nfunction quantilesInterpolate(arr, length, interpolate) {\n    const n1 = length - 1;\n    const compute = (q) => {\n        const index = q * n1;\n        const lo = Math.floor(index);\n        const h = index - lo;\n        const a = arr[lo];\n        return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);\n    };\n    return {\n        q1: compute(0.25),\n        median: compute(0.5),\n        q3: compute(0.75),\n    };\n}\nfunction quantilesType7(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (a, b, alpha) => a + alpha * (b - a));\n}\nfunction quantilesLinear(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (i, j, fraction) => i + (j - i) * fraction);\n}\nfunction quantilesLower(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (i) => i);\n}\nfunction quantilesHigher(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (_, j) => j);\n}\nfunction quantilesNearest(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (i, j, fraction) => (fraction < 0.5 ? i : j));\n}\nfunction quantilesMidpoint(arr, length = arr.length) {\n    return quantilesInterpolate(arr, length, (i, j) => (i + j) * 0.5);\n}\nfunction quantilesFivenum(arr, length = arr.length) {\n    const n = length;\n    const n4 = Math.floor((n + 3) / 2) / 2;\n    const compute = (d) => 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);\n    return {\n        q1: compute(n4),\n        median: compute((n + 1) / 2),\n        q3: compute(n + 1 - n4),\n    };\n}\nfunction quantilesHinges(arr, length = arr.length) {\n    return quantilesFivenum(arr, length);\n}\n\nfunction createSortedData(data) {\n    let valid = 0;\n    const { length } = data;\n    const vs = data instanceof Float64Array ? new Float64Array(length) : new Float32Array(length);\n    for (let i = 0; i < length; i += 1) {\n        const v = data[i];\n        if (v == null || Number.isNaN(v)) {\n            continue;\n        }\n        vs[valid] = v;\n        valid += 1;\n    }\n    const missing = length - valid;\n    if (valid === 0) {\n        return {\n            min: Number.NaN,\n            max: Number.NaN,\n            missing,\n            s: [],\n        };\n    }\n    const validData = valid === length ? vs : vs.subarray(0, valid);\n    validData.sort((a, b) => (a === b ? 0 : a < b ? -1 : 1));\n    const min = validData[0];\n    const max = validData[validData.length - 1];\n    return {\n        min,\n        max,\n        missing,\n        s: validData,\n    };\n}\nfunction withSortedData(data) {\n    if (data.length === 0) {\n        return {\n            min: Number.NaN,\n            max: Number.NaN,\n            missing: 0,\n            s: [],\n        };\n    }\n    const min = data[0];\n    const max = data[data.length - 1];\n    return {\n        min,\n        max,\n        missing: 0,\n        s: data,\n    };\n}\nfunction computeWhiskers(s, valid, min, max, { eps, quantiles, coef, whiskersMode }) {\n    const same = (a, b) => Math.abs(a - b) < eps;\n    const { median, q1, q3 } = quantiles(s, valid);\n    const iqr = q3 - q1;\n    const isCoefValid = typeof coef === 'number' && coef > 0;\n    let whiskerLow = isCoefValid ? Math.max(min, q1 - coef * iqr) : min;\n    let whiskerHigh = isCoefValid ? Math.min(max, q3 + coef * iqr) : max;\n    const outlierLow = [];\n    for (let i = 0; i < valid; i += 1) {\n        const v = s[i];\n        if (v >= whiskerLow || same(v, whiskerLow)) {\n            if (whiskersMode === 'nearest') {\n                whiskerLow = v;\n            }\n            break;\n        }\n        if (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v)) {\n            outlierLow.push(v);\n        }\n    }\n    const reversedOutlierHigh = [];\n    for (let i = valid - 1; i >= 0; i -= 1) {\n        const v = s[i];\n        if (v <= whiskerHigh || same(v, whiskerHigh)) {\n            if (whiskersMode === 'nearest') {\n                whiskerHigh = v;\n            }\n            break;\n        }\n        if ((reversedOutlierHigh.length === 0 || !same(reversedOutlierHigh[reversedOutlierHigh.length - 1], v)) &&\n            (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v))) {\n            reversedOutlierHigh.push(v);\n        }\n    }\n    const outlier = outlierLow.concat(reversedOutlierHigh.reverse());\n    return {\n        median,\n        q1,\n        q3,\n        iqr,\n        outlier,\n        whiskerHigh,\n        whiskerLow,\n    };\n}\nfunction computeStats(s, valid) {\n    let mean = 0;\n    for (let i = 0; i < valid; i++) {\n        const v = s[i];\n        mean += v;\n    }\n    mean /= valid;\n    let variance = 0;\n    for (let i = 0; i < valid; i++) {\n        const v = s[i];\n        variance += (v - mean) * (v - mean);\n    }\n    variance /= valid;\n    return {\n        mean,\n        variance,\n    };\n}\nfunction boxplot(data, options = {}) {\n    const fullOptions = {\n        coef: 1.5,\n        eps: 10e-3,\n        quantiles: quantilesType7,\n        validAndSorted: false,\n        whiskersMode: 'nearest',\n        ...options,\n    };\n    const { missing, s, min, max } = fullOptions.validAndSorted ? withSortedData(data) : createSortedData(data);\n    const invalid = {\n        min: Number.NaN,\n        max: Number.NaN,\n        mean: Number.NaN,\n        missing,\n        iqr: Number.NaN,\n        count: data.length,\n        whiskerHigh: Number.NaN,\n        whiskerLow: Number.NaN,\n        outlier: [],\n        median: Number.NaN,\n        q1: Number.NaN,\n        q3: Number.NaN,\n        variance: 0,\n        items: [],\n        kde: () => 0,\n    };\n    const valid = data.length - missing;\n    if (valid === 0) {\n        return invalid;\n    }\n    const result = {\n        min,\n        max,\n        count: data.length,\n        missing,\n        items: s,\n        ...computeStats(s, valid),\n        ...computeWhiskers(s, valid, min, max, fullOptions),\n    };\n    return {\n        ...result,\n        kde: kde(result),\n    };\n}\n\nexport { boxplot, boxplot as default, kde, quantilesFivenum, quantilesHigher, quantilesHinges, quantilesInterpolate, quantilesLinear, quantilesLower, quantilesMidpoint, quantilesNearest, quantilesType7 };\n//# sourceMappingURL=index.js.map\n","/**\n * @upsetjs/math\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2022 Samuel Gratzl <sam@sgratzl.com>\n */\n\nimport boxplotImpl, { quantilesHinges, quantilesFivenum, quantilesType7, quantilesLinear, quantilesLower, quantilesHigher, quantilesNearest, quantilesMidpoint } from '@sgratzl/boxplots';\n\nconst methodLookup = {\r\n    hinges: quantilesHinges,\r\n    fivenum: quantilesFivenum,\r\n    type7: quantilesType7,\r\n    quantiles: quantilesType7,\r\n    linear: quantilesLinear,\r\n    lower: quantilesLower,\r\n    higher: quantilesHigher,\r\n    nearest: quantilesNearest,\r\n    midpoint: quantilesMidpoint,\r\n};\r\nfunction boxplot(data, options = {}) {\r\n    const o = Object.assign({}, options, {\r\n        quantiles: (typeof options.quantiles === 'function' || options.quantiles == null\r\n            ? options.quantiles\r\n            : methodLookup[options.quantiles]),\r\n    });\r\n    if (o.quantiles == null) {\r\n        delete o.quantiles;\r\n    }\r\n    return boxplotImpl(data, o);\r\n}\n\nfunction rand(seed = Date.now()) {\r\n    return () => {\r\n        seed = (seed * 9301 + 49297) % 233280;\r\n        return seed / 233280;\r\n    };\r\n}\n\nfunction denormalize(range) {\r\n    const delta = range[1] - range[0];\r\n    return (v) => v * delta + range[0];\r\n}\r\nfunction normalize(domain) {\r\n    const delta = domain[1] - domain[0];\r\n    return (v) => (v - domain[0]) / delta;\r\n}\n\nfunction colorGen(dark) {\r\n    const schemeDark2 = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d'];\r\n    const schemeSet2 = ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494'];\r\n    const set = dark ? schemeDark2.concat(schemeSet2) : schemeSet2.concat(schemeDark2);\r\n    let acc = 0;\r\n    return () => {\r\n        return set[acc++ % set.length];\r\n    };\r\n}\r\nfunction bin(hist, values) {\r\n    const map = new Map(hist.map((bin) => [bin.value, 0]));\r\n    values.forEach((value) => {\r\n        if (value == null) {\r\n            return;\r\n        }\r\n        const key = value.toString();\r\n        if (!map.has(key)) {\r\n            return;\r\n        }\r\n        map.set(key, map.get(key) + 1);\r\n    });\r\n    return map;\r\n}\r\nfunction categoricalHistogram(values, categories, base, dark = false) {\r\n    const nextColor = colorGen(dark);\r\n    const generateCat = (value) => {\r\n        return {\r\n            value,\r\n            label: value.length > 0 ? `${value[0].toUpperCase()}${value.slice(1)}` : value,\r\n            color: nextColor(),\r\n        };\r\n    };\r\n    const hist = categories.map((cat) => {\r\n        return Object.assign({ count: 0, acc: 0, percentage: 0 }, generateCat(typeof cat === 'string' ? cat : cat.value), typeof cat === 'string' ? {} : cat);\r\n    });\r\n    const map = bin(hist, values);\r\n    const baseMap = base ? bin(hist, base) : null;\r\n    const total = Array.from(map.values()).reduce((acc, v) => acc + v, 0);\r\n    let acc = 0;\r\n    hist.forEach((bin) => {\r\n        bin.acc = acc;\r\n        bin.count = map.get(bin.value);\r\n        bin.percentage = bin.count / total;\r\n        acc += baseMap ? baseMap.get(bin.value) : bin.count;\r\n    });\r\n    return hist;\r\n}\n\nexport { boxplot, categoricalHistogram, denormalize, normalize, rand };\n//# sourceMappingURL=index.js.map\n","/**\n * @upsetjs/addons\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2022 Samuel Gratzl <sam@sgratzl.com>\n */\n\nimport React from 'react';\nimport { getDefaultTheme } from '@upsetjs/react';\nimport { normalize, denormalize, boxplot, categoricalHistogram } from '@upsetjs/math';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n/**\r\n * @upsetjs/addons\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction round2(v) {\r\n    return Math.round(v * 100) / 100;\r\n}\n\n/**\r\n * @upsetjs/addons\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction simpleScale(domain, range, orient = 'horizontal') {\r\n    const n = normalize(domain);\r\n    const dnDomain = denormalize(domain);\r\n    const dn = denormalize(range);\r\n    const f = (v) => dn(n(v));\r\n    const defaultTicks = orient === 'horizontal' ? 5 : 7;\r\n    f.ticks = (count = defaultTicks) => Array(count)\r\n        .fill(0)\r\n        .map((_, i) => {\r\n        const v = dnDomain(i / (count - 1));\r\n        return {\r\n            value: v,\r\n            label: v.toLocaleString(undefined, { maximumFractionDigits: 2 }),\r\n        };\r\n    });\r\n    f.tickFormat = () => (v) => v.toFixed(2);\r\n    return f;\r\n}\r\nconst defaultFormatter = (v) => v.toFixed(2);\r\nfunction toString$1(b, nf) {\r\n    return `Min: ${nf(b.min)}, 25% Quantile: ${nf(b.q1)}, Median: ${nf(b.median)}, 75% Quantile: ${nf(b.q3)}, Max: ${nf(b.max)}`;\r\n}\r\nconst Boxplot = (p) => {\r\n    const { theme = 'light', mode = 'normal', boxStyle, lineStyle, outlierStyle, margin = 0, boxPadding: bpp = 0.1, outlierRadius = 3, numberFormat: nf = defaultFormatter } = p, options = __rest(p, [\"theme\", \"mode\", \"boxStyle\", \"lineStyle\", \"outlierStyle\", \"margin\", \"boxPadding\", \"outlierRadius\", \"numberFormat\"]);\r\n    const b = Array.isArray(p.values) ? boxplot(p.values, options) : p.values;\r\n    if (Number.isNaN(b.median)) {\r\n        return React.createElement(\"g\", null);\r\n    }\r\n    const hor = p.orient !== 'vertical';\r\n    const n = normalize([p.min, p.max]);\r\n    const dn = denormalize([0, hor ? p.width : p.height]);\r\n    const scale = (v) => round2(dn(n(v)));\r\n    const s = {\r\n        max: scale(b.max),\r\n        avg: scale(b.mean),\r\n        med: scale(b.median),\r\n        min: scale(b.min),\r\n        q1: scale(b.q1),\r\n        q3: scale(b.q3),\r\n        wh: scale(b.whiskerHigh),\r\n        wl: scale(b.whiskerLow),\r\n    };\r\n    const title = p.tooltips !== false && React.createElement(\"title\", null, toString$1(b, nf));\r\n    const inner = getDefaultTheme(theme).notMemberColor;\r\n    const styles = {\r\n        box: Object.assign({ fill: inner }, boxStyle),\r\n        line: Object.assign({ fill: 'none', stroke: theme === 'light' ? 'black' : '#cccccc' }, lineStyle),\r\n        outlier: Object.assign({ fill: inner }, outlierStyle),\r\n    };\r\n    if (hor) {\r\n        const c = p.height / 2;\r\n        const bp = round2(p.height * bpp) + margin;\r\n        const hp = p.height - bp;\r\n        const w1 = `M${s.wl},${margin} l0,${p.height - margin * 2} M${s.wl},${c} L${s.q1},${c}`;\r\n        const w2 = `M${s.q3},${c} L${s.wh},${c} M${s.wh},${margin} L${s.wh},${p.height - margin}`;\r\n        const box = `M${s.q1},${bp} L${s.q3},${bp} L${s.q3},${hp} L${s.q1},${hp} L${s.q1},${bp} M${s.med},${bp} l0,${hp - bp}`;\r\n        const path = React.createElement(\"path\", { d: `${w1} ${w2} ${box}`, style: styles.line });\r\n        if (mode === 'indicator') {\r\n            return path;\r\n        }\r\n        return (React.createElement(\"g\", null,\r\n            title,\r\n            mode === 'normal' && (React.createElement(\"rect\", { x: s.q1, y: bp, width: s.q3 - s.q1, height: p.height - 2 * bp, style: styles.box })),\r\n            path,\r\n            b.outlier.map((o) => (React.createElement(\"circle\", { key: o, r: outlierRadius, cy: c, cx: scale(o), style: styles.outlier },\r\n                React.createElement(\"title\", null,\r\n                    \"$\",\r\n                    nf(o)))))));\r\n    }\r\n    {\r\n        const c = p.width / 2;\r\n        const bp = round2(p.width * bpp) + margin;\r\n        const wp = p.width - bp;\r\n        const w1 = `M${margin},${s.wl} l${p.width - 2 * margin},0 M${c},${s.wl} L${c},${s.q1}`;\r\n        const w2 = `M${c},${s.q3} L${c},${s.wh} M${margin},${s.wh} L${p.width - margin},${s.wh}`;\r\n        const box = `M${bp},${s.q1} L${bp},${s.q3} l${wp - bp},0 L${wp},${s.q1} L${bp},${s.q1} M${bp},${s.med} l${wp - bp},0`;\r\n        const path = React.createElement(\"path\", { d: `${w1} ${w2} ${box}`, style: styles.line });\r\n        if (mode === 'indicator') {\r\n            return path;\r\n        }\r\n        return (React.createElement(\"g\", null,\r\n            title,\r\n            mode === 'normal' && React.createElement(\"rect\", { y: s.q1, x: bp, height: s.q3 - s.q1, width: p.width - 2 * bp, style: styles.box }),\r\n            path,\r\n            b.outlier.map((o) => (React.createElement(\"circle\", { key: o, r: outlierRadius, cx: c, cy: scale(o), style: styles.outlier },\r\n                React.createElement(\"title\", null,\r\n                    \"$\",\r\n                    nf(o)))))));\r\n    }\r\n};\r\nconst BoxplotMemo = /*!#__PURE__*/ React.memo(Boxplot);\r\n/**\r\n * generates a boxplot addon to render box plots as UpSet.js addon for aggregated set data\r\n * @param prop accessor or name of the property within the element\r\n * @param elems list of elements or their minimum / maximum value for specifying the data domain\r\n * @param options additional options\r\n */\r\nfunction boxplotAddon(prop, elems, _a = {}) {\r\n    var { size = 100, position, name = prop.toString() } = _a, extras = __rest(_a, [\"size\", \"position\", \"name\"]);\r\n    const acc = typeof prop === 'function' ? prop : (v) => v[prop];\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let max = Number.NEGATIVE_INFINITY;\r\n    if (Array.isArray(elems)) {\r\n        elems.forEach((elem) => {\r\n            const v = acc(elem);\r\n            if (v == null || Number.isNaN(v)) {\r\n                return;\r\n            }\r\n            if (v < min) {\r\n                min = v;\r\n            }\r\n            if (v > max) {\r\n                max = v;\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        const d = elems;\r\n        min = d.min;\r\n        max = d.max;\r\n    }\r\n    const scale = simpleScale([min, max], [0, size], extras.orient);\r\n    return {\r\n        name,\r\n        position,\r\n        size,\r\n        scale,\r\n        createOnHandlerData: (set) => {\r\n            const b = boxplot(set.elems.map(acc), extras);\r\n            return {\r\n                id: 'boxplot',\r\n                name,\r\n                value: Object.assign(Object.assign(Object.assign({}, b), { toString() {\r\n                        var _a;\r\n                        return toString$1(this, (_a = extras.numberFormat) !== null && _a !== void 0 ? _a : defaultFormatter);\r\n                    } }), b),\r\n            };\r\n        },\r\n        render: ({ width, height, set, theme }) => {\r\n            const values = set.elems.map(acc);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, theme: theme }, extras)));\r\n        },\r\n        renderSelection: ({ width, height, overlap, selectionColor, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = overlap.map(acc);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, mode: \"box\", lineStyle: { stroke: selectionColor, strokeWidth: 2 }, outlierStyle: { fill: selectionColor }, theme: theme }, extras)));\r\n        },\r\n        renderQuery: ({ width, height, overlap, query, secondary, index, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = overlap.map(acc);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, mode: secondary ? 'indicator' : 'box', margin: secondary ? index + 2 : 0, lineStyle: { stroke: query.color, strokeWidth: secondary ? 1 : 2 }, outlierStyle: { fill: query.color }, theme: theme }, extras)));\r\n        },\r\n    };\r\n}\r\n/**\r\n * generates a boxplot addon to render box plots as UpSet.js addon for aggregated set data\r\n * @param acc accessor\r\n * @param elems list of elements or their minimum / maximum value for specifying the data domain\r\n * @param options additional options\r\n */\r\nfunction boxplotAggregatedAddon(acc, domain, _a = {}) {\r\n    var { size = 100, position, name = 'BoxPlot' } = _a, extras = __rest(_a, [\"size\", \"position\", \"name\"]);\r\n    const min = domain.min;\r\n    const max = domain.max;\r\n    const scale = simpleScale([min, max], [0, size], extras.orient);\r\n    return {\r\n        name,\r\n        position,\r\n        size,\r\n        scale,\r\n        createOnHandlerData: (set) => {\r\n            const b = acc(set.elems);\r\n            b.toString = function () {\r\n                var _a;\r\n                return toString$1(this, (_a = extras.numberFormat) !== null && _a !== void 0 ? _a : defaultFormatter);\r\n            };\r\n            return {\r\n                id: 'boxplot',\r\n                name,\r\n                value: b,\r\n            };\r\n        },\r\n        render: ({ width, height, set, theme }) => {\r\n            const values = acc(set.elems);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, theme: theme }, extras)));\r\n        },\r\n        renderSelection: ({ width, height, overlap, selectionColor, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = acc(overlap);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, mode: \"box\", lineStyle: { stroke: selectionColor, strokeWidth: 2 }, outlierStyle: { fill: selectionColor }, theme: theme }, extras)));\r\n        },\r\n        renderQuery: ({ width, height, overlap, query, secondary, index, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = acc(overlap);\r\n            return (React.createElement(BoxplotMemo, Object.assign({ values: values, width: width, height: height, min: min, max: max, mode: secondary ? 'indicator' : 'box', margin: secondary ? index + 2 : 0, lineStyle: { stroke: query.color, strokeWidth: secondary ? 1 : 2 }, outlierStyle: { fill: query.color }, theme: theme }, extras)));\r\n        },\r\n    };\r\n}\n\n/**\r\n * @upsetjs/addons\r\n * https://github.com/upsetjs/upsetjs\r\n *\r\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\r\n */\r\nfunction isGiven(p) {\r\n    return Array.isArray(p.bins);\r\n}\r\nfunction toString(cat) {\r\n    return cat.map((bin) => `${bin.label}: ${bin.count}`).join(', ');\r\n}\r\nconst Categorical = (p) => {\r\n    var _a, _b;\r\n    const { margin = 0, rectStyle = {} } = p;\r\n    const bins = isGiven(p) ? p.bins : categoricalHistogram(p.values, p.categories, p.base, p.theme === 'dark');\r\n    const n = normalize([\r\n        0,\r\n        isGiven(p) ? p.bins.reduce((acc, v) => acc + v.count, 0) : (_b = (_a = p.base) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : p.values.length,\r\n    ]);\r\n    const hor = p.orient !== 'vertical';\r\n    const dn = denormalize([0, hor ? p.width : p.height]);\r\n    const scale = (v) => dn(n(v));\r\n    if (hor) {\r\n        return (React.createElement(\"g\", null, bins.map((bin) => (React.createElement(\"rect\", { key: bin.value, x: scale(bin.acc), width: scale(bin.count), y: margin, height: p.height - 2 * margin, style: Object.assign({ fill: bin.color }, rectStyle) }, p.tooltips !== false && React.createElement(\"title\", null, `${bin.label}: ${bin.count}`))))));\r\n    }\r\n    return (React.createElement(\"g\", null, bins.map((bin) => (React.createElement(\"rect\", { key: bin.value, y: scale(bin.acc), height: scale(bin.count), x: margin, width: p.width - 2 * margin, style: Object.assign({ fill: bin.color }, rectStyle) }, p.tooltips !== false && React.createElement(\"title\", null, `${bin.label}: ${bin.count}`))))));\r\n};\r\nconst CategoricalMemo = /*!#__PURE__*/ React.memo(Categorical);\r\nconst lightOverlap = 'rgba(255,255,255,0.2)';\r\nconst darkOverlap = 'rgba(0,0,0,0.1)';\r\n/**\r\n * generates a categorical addon to render distributions as UpSet.js addon for aggregated set data\r\n * @param prop accessor or name of the property within the element\r\n * @param elems list of elements or their categories\r\n * @param options additional options\r\n */\r\nfunction categoricalAddon(prop, elems, _a = {}) {\r\n    var { size = 100, position, name = prop.toString() } = _a, extras = __rest(_a, [\"size\", \"position\", \"name\"]);\r\n    const acc = typeof prop === 'function' ? prop : (v) => v[prop];\r\n    let categories = [];\r\n    if (Array.isArray(elems)) {\r\n        const cats = new Set();\r\n        elems.forEach((elem) => {\r\n            const v = acc(elem);\r\n            if (v == null) {\r\n                return;\r\n            }\r\n            cats.add(v.toString());\r\n        });\r\n        categories = Array.from(cats).sort();\r\n    }\r\n    else {\r\n        categories = elems.categories;\r\n    }\r\n    return {\r\n        name,\r\n        position,\r\n        size,\r\n        createOnHandlerData: (set) => {\r\n            const b = categoricalHistogram(set.elems.map(acc), categories, undefined, extras.theme === 'dark');\r\n            b.toString = function () {\r\n                return toString(this);\r\n            };\r\n            return {\r\n                id: 'categorical',\r\n                name,\r\n                value: b,\r\n            };\r\n        },\r\n        render: ({ width, height, set, theme }) => {\r\n            const values = set.elems.map(acc);\r\n            return (React.createElement(CategoricalMemo, Object.assign({ values: values, categories: categories, width: width, height: height, theme: theme }, extras)));\r\n        },\r\n        renderSelection: ({ width, height, set, theme, overlap, selectionColor }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const base = set.elems.map(acc);\r\n            const values = overlap.map(acc);\r\n            return (React.createElement(CategoricalMemo, Object.assign({ values: values, base: base, categories: categories, width: width, height: height, theme: theme, rectStyle: { stroke: selectionColor, strokeWidth: 2, fill: theme === 'light' ? darkOverlap : lightOverlap } }, extras)));\r\n        },\r\n        renderQuery: ({ width, height, overlap, set, query, secondary, index, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const base = set.elems.map(acc);\r\n            const values = overlap.map(acc);\r\n            return (React.createElement(CategoricalMemo, Object.assign({ values: values, base: base, categories: categories, width: width, height: height, margin: secondary ? index + 2 : 0, rectStyle: { stroke: query.color, fill: theme === 'light' ? darkOverlap : lightOverlap }, theme: theme }, extras)));\r\n        },\r\n    };\r\n}\r\n/**\r\n * generates a categorical addon to render distributions as UpSet.js addon for aggregated set data\r\n * @param prop accessor or name of the property within the element\r\n * @param elems list of elements or their categories\r\n * @param options additional options\r\n */\r\nfunction categoricalAggregatedAddon(acc, _a = {}) {\r\n    var { size = 100, position, name = 'Histogram' } = _a, extras = __rest(_a, [\"size\", \"position\", \"name\"]);\r\n    return {\r\n        name,\r\n        position,\r\n        size,\r\n        createOnHandlerData: (set) => {\r\n            const b = acc(set.elems);\r\n            return {\r\n                id: 'categorical',\r\n                name,\r\n                value: Object.assign(Object.assign(Object.assign({}, b), { toString() {\r\n                        return toString(this);\r\n                    } }), b),\r\n            };\r\n        },\r\n        render: ({ width, height, set, theme }) => {\r\n            const values = acc(set.elems);\r\n            return React.createElement(CategoricalMemo, Object.assign({ bins: values, width: width, height: height, theme: theme }, extras));\r\n        },\r\n        renderSelection: ({ width, height, theme, overlap, selectionColor }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = acc(overlap);\r\n            return (React.createElement(CategoricalMemo, Object.assign({ bins: values, width: width, height: height, theme: theme, rectStyle: { stroke: selectionColor, strokeWidth: 2, fill: theme === 'light' ? darkOverlap : lightOverlap } }, extras)));\r\n        },\r\n        renderQuery: ({ width, height, overlap, query, secondary, index, theme }) => {\r\n            if (overlap == null || overlap.length === 0) {\r\n                return null;\r\n            }\r\n            const values = acc(overlap);\r\n            return (React.createElement(CategoricalMemo, Object.assign({ bins: values, width: width, height: height, margin: secondary ? index + 2 : 0, rectStyle: { stroke: query.color, fill: theme === 'light' ? darkOverlap : lightOverlap }, theme: theme }, extras)));\r\n        },\r\n    };\r\n}\n\nexport { Boxplot, Categorical, boxplotAddon, boxplotAggregatedAddon, categoricalAddon, categoricalAggregatedAddon, simpleScale };\n//# sourceMappingURL=index.js.map\n",null,null,null],"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeDiff","options","oldBeforeRender","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","nextValue","action","setState","useEffect","callback","args","state","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","current","useImperativeHandle","ref","createHandle","factory","useCallback","useContext","context","provider","sub","props","value","useDebugValue","formatter","flushAfterPaintEffects","component","sort","a","b","pop","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","some","filter","cb","hasErrored","s","hook","comp","cleanup","oldArgs","newArgs","arg","f","assign","obj","shallowDiffers","LZString","String","fromCharCode","keyStrBase64","keyStrUriSafe","baseReverseDic","getBaseValue","alphabet","character","charAt","compressToBase64","input","res","_compress","decompressFromBase64","_decompress","compressToUTF16","decompressFromUTF16","compressed","charCodeAt","compressToUint8Array","uncompressed","compress","buf","Uint8Array","TotalLen","current_value","decompressFromUint8Array","decompress","result","join","compressToEncodedURIComponent","decompressFromEncodedURIComponent","replace","bitsPerChar","getCharFromInt","context_dictionary","context_dictionaryToCreate","context_c","context_wc","context_w","context_enlargeIn","context_dictSize","context_numBits","context_data","context_data_val","context_data_position","ii","Object","hasOwnProperty","Math","pow","resetValue","getNextValue","dictionary","enlargeIn","dictSize","numBits","entry","w","bits","resb","maxpower","power","data","val","position","module","boxplotImpl","boxplotAddonImpl","boxplotAggregatedAddonImpl","categoricalAddonImpl","categoricalAggregatedAddonImpl","fillDefaultsImpl","fillVennDiagramDefaultsImpl","fillKarnaughMapDefaultsImpl","renderPreact","h","UpSetElement","VennDiagramElement","KarnaughMapElement","hydratePreact","exportSVGImpl","downloadUrlImpl","toUpSetJSDumpImpl","toUpSetJSStaticDumpImpl"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvIA,MAAIgC,QAAQ,GAAI,YAAW;AAG3B,QAAIJ,CAAC,GAAGK,MAAM,CAACC,YAAf;AACA,QAAIC,YAAY,GAAG,mEAAnB;AACA,QAAIC,aAAa,GAAG,mEAApB;AACA,QAAIC,cAAc,GAAG,EAArB;AAEA,aAASC,YAAT,CAAsBC,QAAtB,EAAgCC,SAAhC,EAA2C;AACzC,UAAI,CAACH,cAAc,CAACE,QAAD,CAAnB,EAA+B;AAC7BF,QAAAA,cAAc,CAACE,QAAD,CAAd,GAA2B,EAA3B;AACA,aAAK,IAAI3G,CAAC,GAAC,CAAX,EAAeA,CAAC,GAAC2G,QAAQ,CAAC5G,MAA1B,EAAmCC,CAAC,EAApC,EAAwC;AACtCyG,UAAAA,cAAc,CAACE,QAAD,CAAd,CAAyBA,QAAQ,CAACE,MAAT,CAAgB7G,CAAhB,CAAzB,IAA+CA,CAA/C;AACD;AACF;AACD,aAAOyG,cAAc,CAACE,QAAD,CAAd,CAAyBC,SAAzB,CAAP;AACD;AAED,QAAIR,QAAQ,GAAG;AACbU,MAAAA,gBAAgB,EAAG,0BAAUC,KAAV,EAAiB;AAClC,YAAIA,KAAK,IAAI,IAAb,EAAmB,OAAO,EAAP;AACnB,YAAIC,GAAG,GAAGZ,QAAQ,CAACa,SAAT,CAAmBF,KAAnB,EAA0B,CAA1B,EAA6B,UAAS5C,CAAT,EAAW;AAAC,iBAAOoC,YAAY,CAACM,MAAb,CAAoB1C,CAApB,CAAP;AAA+B,SAAxE,CAAV;AACA,gBAAQ6C,GAAG,CAACjH,MAAJ,GAAa,CAArB;AACA,kBADA;AAEA,eAAK,CAAL;AAAS,mBAAOiH,GAAP;AACT,eAAK,CAAL;AAAS,mBAAOA,GAAG,GAAC,KAAX;AACT,eAAK,CAAL;AAAS,mBAAOA,GAAG,GAAC,IAAX;AACT,eAAK,CAAL;AAAS,mBAAOA,GAAG,GAAC,GAAX;AALT;AAOD,OAXY;AAabE,MAAAA,oBAAoB,EAAG,8BAAUH,KAAV,EAAiB;AACtC,YAAIA,KAAK,IAAI,IAAb,EAAmB,OAAO,EAAP;AACnB,YAAIA,KAAK,IAAI,EAAb,EAAiB,OAAO,IAAP;AACjB,eAAOX,QAAQ,CAACe,WAAT,CAAqBJ,KAAK,CAAChH,MAA3B,EAAmC,EAAnC,EAAuC,UAAS0B,KAAT,EAAgB;AAAE,iBAAOiF,YAAY,CAACH,YAAD,EAAeQ,KAAK,CAACF,MAAN,CAAapF,KAAb,CAAf,CAAnB;AAAyD,SAAlH,CAAP;AACD,OAjBY;AAmBb2F,MAAAA,eAAe,EAAG,yBAAUL,KAAV,EAAiB;AACjC,YAAIA,KAAK,IAAI,IAAb,EAAmB,OAAO,EAAP;AACnB,eAAOX,QAAQ,CAACa,SAAT,CAAmBF,KAAnB,EAA0B,EAA1B,EAA8B,UAAS5C,CAAT,EAAW;AAAC,iBAAO6B,CAAC,CAAC7B,CAAC,GAAC,EAAH,CAAR;AAAgB,SAA1D,IAA8D,GAArE;AACD,OAtBY;AAwBbkD,MAAAA,mBAAmB,EAAE,6BAAUC,UAAV,EAAsB;AACzC,YAAIA,UAAU,IAAI,IAAlB,EAAwB,OAAO,EAAP;AACxB,YAAIA,UAAU,IAAI,EAAlB,EAAsB,OAAO,IAAP;AACtB,eAAOlB,QAAQ,CAACe,WAAT,CAAqBG,UAAU,CAACvH,MAAhC,EAAwC,KAAxC,EAA+C,UAAS0B,KAAT,EAAgB;AAAE,iBAAO6F,UAAU,CAACC,UAAX,CAAsB9F,KAAtB,IAA+B,EAAtC;AAA2C,SAA5G,CAAP;AACD,OA5BY;AA+Bb+F,MAAAA,oBAAoB,EAAE,8BAAUC,YAAV,EAAwB;AAC5C,YAAIH,UAAU,GAAGlB,QAAQ,CAACsB,QAAT,CAAkBD,YAAlB,CAAjB;AACA,YAAIE,GAAG,GAAC,IAAIC,UAAJ,CAAeN,UAAU,CAACvH,MAAX,GAAkB,CAAjC,CAAR,CAF4C;AAI5C,aAAK,IAAIC,CAAC,GAAC,CAAN,EAAS6H,QAAQ,GAACP,UAAU,CAACvH,MAAlC,EAA0CC,CAAC,GAAC6H,QAA5C,EAAsD7H,CAAC,EAAvD,EAA2D;AACzD,cAAI8H,aAAa,GAAGR,UAAU,CAACC,UAAX,CAAsBvH,CAAtB,CAApB;AACA2H,UAAAA,GAAG,CAAC3H,CAAC,GAAC,CAAH,CAAH,GAAW8H,aAAa,KAAK,CAA7B;AACAH,UAAAA,GAAG,CAAC3H,CAAC,GAAC,CAAF,GAAI,CAAL,CAAH,GAAa8H,aAAa,GAAG,GAA7B;AACD;AACD,eAAOH,GAAP;AACD,OAzCY;AA4CbI,MAAAA,wBAAwB,EAAC,kCAAUT,UAAV,EAAsB;AAC7C,YAAIA,UAAU,KAAG,IAAb,IAAqBA,UAAU,KAAGjF,SAAtC,EAAgD;AAC5C,iBAAO+D,QAAQ,CAAC4B,UAAT,CAAoBV,UAApB,CAAP;AACH,SAFD,MAEO;AACH,cAAIK,GAAG,GAAC,IAAIxH,KAAJ,CAAUmH,UAAU,CAACvH,MAAX,GAAkB,CAA5B,CAAR,CADG;AAEH,eAAK,IAAIC,CAAC,GAAC,CAAN,EAAS6H,QAAQ,GAACF,GAAG,CAAC5H,MAA3B,EAAmCC,CAAC,GAAC6H,QAArC,EAA+C7H,CAAC,EAAhD,EAAoD;AAClD2H,YAAAA,GAAG,CAAC3H,CAAD,CAAH,GAAOsH,UAAU,CAACtH,CAAC,GAAC,CAAH,CAAV,GAAgB,GAAhB,GAAoBsH,UAAU,CAACtH,CAAC,GAAC,CAAF,GAAI,CAAL,CAArC;AACD;AAED,cAAIiI,MAAM,GAAG,EAAb;AACAN,UAAAA,GAAG,CAACrD,OAAJ,CAAY,UAAUK,CAAV,EAAa;AACvBsD,YAAAA,MAAM,CAACrG,IAAP,CAAYoE,CAAC,CAACrB,CAAD,CAAb;AACD,WAFD;AAGA,iBAAOyB,QAAQ,CAAC4B,UAAT,CAAoBC,MAAM,CAACC,IAAP,CAAY,EAAZ,CAApB,CAAP;AAEH;AAEF,OA7DY;AAiEbC,MAAAA,6BAA6B,EAAE,uCAAUpB,KAAV,EAAiB;AAC9C,YAAIA,KAAK,IAAI,IAAb,EAAmB,OAAO,EAAP;AACnB,eAAOX,QAAQ,CAACa,SAAT,CAAmBF,KAAnB,EAA0B,CAA1B,EAA6B,UAAS5C,CAAT,EAAW;AAAC,iBAAOqC,aAAa,CAACK,MAAd,CAAqB1C,CAArB,CAAP;AAAgC,SAAzE,CAAP;AACD,OApEY;AAuEbiE,MAAAA,iCAAiC,EAAC,2CAAUrB,KAAV,EAAiB;AACjD,YAAIA,KAAK,IAAI,IAAb,EAAmB,OAAO,EAAP;AACnB,YAAIA,KAAK,IAAI,EAAb,EAAiB,OAAO,IAAP;AACjBA,QAAAA,KAAK,GAAGA,KAAK,CAACsB,OAAN,CAAc,IAAd,EAAoB,GAApB,CAAR;AACA,eAAOjC,QAAQ,CAACe,WAAT,CAAqBJ,KAAK,CAAChH,MAA3B,EAAmC,EAAnC,EAAuC,UAAS0B,KAAT,EAAgB;AAAE,iBAAOiF,YAAY,CAACF,aAAD,EAAgBO,KAAK,CAACF,MAAN,CAAapF,KAAb,CAAhB,CAAnB;AAA0D,SAAnH,CAAP;AACD,OA5EY;AA8EbiG,MAAAA,QAAQ,EAAE,kBAAUD,YAAV,EAAwB;AAChC,eAAOrB,QAAQ,CAACa,SAAT,CAAmBQ,YAAnB,EAAiC,EAAjC,EAAqC,UAAStD,CAAT,EAAW;AAAC,iBAAO6B,CAAC,CAAC7B,CAAD,CAAR;AAAa,SAA9D,CAAP;AACD,OAhFY;AAiFb8C,MAAAA,SAAS,EAAE,mBAAUQ,YAAV,EAAwBa,WAAxB,EAAqCC,cAArC,EAAqD;AAC9D,YAAId,YAAY,IAAI,IAApB,EAA0B,OAAO,EAAP;AAC1B,YAAIzH,CAAJ;AAAA,YAAO6D,KAAP;AAAA,YACI2E,kBAAkB,GAAE,EADxB;AAAA,YAEIC,0BAA0B,GAAE,EAFhC;AAAA,YAGIC,SAAS,GAAC,EAHd;AAAA,YAIIC,UAAU,GAAC,EAJf;AAAA,YAKIC,SAAS,GAAC,EALd;AAAA,YAMIC,iBAAiB,GAAE,CANvB;AAOIC,QAAAA,gBAAgB,GAAE,CAPtB;AAAA,YAQIC,eAAe,GAAE,CARrB;AAAA,YASIC,YAAY,GAAC,EATjB;AAAA,YAUIC,gBAAgB,GAAC,CAVrB;AAAA,YAWIC,qBAAqB,GAAC,CAX1B;AAAA,YAYIC,EAZJ;AAcA,aAAKA,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAG1B,YAAY,CAAC1H,MAA/B,EAAuCoJ,EAAE,IAAI,CAA7C,EAAgD;AAC9CT,UAAAA,SAAS,GAAGjB,YAAY,CAACZ,MAAb,CAAoBsC,EAApB,CAAZ;AACA,cAAI,CAACC,MAAM,CAAChJ,SAAP,CAAiBiJ,cAAjB,CAAgC/I,IAAhC,CAAqCkI,kBAArC,EAAwDE,SAAxD,CAAL,EAAyE;AACvEF,YAAAA,kBAAkB,CAACE,SAAD,CAAlB,GAAgCI,gBAAgB,EAAhD;AACAL,YAAAA,0BAA0B,CAACC,SAAD,CAA1B,GAAwC,IAAxC;AACD;AAEDC,UAAAA,UAAU,GAAGC,SAAS,GAAGF,SAAzB;AACA,cAAIU,MAAM,CAAChJ,SAAP,CAAiBiJ,cAAjB,CAAgC/I,IAAhC,CAAqCkI,kBAArC,EAAwDG,UAAxD,CAAJ,EAAyE;AACvEC,YAAAA,SAAS,GAAGD,UAAZ;AACD,WAFD,MAEO;AACL,gBAAIS,MAAM,CAAChJ,SAAP,CAAiBiJ,cAAjB,CAAgC/I,IAAhC,CAAqCmI,0BAArC,EAAgEG,SAAhE,CAAJ,EAAgF;AAC9E,kBAAIA,SAAS,CAACrB,UAAV,CAAqB,CAArB,IAAwB,GAA5B,EAAiC;AAC/B,qBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,kBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAAxC;AACA,sBAAIC,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,oBAAAA,qBAAqB,GAAG,CAAxB;AACAF,oBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,oBAAAA,gBAAgB,GAAG,CAAnB;AACD,mBAJD,MAIO;AACLC,oBAAAA,qBAAqB;AACtB;AACF;AACDrF,gBAAAA,KAAK,GAAG+E,SAAS,CAACrB,UAAV,CAAqB,CAArB,CAAR;AACA,qBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC,CAAb,EAAiBA,CAAC,EAAlB,EAAsB;AACpBiJ,kBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,sBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,oBAAAA,qBAAqB,GAAG,CAAxB;AACAF,oBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,oBAAAA,gBAAgB,GAAG,CAAnB;AACD,mBAJD,MAIO;AACLC,oBAAAA,qBAAqB;AACtB;AACDrF,kBAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AACF,eAvBD,MAuBO;AACLA,gBAAAA,KAAK,GAAG,CAAR;AACA,qBAAK7D,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,kBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA0BpF,KAA7C;AACA,sBAAIqF,qBAAqB,IAAGZ,WAAW,GAAC,CAAxC,EAA2C;AACzCY,oBAAAA,qBAAqB,GAAG,CAAxB;AACAF,oBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,oBAAAA,gBAAgB,GAAG,CAAnB;AACD,mBAJD,MAIO;AACLC,oBAAAA,qBAAqB;AACtB;AACDrF,kBAAAA,KAAK,GAAG,CAAR;AACD;AACDA,gBAAAA,KAAK,GAAG+E,SAAS,CAACrB,UAAV,CAAqB,CAArB,CAAR;AACA,qBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC,EAAb,EAAkBA,CAAC,EAAnB,EAAuB;AACrBiJ,kBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,sBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,oBAAAA,qBAAqB,GAAG,CAAxB;AACAF,oBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,oBAAAA,gBAAgB,GAAG,CAAnB;AACD,mBAJD,MAIO;AACLC,oBAAAA,qBAAqB;AACtB;AACDrF,kBAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AACF;AACDgF,cAAAA,iBAAiB;AACjB,kBAAIA,iBAAiB,IAAI,CAAzB,EAA4B;AAC1BA,gBAAAA,iBAAiB,GAAGS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYR,eAAZ,CAApB;AACAA,gBAAAA,eAAe;AAChB;AACD,qBAAON,0BAA0B,CAACG,SAAD,CAAjC;AACD,aAxDD,MAwDO;AACL/E,cAAAA,KAAK,GAAG2E,kBAAkB,CAACI,SAAD,CAA1B;AACA,mBAAK5I,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,gBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,oBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,kBAAAA,qBAAqB,GAAG,CAAxB;AACAF,kBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,kBAAAA,gBAAgB,GAAG,CAAnB;AACD,iBAJD,MAIO;AACLC,kBAAAA,qBAAqB;AACtB;AACDrF,gBAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AAGF;AACDgF,YAAAA,iBAAiB;AACjB,gBAAIA,iBAAiB,IAAI,CAAzB,EAA4B;AAC1BA,cAAAA,iBAAiB,GAAGS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYR,eAAZ,CAApB;AACAA,cAAAA,eAAe;AAChB,aA7EI;AA+ELP,YAAAA,kBAAkB,CAACG,UAAD,CAAlB,GAAiCG,gBAAgB,EAAjD;AACAF,YAAAA,SAAS,GAAGvC,MAAM,CAACqC,SAAD,CAAlB;AACD;AACF,SA5G6D;AA+G9D,YAAIE,SAAS,KAAK,EAAlB,EAAsB;AACpB,cAAIQ,MAAM,CAAChJ,SAAP,CAAiBiJ,cAAjB,CAAgC/I,IAAhC,CAAqCmI,0BAArC,EAAgEG,SAAhE,CAAJ,EAAgF;AAC9E,gBAAIA,SAAS,CAACrB,UAAV,CAAqB,CAArB,IAAwB,GAA5B,EAAiC;AAC/B,mBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,gBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAAxC;AACA,oBAAIC,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,kBAAAA,qBAAqB,GAAG,CAAxB;AACAF,kBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,kBAAAA,gBAAgB,GAAG,CAAnB;AACD,iBAJD,MAIO;AACLC,kBAAAA,qBAAqB;AACtB;AACF;AACDrF,cAAAA,KAAK,GAAG+E,SAAS,CAACrB,UAAV,CAAqB,CAArB,CAAR;AACA,mBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC,CAAb,EAAiBA,CAAC,EAAlB,EAAsB;AACpBiJ,gBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,oBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,kBAAAA,qBAAqB,GAAG,CAAxB;AACAF,kBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,kBAAAA,gBAAgB,GAAG,CAAnB;AACD,iBAJD,MAIO;AACLC,kBAAAA,qBAAqB;AACtB;AACDrF,gBAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AACF,aAvBD,MAuBO;AACLA,cAAAA,KAAK,GAAG,CAAR;AACA,mBAAK7D,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,gBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA0BpF,KAA7C;AACA,oBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,kBAAAA,qBAAqB,GAAG,CAAxB;AACAF,kBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,kBAAAA,gBAAgB,GAAG,CAAnB;AACD,iBAJD,MAIO;AACLC,kBAAAA,qBAAqB;AACtB;AACDrF,gBAAAA,KAAK,GAAG,CAAR;AACD;AACDA,cAAAA,KAAK,GAAG+E,SAAS,CAACrB,UAAV,CAAqB,CAArB,CAAR;AACA,mBAAKvH,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC,EAAb,EAAkBA,CAAC,EAAnB,EAAuB;AACrBiJ,gBAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,oBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,kBAAAA,qBAAqB,GAAG,CAAxB;AACAF,kBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,kBAAAA,gBAAgB,GAAG,CAAnB;AACD,iBAJD,MAIO;AACLC,kBAAAA,qBAAqB;AACtB;AACDrF,gBAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AACF;AACDgF,YAAAA,iBAAiB;AACjB,gBAAIA,iBAAiB,IAAI,CAAzB,EAA4B;AAC1BA,cAAAA,iBAAiB,GAAGS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYR,eAAZ,CAApB;AACAA,cAAAA,eAAe;AAChB;AACD,mBAAON,0BAA0B,CAACG,SAAD,CAAjC;AACD,WAxDD,MAwDO;AACL/E,YAAAA,KAAK,GAAG2E,kBAAkB,CAACI,SAAD,CAA1B;AACA,iBAAK5I,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,cAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,kBAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,gBAAAA,qBAAqB,GAAG,CAAxB;AACAF,gBAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,gBAAAA,gBAAgB,GAAG,CAAnB;AACD,eAJD,MAIO;AACLC,gBAAAA,qBAAqB;AACtB;AACDrF,cAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD;AAGF;AACDgF,UAAAA,iBAAiB;AACjB,cAAIA,iBAAiB,IAAI,CAAzB,EAA4B;AAC1BA,YAAAA,iBAAiB,GAAGS,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYR,eAAZ,CAApB;AACAA,YAAAA,eAAe;AAChB;AACF,SA7L6D;AAgM9DlF,QAAAA,KAAK,GAAG,CAAR;AACA,aAAK7D,CAAC,GAAC,CAAP,EAAWA,CAAC,GAAC+I,eAAb,EAA+B/I,CAAC,EAAhC,EAAoC;AAClCiJ,UAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAArB,GAA2BpF,KAAK,GAAC,CAApD;AACA,cAAIqF,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CY,YAAAA,qBAAqB,GAAG,CAAxB;AACAF,YAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACAA,YAAAA,gBAAgB,GAAG,CAAnB;AACD,WAJD,MAIO;AACLC,YAAAA,qBAAqB;AACtB;AACDrF,UAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACD,SA3M6D;AA8M9D,eAAO,IAAP,EAAa;AACXoF,UAAAA,gBAAgB,GAAIA,gBAAgB,IAAI,CAAxC;AACA,cAAIC,qBAAqB,IAAIZ,WAAW,GAAC,CAAzC,EAA4C;AAC1CU,YAAAA,YAAY,CAACpH,IAAb,CAAkB2G,cAAc,CAACU,gBAAD,CAAhC;AACA;AACD,WAHD,MAIKC,qBAAqB;AAC3B;AACD,eAAOF,YAAY,CAACd,IAAb,CAAkB,EAAlB,CAAP;AACD,OAxSY;AA0SbF,MAAAA,UAAU,EAAE,oBAAUV,UAAV,EAAsB;AAChC,YAAIA,UAAU,IAAI,IAAlB,EAAwB,OAAO,EAAP;AACxB,YAAIA,UAAU,IAAI,EAAlB,EAAsB,OAAO,IAAP;AACtB,eAAOlB,QAAQ,CAACe,WAAT,CAAqBG,UAAU,CAACvH,MAAhC,EAAwC,KAAxC,EAA+C,UAAS0B,KAAT,EAAgB;AAAE,iBAAO6F,UAAU,CAACC,UAAX,CAAsB9F,KAAtB,CAAP;AAAsC,SAAvG,CAAP;AACD,OA9SY;AAgTb0F,MAAAA,WAAW,EAAE,qBAAUpH,MAAV,EAAkByJ,UAAlB,EAA8BC,YAA9B,EAA4C;AACvD,YAAIC,UAAU,GAAG,EAAjB;AAAA,YAEIC,SAAS,GAAG,CAFhB;AAAA,YAGIC,QAAQ,GAAG,CAHf;AAAA,YAIIC,OAAO,GAAG,CAJd;AAAA,YAKIC,KAAK,GAAG,EALZ;AAAA,YAMI7B,MAAM,GAAG,EANb;AAAA,YAOIjI,CAPJ;AAAA,YAQI+J,CARJ;AAAA,YASIC,IATJ;AAAA,YASUC,IATV;AAAA,YASgBC,QAThB;AAAA,YAS0BC,KAT1B;AAAA,YAUIxF,CAVJ;AAAA,YAWIyF,IAAI,GAAG;AAACC,UAAAA,GAAG,EAACZ,YAAY,CAAC,CAAD,CAAjB;AAAsBa,UAAAA,QAAQ,EAACd,UAA/B;AAA2C/H,UAAAA,KAAK,EAAC;AAAjD;AAEX,aAAKzB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2B;AACzB0J,UAAAA,UAAU,CAAC1J,CAAD,CAAV,GAAgBA,CAAhB;AACD;AAEDgK,QAAAA,IAAI,GAAG,CAAP;AACAE,QAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAW,CAAX,CAAX;AACAY,QAAAA,KAAK,GAAC,CAAN;AACA,eAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,UAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,UAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,cAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,YAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,YAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,UAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,UAAAA,KAAK,KAAK,CAAV;AACD;AAED,gBAAeH,IAAf;AACE,eAAK,CAAL;AACIA,YAAAA,IAAI,GAAG,CAAP;AACAE,YAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAW,CAAX,CAAX;AACAY,YAAAA,KAAK,GAAC,CAAN;AACA,mBAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,cAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,cAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,kBAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,gBAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,gBAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,cAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,cAAAA,KAAK,KAAK,CAAV;AACD;AACHxF,YAAAA,CAAC,GAAGqB,CAAC,CAACgE,IAAD,CAAL;AACA;AACF,eAAK,CAAL;AACIA,YAAAA,IAAI,GAAG,CAAP;AACAE,YAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAW,EAAX,CAAX;AACAY,YAAAA,KAAK,GAAC,CAAN;AACA,mBAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,cAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,cAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,kBAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,gBAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,gBAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,cAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,cAAAA,KAAK,KAAK,CAAV;AACD;AACHxF,YAAAA,CAAC,GAAGqB,CAAC,CAACgE,IAAD,CAAL;AACA;AACF,eAAK,CAAL;AACE,mBAAO,EAAP;AAlCJ;AAoCAN,QAAAA,UAAU,CAAC,CAAD,CAAV,GAAgB/E,CAAhB;AACAoF,QAAAA,CAAC,GAAGpF,CAAJ;AACAsD,QAAAA,MAAM,CAACrG,IAAP,CAAY+C,CAAZ;AACA,eAAO,IAAP,EAAa;AACX,cAAIyF,IAAI,CAAC3I,KAAL,GAAa1B,MAAjB,EAAyB;AACvB,mBAAO,EAAP;AACD;AAEDiK,UAAAA,IAAI,GAAG,CAAP;AACAE,UAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAWM,OAAX,CAAX;AACAM,UAAAA,KAAK,GAAC,CAAN;AACA,iBAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,YAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,YAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,gBAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,cAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,cAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,YAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,YAAAA,KAAK,KAAK,CAAV;AACD;AAED,kBAAQxF,CAAC,GAAGqF,IAAZ;AACE,iBAAK,CAAL;AACEA,cAAAA,IAAI,GAAG,CAAP;AACAE,cAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAW,CAAX,CAAX;AACAY,cAAAA,KAAK,GAAC,CAAN;AACA,qBAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,gBAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,gBAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,oBAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,kBAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,kBAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,gBAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,gBAAAA,KAAK,KAAK,CAAV;AACD;AAEDT,cAAAA,UAAU,CAACE,QAAQ,EAAT,CAAV,GAAyB5D,CAAC,CAACgE,IAAD,CAA1B;AACArF,cAAAA,CAAC,GAAGiF,QAAQ,GAAC,CAAb;AACAD,cAAAA,SAAS;AACT;AACF,iBAAK,CAAL;AACEK,cAAAA,IAAI,GAAG,CAAP;AACAE,cAAAA,QAAQ,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAW,EAAX,CAAX;AACAY,cAAAA,KAAK,GAAC,CAAN;AACA,qBAAOA,KAAK,IAAED,QAAd,EAAwB;AACtBD,gBAAAA,IAAI,GAAGG,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,QAAvB;AACAF,gBAAAA,IAAI,CAACE,QAAL,KAAkB,CAAlB;AACA,oBAAIF,IAAI,CAACE,QAAL,IAAiB,CAArB,EAAwB;AACtBF,kBAAAA,IAAI,CAACE,QAAL,GAAgBd,UAAhB;AACAY,kBAAAA,IAAI,CAACC,GAAL,GAAWZ,YAAY,CAACW,IAAI,CAAC3I,KAAL,EAAD,CAAvB;AACD;AACDuI,gBAAAA,IAAI,IAAI,CAACC,IAAI,GAAC,CAAL,GAAS,CAAT,GAAa,CAAd,IAAmBE,KAA3B;AACAA,gBAAAA,KAAK,KAAK,CAAV;AACD;AACDT,cAAAA,UAAU,CAACE,QAAQ,EAAT,CAAV,GAAyB5D,CAAC,CAACgE,IAAD,CAA1B;AACArF,cAAAA,CAAC,GAAGiF,QAAQ,GAAC,CAAb;AACAD,cAAAA,SAAS;AACT;AACF,iBAAK,CAAL;AACE,qBAAO1B,MAAM,CAACC,IAAP,CAAY,EAAZ,CAAP;AAvCJ;AA0CA,cAAIyB,SAAS,IAAI,CAAjB,EAAoB;AAClBA,YAAAA,SAAS,GAAGL,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYM,OAAZ,CAAZ;AACAA,YAAAA,OAAO;AACR;AAED,cAAIH,UAAU,CAAC/E,CAAD,CAAd,EAAmB;AACjBmF,YAAAA,KAAK,GAAGJ,UAAU,CAAC/E,CAAD,CAAlB;AACD,WAFD,MAEO;AACL,gBAAIA,CAAC,KAAKiF,QAAV,EAAoB;AAClBE,cAAAA,KAAK,GAAGC,CAAC,GAAGA,CAAC,CAAClD,MAAF,CAAS,CAAT,CAAZ;AACD,aAFD,MAEO;AACL,qBAAO,IAAP;AACD;AACF;AACDoB,UAAAA,MAAM,CAACrG,IAAP,CAAYkI,KAAZ,EA3EW;AA8EXJ,UAAAA,UAAU,CAACE,QAAQ,EAAT,CAAV,GAAyBG,CAAC,GAAGD,KAAK,CAACjD,MAAN,CAAa,CAAb,CAA7B;AACA8C,UAAAA,SAAS;AAETI,UAAAA,CAAC,GAAGD,KAAJ;AAEA,cAAIH,SAAS,IAAI,CAAjB,EAAoB;AAClBA,YAAAA,SAAS,GAAGL,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYM,OAAZ,CAAZ;AACAA,YAAAA,OAAO;AACR;AAEF;AACF;AAhdY,KAAf;AAkdE,WAAOzD,QAAP;AACD,GArec,EAAf;AAueA,EAEO,IAAqCmE,MAAM,IAAI,IAA/C,EAAsD;AAC3DA,IAAAA,cAAA,GAAiBnE,QAAjB;;;;;SC5ec,eAAe,MAAmB;AAChD,SAAO,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,SAAhB,EACJ,IADI,CACC,UAAC,CAAD;AAAA,WAAO,CAAC,CAAC,UAAF,CAAa,OAAb,CAAP;AAAA,GADD,EAEJ,KAFI,CAEE,QAAQ,MAFV,CAAP;AAGD;SAEe,aAAa,MAAqB,SAAe;;AAC/D,SAAO,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,aAAL,0BAAqC,OAArC,EAAA,MAA+C,IAA/C,IAA+C,EAAA,KAAA,KAAA,CAA/C,GAA+C,KAAA,CAA/C,GAA+C,EAAA,CAAE,WAAjD,MAA4D,IAA5D,IAA4D,EAAA,KAAA,KAAA,CAA5D,GAA4D,EAA5D,GAAgE,SAAvE;AACD;SAEe,mBAAmB,MAAqB,SAAe;;AACrE,SAAO,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,IAAI,CAAC,aAAL,yBAAoC,OAApC,EAAA,MAA8C,IAA9C,IAA8C,EAAA,KAAA,KAAA,CAA9C,GAA8C,KAAA,CAA9C,GAA8C,EAAA,CAAE,WAAhD,MAA2D,IAA3D,IAA2D,EAAA,KAAA,KAAA,CAA3D,GAA2D,EAA3D,GAA+D,EAAtE;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}